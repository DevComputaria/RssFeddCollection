<?xml version='1.0' encoding='UTF-8'?><?xml-stylesheet href="http://www.blogger.com/styles/atom.css" type="text/css"?><entry xmlns='http://www.w3.org/2005/Atom' xmlns:blogger='http://schemas.google.com/blogger/2008' xmlns:georss='http://www.georss.org/georss' xmlns:gd='http://schemas.google.com/g/2005' xmlns:thr='http://purl.org/syndication/thread/1.0'><id>tag:blogger.com,1999:blog-4838136820032157985.post-6510029969921067809</id><published>2021-10-20T09:26:00.000-07:00</published><updated>2021-10-21T09:00:10.361-07:00</updated><title type='text'>Using Kerberos for Authentication Relay Attacks</title><content type='html'>&lt;style type=&quot;text/css&quot;&gt;ol.lst-kix_d25vxsk234hv-6{list-style-type:none}.lst-kix_wkcrlfh2qk3l-7&gt;li{counter-increment:lst-ctn-kix_wkcrlfh2qk3l-7}.lst-kix_i2wckd3yhfhe-0&gt;li{counter-increment:lst-ctn-kix_i2wckd3yhfhe-0}ol.lst-kix_i2wckd3yhfhe-5.start{counter-reset:lst-ctn-kix_i2wckd3yhfhe-5 0}ol.lst-kix_d25vxsk234hv-5{list-style-type:none}ol.lst-kix_d25vxsk234hv-4{list-style-type:none}ol.lst-kix_jp16emg17n48-2.start{counter-reset:lst-ctn-kix_jp16emg17n48-2 0}ol.lst-kix_d25vxsk234hv-3{list-style-type:none}ol.lst-kix_i2wckd3yhfhe-8{list-style-type:none}ol.lst-kix_d25vxsk234hv-2{list-style-type:none}ol.lst-kix_d25vxsk234hv-3.start{counter-reset:lst-ctn-kix_d25vxsk234hv-3 0}ol.lst-kix_d25vxsk234hv-1{list-style-type:none}ol.lst-kix_d25vxsk234hv-0{list-style-type:none}.lst-kix_d25vxsk234hv-4&gt;li{counter-increment:lst-ctn-kix_d25vxsk234hv-4}.lst-kix_jp16emg17n48-8&gt;li{counter-increment:lst-ctn-kix_jp16emg17n48-8}ul.lst-kix_fmj6vk2ylkib-0{list-style-type:none}ul.lst-kix_fmj6vk2ylkib-1{list-style-type:none}ol.lst-kix_d25vxsk234hv-6.start{counter-reset:lst-ctn-kix_d25vxsk234hv-6 0}ol.lst-kix_i2wckd3yhfhe-4{list-style-type:none}ul.lst-kix_fmj6vk2ylkib-8{list-style-type:none}.lst-kix_wkcrlfh2qk3l-8&gt;li{counter-increment:lst-ctn-kix_wkcrlfh2qk3l-8}ol.lst-kix_i2wckd3yhfhe-5{list-style-type:none}ol.lst-kix_i2wckd3yhfhe-6{list-style-type:none}ul.lst-kix_fmj6vk2ylkib-6{list-style-type:none}ol.lst-kix_i2wckd3yhfhe-7{list-style-type:none}ul.lst-kix_fmj6vk2ylkib-7{list-style-type:none}ol.lst-kix_i2wckd3yhfhe-0{list-style-type:none}ul.lst-kix_fmj6vk2ylkib-4{list-style-type:none}ol.lst-kix_i2wckd3yhfhe-1{list-style-type:none}ul.lst-kix_fmj6vk2ylkib-5{list-style-type:none}ol.lst-kix_i2wckd3yhfhe-2{list-style-type:none}ul.lst-kix_fmj6vk2ylkib-2{list-style-type:none}ol.lst-kix_i2wckd3yhfhe-3{list-style-type:none}ul.lst-kix_fmj6vk2ylkib-3{list-style-type:none}.lst-kix_2yktnm17nyl7-2&gt;li:before{content:&quot;\0025a0  &quot;}.lst-kix_2yktnm17nyl7-3&gt;li:before{content:&quot;\0025cf  &quot;}ul.lst-kix_2yktnm17nyl7-8{list-style-type:none}ul.lst-kix_2yktnm17nyl7-7{list-style-type:none}ul.lst-kix_2yktnm17nyl7-6{list-style-type:none}.lst-kix_d25vxsk234hv-2&gt;li{counter-increment:lst-ctn-kix_d25vxsk234hv-2}.lst-kix_2yktnm17nyl7-1&gt;li:before{content:&quot;\0025cb  &quot;}.lst-kix_d25vxsk234hv-5&gt;li{counter-increment:lst-ctn-kix_d25vxsk234hv-5}.lst-kix_jp16emg17n48-7&gt;li{counter-increment:lst-ctn-kix_jp16emg17n48-7}ol.lst-kix_jp16emg17n48-8.start{counter-reset:lst-ctn-kix_jp16emg17n48-8 0}ol.lst-kix_d25vxsk234hv-0.start{counter-reset:lst-ctn-kix_d25vxsk234hv-0 0}.lst-kix_2yktnm17nyl7-0&gt;li:before{content:&quot;\0025cf  &quot;}.lst-kix_jp16emg17n48-4&gt;li:before{content:&quot;(&quot; counter(lst-ctn-kix_jp16emg17n48-4,lower-latin) &quot;) &quot;}ol.lst-kix_wkcrlfh2qk3l-6.start{counter-reset:lst-ctn-kix_wkcrlfh2qk3l-6 0}.lst-kix_jp16emg17n48-3&gt;li:before{content:&quot;(&quot; counter(lst-ctn-kix_jp16emg17n48-3,decimal) &quot;) &quot;}.lst-kix_jp16emg17n48-5&gt;li:before{content:&quot;(&quot; counter(lst-ctn-kix_jp16emg17n48-5,lower-roman) &quot;) &quot;}ul.lst-kix_2yktnm17nyl7-1{list-style-type:none}.lst-kix_jp16emg17n48-0&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_jp16emg17n48-0,decimal) &quot;) &quot;}ul.lst-kix_2yktnm17nyl7-0{list-style-type:none}.lst-kix_jp16emg17n48-1&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_jp16emg17n48-1,lower-latin) &quot;) &quot;}ul.lst-kix_2yktnm17nyl7-5{list-style-type:none}.lst-kix_jp16emg17n48-2&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_jp16emg17n48-2,lower-roman) &quot;) &quot;}.lst-kix_wkcrlfh2qk3l-6&gt;li{counter-increment:lst-ctn-kix_wkcrlfh2qk3l-6}ul.lst-kix_2yktnm17nyl7-4{list-style-type:none}ol.lst-kix_i2wckd3yhfhe-0.start{counter-reset:lst-ctn-kix_i2wckd3yhfhe-0 0}ol.lst-kix_jp16emg17n48-5.start{counter-reset:lst-ctn-kix_jp16emg17n48-5 0}ul.lst-kix_2yktnm17nyl7-3{list-style-type:none}ol.lst-kix_d25vxsk234hv-8{list-style-type:none}ul.lst-kix_2yktnm17nyl7-2{list-style-type:none}ol.lst-kix_d25vxsk234hv-7{list-style-type:none}ol.lst-kix_wkcrlfh2qk3l-3.start{counter-reset:lst-ctn-kix_wkcrlfh2qk3l-3 0}.lst-kix_jp16emg17n48-0&gt;li{counter-increment:lst-ctn-kix_jp16emg17n48-0}.lst-kix_jp16emg17n48-7&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_jp16emg17n48-7,lower-latin) &quot;. &quot;}ol.lst-kix_i2wckd3yhfhe-3.start{counter-reset:lst-ctn-kix_i2wckd3yhfhe-3 0}.lst-kix_jp16emg17n48-6&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_jp16emg17n48-6,decimal) &quot;. &quot;}ol.lst-kix_i2wckd3yhfhe-7.start{counter-reset:lst-ctn-kix_i2wckd3yhfhe-7 0}.lst-kix_jp16emg17n48-6&gt;li{counter-increment:lst-ctn-kix_jp16emg17n48-6}.lst-kix_wkcrlfh2qk3l-5&gt;li{counter-increment:lst-ctn-kix_wkcrlfh2qk3l-5}ol.lst-kix_jp16emg17n48-4.start{counter-reset:lst-ctn-kix_jp16emg17n48-4 0}.lst-kix_jp16emg17n48-8&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_jp16emg17n48-8,lower-roman) &quot;. &quot;}ol.lst-kix_jp16emg17n48-3.start{counter-reset:lst-ctn-kix_jp16emg17n48-3 0}ol.lst-kix_wkcrlfh2qk3l-4.start{counter-reset:lst-ctn-kix_wkcrlfh2qk3l-4 0}.lst-kix_wkcrlfh2qk3l-2&gt;li{counter-increment:lst-ctn-kix_wkcrlfh2qk3l-2}ol.lst-kix_i2wckd3yhfhe-2.start{counter-reset:lst-ctn-kix_i2wckd3yhfhe-2 0}.lst-kix_d25vxsk234hv-0&gt;li{counter-increment:lst-ctn-kix_d25vxsk234hv-0}ol.lst-kix_d25vxsk234hv-5.start{counter-reset:lst-ctn-kix_d25vxsk234hv-5 0}ol.lst-kix_jp16emg17n48-8{list-style-type:none}.lst-kix_d25vxsk234hv-6&gt;li{counter-increment:lst-ctn-kix_d25vxsk234hv-6}ol.lst-kix_jp16emg17n48-7{list-style-type:none}.lst-kix_i2wckd3yhfhe-1&gt;li{counter-increment:lst-ctn-kix_i2wckd3yhfhe-1}ol.lst-kix_i2wckd3yhfhe-8.start{counter-reset:lst-ctn-kix_i2wckd3yhfhe-8 0}.lst-kix_i2wckd3yhfhe-4&gt;li{counter-increment:lst-ctn-kix_i2wckd3yhfhe-4}ol.lst-kix_jp16emg17n48-4{list-style-type:none}ol.lst-kix_jp16emg17n48-3{list-style-type:none}ol.lst-kix_jp16emg17n48-6{list-style-type:none}ol.lst-kix_jp16emg17n48-5{list-style-type:none}ol.lst-kix_jp16emg17n48-0{list-style-type:none}ol.lst-kix_jp16emg17n48-2{list-style-type:none}.lst-kix_d25vxsk234hv-3&gt;li{counter-increment:lst-ctn-kix_d25vxsk234hv-3}.lst-kix_i2wckd3yhfhe-7&gt;li{counter-increment:lst-ctn-kix_i2wckd3yhfhe-7}ol.lst-kix_jp16emg17n48-1{list-style-type:none}.lst-kix_fmj6vk2ylkib-1&gt;li:before{content:&quot;\0025cb  &quot;}.lst-kix_wkcrlfh2qk3l-1&gt;li{counter-increment:lst-ctn-kix_wkcrlfh2qk3l-1}.lst-kix_fmj6vk2ylkib-0&gt;li:before{content:&quot;\0025cf  &quot;}.lst-kix_fmj6vk2ylkib-2&gt;li:before{content:&quot;\0025a0  &quot;}.lst-kix_fmj6vk2ylkib-3&gt;li:before{content:&quot;\0025cf  &quot;}ol.lst-kix_wkcrlfh2qk3l-8.start{counter-reset:lst-ctn-kix_wkcrlfh2qk3l-8 0}.lst-kix_i2wckd3yhfhe-1&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_i2wckd3yhfhe-1,lower-latin) &quot;) &quot;}.lst-kix_jp16emg17n48-2&gt;li{counter-increment:lst-ctn-kix_jp16emg17n48-2}.lst-kix_i2wckd3yhfhe-2&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_i2wckd3yhfhe-2,lower-roman) &quot;) &quot;}.lst-kix_i2wckd3yhfhe-6&gt;li{counter-increment:lst-ctn-kix_i2wckd3yhfhe-6}.lst-kix_i2wckd3yhfhe-4&gt;li:before{content:&quot;(&quot; counter(lst-ctn-kix_i2wckd3yhfhe-4,lower-latin) &quot;) &quot;}.lst-kix_wkcrlfh2qk3l-7&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_wkcrlfh2qk3l-7,lower-latin) &quot;. &quot;}.lst-kix_wkcrlfh2qk3l-8&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_wkcrlfh2qk3l-8,lower-roman) &quot;. &quot;}.lst-kix_i2wckd3yhfhe-3&gt;li:before{content:&quot;(&quot; counter(lst-ctn-kix_i2wckd3yhfhe-3,decimal) &quot;) &quot;}.lst-kix_i2wckd3yhfhe-5&gt;li:before{content:&quot;(&quot; counter(lst-ctn-kix_i2wckd3yhfhe-5,lower-roman) &quot;) &quot;}.lst-kix_jp16emg17n48-3&gt;li{counter-increment:lst-ctn-kix_jp16emg17n48-3}.lst-kix_i2wckd3yhfhe-5&gt;li{counter-increment:lst-ctn-kix_i2wckd3yhfhe-5}ol.lst-kix_jp16emg17n48-6.start{counter-reset:lst-ctn-kix_jp16emg17n48-6 0}.lst-kix_i2wckd3yhfhe-8&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_i2wckd3yhfhe-8,lower-roman) &quot;. &quot;}.lst-kix_d25vxsk234hv-8&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_d25vxsk234hv-8,lower-roman) &quot;. &quot;}ol.lst-kix_wkcrlfh2qk3l-5.start{counter-reset:lst-ctn-kix_wkcrlfh2qk3l-5 0}ol.lst-kix_i2wckd3yhfhe-1.start{counter-reset:lst-ctn-kix_i2wckd3yhfhe-1 0}.lst-kix_i2wckd3yhfhe-7&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_i2wckd3yhfhe-7,lower-latin) &quot;. &quot;}.lst-kix_i2wckd3yhfhe-6&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_i2wckd3yhfhe-6,decimal) &quot;. &quot;}.lst-kix_jp16emg17n48-1&gt;li{counter-increment:lst-ctn-kix_jp16emg17n48-1}.lst-kix_d25vxsk234hv-4&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_d25vxsk234hv-4,lower-latin) &quot;. &quot;}.lst-kix_wkcrlfh2qk3l-0&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_wkcrlfh2qk3l-0,decimal) &quot;. &quot;}.lst-kix_d25vxsk234hv-8&gt;li{counter-increment:lst-ctn-kix_d25vxsk234hv-8}.lst-kix_jp16emg17n48-4&gt;li{counter-increment:lst-ctn-kix_jp16emg17n48-4}.lst-kix_d25vxsk234hv-3&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_d25vxsk234hv-3,decimal) &quot;. &quot;}.lst-kix_d25vxsk234hv-5&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_d25vxsk234hv-5,lower-roman) &quot;. &quot;}ol.lst-kix_i2wckd3yhfhe-6.start{counter-reset:lst-ctn-kix_i2wckd3yhfhe-6 0}.lst-kix_wkcrlfh2qk3l-1&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_wkcrlfh2qk3l-1,lower-latin) &quot;. &quot;}ol.lst-kix_wkcrlfh2qk3l-2.start{counter-reset:lst-ctn-kix_wkcrlfh2qk3l-2 0}.lst-kix_d25vxsk234hv-7&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_d25vxsk234hv-7,lower-latin) &quot;. &quot;}ol.lst-kix_d25vxsk234hv-4.start{counter-reset:lst-ctn-kix_d25vxsk234hv-4 0}.lst-kix_d25vxsk234hv-6&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_d25vxsk234hv-6,decimal) &quot;. &quot;}.lst-kix_wkcrlfh2qk3l-6&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_wkcrlfh2qk3l-6,decimal) &quot;. &quot;}.lst-kix_fmj6vk2ylkib-8&gt;li:before{content:&quot;\0025a0  &quot;}.lst-kix_fmj6vk2ylkib-7&gt;li:before{content:&quot;\0025cb  &quot;}.lst-kix_wkcrlfh2qk3l-5&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_wkcrlfh2qk3l-5,lower-roman) &quot;. &quot;}.lst-kix_wkcrlfh2qk3l-0&gt;li{counter-increment:lst-ctn-kix_wkcrlfh2qk3l-0}.lst-kix_i2wckd3yhfhe-0&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_i2wckd3yhfhe-0,decimal) &quot;) &quot;}.lst-kix_fmj6vk2ylkib-5&gt;li:before{content:&quot;\0025a0  &quot;}.lst-kix_d25vxsk234hv-0&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_d25vxsk234hv-0,decimal) &quot;. &quot;}.lst-kix_wkcrlfh2qk3l-3&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_wkcrlfh2qk3l-3,decimal) &quot;. &quot;}.lst-kix_wkcrlfh2qk3l-4&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_wkcrlfh2qk3l-4,lower-latin) &quot;. &quot;}ol.lst-kix_d25vxsk234hv-7.start{counter-reset:lst-ctn-kix_d25vxsk234hv-7 0}.lst-kix_wkcrlfh2qk3l-3&gt;li{counter-increment:lst-ctn-kix_wkcrlfh2qk3l-3}.lst-kix_fmj6vk2ylkib-4&gt;li:before{content:&quot;\0025cb  &quot;}.lst-kix_fmj6vk2ylkib-6&gt;li:before{content:&quot;\0025cf  &quot;}.lst-kix_d25vxsk234hv-1&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_d25vxsk234hv-1,lower-latin) &quot;. &quot;}.lst-kix_d25vxsk234hv-2&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_d25vxsk234hv-2,lower-roman) &quot;. &quot;}.lst-kix_wkcrlfh2qk3l-2&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_wkcrlfh2qk3l-2,lower-roman) &quot;. &quot;}.lst-kix_wkcrlfh2qk3l-4&gt;li{counter-increment:lst-ctn-kix_wkcrlfh2qk3l-4}.lst-kix_d25vxsk234hv-1&gt;li{counter-increment:lst-ctn-kix_d25vxsk234hv-1}ol.lst-kix_d25vxsk234hv-8.start{counter-reset:lst-ctn-kix_d25vxsk234hv-8 0}ol.lst-kix_d25vxsk234hv-1.start{counter-reset:lst-ctn-kix_d25vxsk234hv-1 0}.lst-kix_d25vxsk234hv-7&gt;li{counter-increment:lst-ctn-kix_d25vxsk234hv-7}.lst-kix_i2wckd3yhfhe-3&gt;li{counter-increment:lst-ctn-kix_i2wckd3yhfhe-3}.lst-kix_jp16emg17n48-5&gt;li{counter-increment:lst-ctn-kix_jp16emg17n48-5}ol.lst-kix_jp16emg17n48-7.start{counter-reset:lst-ctn-kix_jp16emg17n48-7 0}ol.lst-kix_wkcrlfh2qk3l-4{list-style-type:none}ol.lst-kix_wkcrlfh2qk3l-0.start{counter-reset:lst-ctn-kix_wkcrlfh2qk3l-0 0}ol.lst-kix_wkcrlfh2qk3l-3{list-style-type:none}ol.lst-kix_wkcrlfh2qk3l-2{list-style-type:none}ol.lst-kix_wkcrlfh2qk3l-1{list-style-type:none}.lst-kix_i2wckd3yhfhe-8&gt;li{counter-increment:lst-ctn-kix_i2wckd3yhfhe-8}ol.lst-kix_wkcrlfh2qk3l-0{list-style-type:none}ol.lst-kix_jp16emg17n48-1.start{counter-reset:lst-ctn-kix_jp16emg17n48-1 0}ol.lst-kix_i2wckd3yhfhe-4.start{counter-reset:lst-ctn-kix_i2wckd3yhfhe-4 0}ol.lst-kix_wkcrlfh2qk3l-8{list-style-type:none}.lst-kix_i2wckd3yhfhe-2&gt;li{counter-increment:lst-ctn-kix_i2wckd3yhfhe-2}ol.lst-kix_wkcrlfh2qk3l-7{list-style-type:none}.lst-kix_2yktnm17nyl7-4&gt;li:before{content:&quot;\0025cb  &quot;}ol.lst-kix_wkcrlfh2qk3l-6{list-style-type:none}ol.lst-kix_wkcrlfh2qk3l-5{list-style-type:none}ol.lst-kix_d25vxsk234hv-2.start{counter-reset:lst-ctn-kix_d25vxsk234hv-2 0}.lst-kix_2yktnm17nyl7-5&gt;li:before{content:&quot;\0025a0  &quot;}.lst-kix_2yktnm17nyl7-6&gt;li:before{content:&quot;\0025cf  &quot;}.lst-kix_2yktnm17nyl7-7&gt;li:before{content:&quot;\0025cb  &quot;}ol.lst-kix_wkcrlfh2qk3l-7.start{counter-reset:lst-ctn-kix_wkcrlfh2qk3l-7 0}.lst-kix_2yktnm17nyl7-8&gt;li:before{content:&quot;\0025a0  &quot;}li.li-bullet-0:before{margin-left:-18pt;white-space:nowrap;display:inline-block;min-width:18pt}ol.lst-kix_wkcrlfh2qk3l-1.start{counter-reset:lst-ctn-kix_wkcrlfh2qk3l-1 0}ol.lst-kix_jp16emg17n48-0.start{counter-reset:lst-ctn-kix_jp16emg17n48-0 0}ol{margin:0;padding:0}table td,table th{padding:0}.c29{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:49.5pt;border-top-color:#000000;border-bottom-style:solid}.c10{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:66.8pt;border-top-color:#000000;border-bottom-style:solid}.c11{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:468pt;border-top-color:#000000;border-bottom-style:solid}.c22{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:87pt;border-top-color:#000000;border-bottom-style:solid}.c30{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:81pt;border-top-color:#000000;border-bottom-style:solid}.c15{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:164.2pt;border-top-color:#000000;border-bottom-style:solid}.c3{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:&quot;Arial&quot;;font-style:normal}.c26{padding-top:18pt;padding-bottom:6pt;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c31{color:#434343;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:14pt;font-family:&quot;Arial&quot;;font-style:normal}.c32{padding-top:16pt;padding-bottom:4pt;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c0{padding-top:0pt;padding-bottom:0pt;line-height:1.5;orphans:2;widows:2;text-align:left}.c39{-webkit-text-decoration-skip:none;color:#000000;text-decoration:line-through;vertical-align:baseline;text-decoration-skip-ink:none;font-style:normal}.c38{color:#000000;text-decoration:none;vertical-align:super;font-style:normal}.c21{border-spacing:0;border-collapse:collapse;margin-right:auto}.c7{padding-top:0pt;padding-bottom:0pt;line-height:1.5;text-align:left}.c6{color:#000000;text-decoration:none;vertical-align:baseline;font-style:normal}.c8{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline}.c1{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:left}.c25{font-weight:400;font-size:11pt;font-family:&quot;Arial&quot;}.c37{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c19{font-weight:400;font-size:16pt;font-family:&quot;Arial&quot;}.c2{font-size:10pt;font-family:&quot;Courier New&quot;;font-weight:400}.c12{font-weight:400;font-size:11pt;font-family:&quot;Courier New&quot;}.c40{font-weight:400;font-size:10pt;font-family:&quot;Arial&quot;}.c14{color:#000000;text-decoration:none;vertical-align:baseline}.c42{font-family:&quot;Courier New&quot;;font-weight:400}.c16{border:1px solid black;margin:5px}.c18{margin-left:36pt;padding-left:0pt}.c5{color:inherit;text-decoration:inherit}.c24{padding:0;margin:0}.c28{background-color:#ffff00}.c33{background-color:#cccccc}.c9{height:11pt}.c17{color:#696969}.c34{color:#000080}.c4{font-style:italic}.c13{color:#0000ff}.c35{color:#8a2be2}.c36{color:#a31515}.c23{color:#a82d00}.c20{height:0pt}.c41{vertical-align:super}.c27{color:#8b0000}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:&quot;Arial&quot;}p{margin:0;color:#000000;font-size:11pt;font-family:&quot;Arial&quot;}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}&lt;/style&gt;&lt;/head&gt;&lt;body class=&quot;c37&quot;&gt;&lt;div&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;Posted by James Forshaw, Project Zero&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;This blog post is a summary of some research I&amp;#39;ve been doing into relaying Kerberos authentication in Windows domain environments. To keep this blog shorter I am going to assume you have a working knowledge of Windows network authentication, and specifically Kerberos and NTLM. For a quick primer on Kerberos see &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-kile/b4af186e-b2ff-43f9-b18e-eedb366abf13&quot;&gt;this page&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;which is part of Microsoft&amp;#39;s Kerberos extension documentation or you can always read &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://www.rfc-editor.org/rfc/rfc4120.txt&quot;&gt;RFC4120&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;.&lt;/span&gt;&lt;/p&gt;&lt;h2 class=&quot;c26&quot; id=&quot;h.yuh7isexpwgo&quot;&gt;&lt;span class=&quot;c6 c19&quot;&gt;Background&lt;/span&gt;&lt;/h2&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;Windows based enterprise networks rely on network authentication protocols, such as &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-nlmp/b38c36ed-2804-4868-a9ff-8dd3182128e4&quot;&gt;NT Lan Manager (NTLM)&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;and Kerberos to implement single sign on. These protocols allow domain users to seamlessly connect to corporate resources without having to repeatedly enter their passwords. This works by the computer&amp;#39;s &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Local Security Authority (LSA)&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;process storing the user&amp;#39;s credentials when the user first authenticates. The LSA can then reuse those credentials for network authentication without requiring user interaction.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;However, the convenience of not prompting the user for their credentials when performing network authentication has a downside. To be most useful, common clients for network protocols such as HTTP or SMB must automatically perform the authentication without user interaction otherwise it defeats the purpose of avoiding asking the user for their credentials. &lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;This automatic authentication can be a problem if an attacker can trick a user into connecting to a server they control. The attacker could induce the user&amp;#39;s network client to start an authentication process and use that information to authenticate to an unrelated service allowing the attacker to access that service&amp;#39;s resources as the user. When the authentication protocol is captured and forwarded to another system in this way it&amp;#39;s referred to as an Authentication Relay attack.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c25 c14 c4&quot;&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/a/AVvXsEjeIXhBwnBcGsUREqJ9YPAEyeTw99GDlcn_PmW7fyuxGGkop9HvtErkOKfvy6WXzeXZFfXdOR8C-StQgu3qPaE-t48EHnQ0xPbUgBDm3-jyO_dij-bFHf4Vw6v-ryL9D7FixnLa6I88bzvbkx-QNGx7Wxhc3GGWmJGa9Xbu1-HIZGM0SA1HQWcERC_y2w=s856&quot; style=&quot;display: block; padding: 1em 0;text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/a/AVvXsEjeIXhBwnBcGsUREqJ9YPAEyeTw99GDlcn_PmW7fyuxGGkop9HvtErkOKfvy6WXzeXZFfXdOR8C-StQgu3qPaE-t48EHnQ0xPbUgBDm3-jyO_dij-bFHf4Vw6v-ryL9D7FixnLa6I88bzvbkx-QNGx7Wxhc3GGWmJGa9Xbu1-HIZGM0SA1HQWcERC_y2w=s856&quot; border=&quot;0&quot; alt=&quot;Simple diagram of an authentication relay attack&quot; style=&quot;max-height: 750px; max-width: 600px;&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;Authentication relay attacks using the NTLM protocol were &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://web.archive.org/web/20030706050349/http://www.xfocus.net/articles/200305/smbrelay.html&quot;&gt;f&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://web.archive.org/web/20030706050349/http://www.xfocus.net/articles/200305/smbrelay.html&quot;&gt;irst published&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;all the way back in 2001 by Josh Buchbinder (Sir Dystic) of the Cult of the Dead Cow&lt;/span&gt;&lt;span&gt;. However, even in 2021 NTLM relay attacks still represent a threat in default configurations of Windows domain networks. The most recent major abuse of NTLM relay was through the &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://specterops.io/assets/resources/Certified_Pre-Owned.pdf&quot;&gt;Active Directory Certificate Services web enrollment service&lt;/a&gt;&lt;/span&gt;&lt;span&gt;. This combined with the &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://github.com/topotam/PetitPotam&quot;&gt;PetitPotam&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;technique to induce a Domain Controller to perform NTLM authentication allows for a Windows domain to be compromised by an unauthenticated attacker.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;Over the years Microsoft has made many efforts to mitigate authentication relay attacks. The best mitigations rely on the fact that the attacker does not have knowledge of the user&amp;#39;s password or control over the authentication process. This includes signing and encryption (sealing) of network traffic using a session key which is protected by the user&amp;#39;s password or channel binding as part of &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://msrc-blog.microsoft.com/2009/12/08/extended-protection-for-authentication/&quot;&gt;Extended Protection for Authentication (EPA)&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;which prevents relay of authentication to a network protocol under TLS.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;Another mitigation regularly proposed is to disable NTLM authentication either for particular services or network wide using &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/network-security-restrict-ntlm-ntlm-authentication-in-this-domain&quot;&gt;Group Policy&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;. While this has potential compatibility issues, restricting authentication to only Kerberos should be more secure. That got me thinking, is disabling NTLM sufficient to eliminate authentication relay attacks on Windows domains?&lt;/span&gt;&lt;/p&gt;&lt;h2 class=&quot;c26&quot; id=&quot;h.58jp1dccho9f&quot;&gt;&lt;span class=&quot;c6 c19&quot;&gt;Why are there no Kerberos Relay Attacks?&lt;/span&gt;&lt;/h2&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;The obvious question is, if NTLM is disabled could you relay Kerberos authentication instead? Searching for Kerberos Relay attacks doesn&amp;#39;t yield much public research that I could find. There is the &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://github.com/dirkjanm/krbrelayx&quot;&gt;krbrelayx&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;tool written by &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://twitter.com/_dirkjan&quot;&gt;Dirk-jan&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;which is similar in concept to the &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://github.com/SecureAuthCorp/impacket/tree/master/impacket/examples/ntlmrelayx&quot;&gt;ntlmrelayx&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;tool in &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://github.com/SecureAuthCorp/impacket&quot;&gt;impacket&lt;/a&gt;&lt;/span&gt;&lt;span&gt;, a common tool for performing NTLM authentication relay attacks&lt;/span&gt;&lt;span&gt;. However as the accompanying &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://dirkjanm.io/krbrelayx-unconstrained-delegation-abuse-toolkit/&quot;&gt;blog post&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;makes clear this is a tool to abuse &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://docs.microsoft.com/en-us/defender-for-identity/cas-isp-unconstrained-kerberos&quot;&gt;unconstrained delegation&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;rather than relay the authentication. &lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;I did find a &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://media.defcon.org/DEF%20CON%2029/DEF%20CON%2029%20presentations/Sagi%20Sheinfeld%20Eyal%20Karni%20Yaron%20Zinar%20-%20Using%20Machine-in-the-Middle%20to%20Attack%20Active%20Directory%20Authentication%20Schemes.pdf&quot;&gt;recent presentation&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;by Sagi Sheinfeld, &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://twitter.com/eyal_karni&quot;&gt;Eyal Karni&lt;/a&gt;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://twitter.com/YaronZi&quot;&gt;Yaron Zinar&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;from Crowdstrike at Defcon 29 (and also coming up at Blackhat EU 2021) which relayed Kerberos authentication. The presentation discussed MitM network traffic to specific servers, then relaying the Kerberos authentication. A MitM attack relies on being able to spoof an existing server through some mechanism, which is a well known risk. &amp;nbsp;The last line in the presentation is &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;&amp;quot;Microsoft Recommendation: Avoid being MITM&amp;rsquo;d&amp;hellip;&amp;quot;&lt;/span&gt;&lt;span&gt;&amp;nbsp;which seems a &lt;/span&gt;&lt;span&gt;reasonable approach to take if possible&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;However a MitM attack is slightly different to the common NTLM relay attack scenario where you can induce a domain joined system to authenticate to a server an attacker controls and then forward that authentication to an unrelated service. NTLM is easy to relay as it wasn&amp;#39;t designed to distinguish authentication to a particular service from any other. The only unique aspect was the server (and later client) challenge but that value wasn&amp;#39;t specific to the service and so authentication for say SMB could be forwarded to HTTP and the victim service couldn&amp;#39;t tell the difference. Subsequently EPA has been retrofitted onto NTLM to make the authentication specific to a service, but due to backwards compatibility these mitigations aren&amp;#39;t always used.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;On the other hand Kerberos has always required the target of the authentication to be specified beforehand through a &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;principal name&lt;/span&gt;&lt;span&gt;, typically this is a &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://docs.microsoft.com/en-us/windows/win32/ad/service-principal-names&quot;&gt;Service Principal Name (SPN)&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;although in certain circumstances it can be a &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;User Principal Name (UPN)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&amp;nbsp;The SPN is usually represented as a string of the form &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;CLASS/INSTANCE:PORT/NAME&lt;/span&gt;&lt;span&gt;, where &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;CLASS&lt;/span&gt;&lt;span&gt;&amp;nbsp;is the class of service, such as &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;HTTP&lt;/span&gt;&lt;span&gt;&amp;nbsp;or &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;CIFS&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;INSTANCE &lt;/span&gt;&lt;span&gt;is typically the DNS name of the server hosting the service and &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;PORT&lt;/span&gt;&lt;span&gt;&amp;nbsp;and &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;NAME&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;are optional.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;The SPN is used by the Kerberos &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Ticket Granting Server (TGS)&lt;/span&gt;&lt;span&gt;&amp;nbsp;to select the shared encryption key for a Kerberos service ticket generated for the authentication. This ticket contains the details of the authenticating user based on the contents of the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Ticket Granting Ticket (TGT)&lt;/span&gt;&lt;span&gt;&amp;nbsp;that was requested during the user&amp;#39;s initial Kerberos authentication process. The client can then package the service&amp;#39;s ticket into an &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Authentication Protocol Request (AP_REQ)&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;authentication token to send to the server.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;Without knowledge of the shared encryption key the Kerberos service ticket can&amp;#39;t be decrypted by the service and the authentication fails. Therefore if Kerberos authentication is attempted to an SMB service with the SPN &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;CIFS/fileserver.domain.com&lt;/span&gt;&lt;span&gt;, then that ticket shouldn&amp;#39;t be usable if the relay target is a HTTP service with the SPN &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;HTTP/fileserver.domain.com&lt;/span&gt;&lt;span&gt;, as the shared key should be different.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;In practice that&amp;#39;s rarely the case in Windows domain networks. The Domain Controller associates the SPN with a user account, most commonly the computer account of the domain joined server and the key is derived from the account&amp;#39;s password. The &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;CIFS/fileserver.domain.com&lt;/span&gt;&lt;span&gt;&amp;nbsp;and &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;HTTP/fileserver.domain.com &lt;/span&gt;&lt;span&gt;SPNs would likely be assigned to the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;FILESERVER$&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;computer account, therefore the shared encryption key will be the same for both SPNs and in theory the authentication could be relayed from one service to the other. The receiving service could query for the authenticated SPN string from the authentication APIs and then compare it to its expected value, but this check is typically optional.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;The selection of the SPN to use for the Kerberos authentication is typically defined by the target server&amp;#39;s host name. In a relay attack the attacker&amp;#39;s server will not be the same as the target. For example, the SMB connection might be targeting the attacker&amp;#39;s server, and will assign the SPN &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;CIFS/evil.com&lt;/span&gt;&lt;span&gt;. Assuming this SPN is even registered it would in all probability have a different shared encryption key to the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;CIFS/fileserver.domain.com &lt;/span&gt;&lt;span&gt;SPN due to the different computer accounts. Therefore relaying the authentication to the target SMB service will fail as the ticket can&amp;#39;t be decrypted.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;The requirement that the SPN is associated with the target service&amp;#39;s shared encryption key is why I assume few consider Kerberos relay attacks to be a major risk, if not impossible. There&amp;#39;s an assumption that an attacker cannot induce a client into generating a service ticket for an SPN which differs from the host the client is connecting to.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;However, there&amp;#39;s nothing inherently stopping Kerberos authentication being relayed if the attacker can control the SPN. The only way to stop relayed Kerberos authentication is for the service to protect itself through the use of signing/sealing or channel binding which rely on the shared knowledge between the client and server, but crucially not the attacker relaying the authentication. However, even now these service protections aren&amp;#39;t the default even on critical protocols such as LDAP.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;As the only limit on basic Kerberos relay (in the absence of service protections) is the selection of the SPN, this research focuses on how common protocols select the SPN and whether it can be influenced by the attacker to achieve Kerberos authentication relay.&lt;/span&gt;&lt;/p&gt;&lt;h2 class=&quot;c26&quot; id=&quot;h.8vjgkoldr6oj&quot;&gt;&lt;span class=&quot;c6 c19&quot;&gt;Kerberos Relay Requirements&lt;/span&gt;&lt;/h2&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;It&amp;#39;s easy to demonstrate in a controlled environment that Kerberos relay is possible. We can write a simple client which uses the &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://en.wikipedia.org/wiki/Security_Support_Provider_Interface&quot;&gt;Security Support Provider Interface (SSPI)&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;APIs to communicate with the LSA and implement the network authentication. This client calls the &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/sspi/nf-sspi-initializesecuritycontextw&quot;&gt;InitializeSecurityContext&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;API which will generate an AP_REQ authentication token containing a Kerberos Service Ticket for an arbitrary SPN. This AP_REQ can be forwarded to an intermediate server and then relayed to the service the SPN represents. You&amp;#39;ll find this will work, again to reiterate, assuming that no service protections are in place.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;However, there are some caveats in the way a client calls &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;InitializeSecurityContext&lt;/span&gt;&lt;span&gt;&amp;nbsp;which will impact how useful the generated AP_REQ is even if the attacker can influence the SPN. If the client specifies any one of the following request flags, &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;ISC_REQ_CONFIDENTIALITY,&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;ISC_REQ_INTEGRITY&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;ISC_REQ_REPLAY_DETECT&lt;/span&gt;&lt;span&gt;&amp;nbsp;or &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;ISC_REQ_SEQUENCE_DETECT&lt;/span&gt;&lt;span&gt;&amp;nbsp;then the generated AP_REQ will enable encryption and/or integrity checking. When the AP_REQ is received by the server using the &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/sspi/nf-sspi-acceptsecuritycontext&quot;&gt;AcceptSecurityContext&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span&gt;API it will return a set of flags which indicate if the client enabled encryption or integrity checking. Some services use these &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://docs.microsoft.com/en-us/windows/win32/secauthn/context-requirements&quot;&gt;returned flags&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;to opportunistically enable service protections. &lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;For example LDAP&amp;#39;s default setting is to enable signing/encryption if the client supports it. Therefore you shouldn&amp;#39;t be able to relay Kerberos authentication to LDAP if the client enabled any of these protections. However, other services such as HTTP don&amp;#39;t typically support signing and sealing and so will happily accept authentication tokens which specify the request flags.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;Another caveat is the client could specify channel binding information, typically derived from the certificate used by the TLS channel used in the communication. The channel binding information can be controlled by the attacker, but not set to arbitrary values without a bug in the TLS implementation or the code which determines the channel binding information itself. &lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;While services have an option to only enable channel binding if it&amp;#39;s supported by the client, all Windows Kerberos AP_REQ tokens indicate support through the &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-kile/b15648e2-439a-4d04-b8a2-2f34c45690f9&quot;&gt;KERB_AP_OPTIONS_CBT&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span&gt;options flag in the authenticator. &lt;/span&gt;&lt;span&gt;Sagi Sheinfeld et al did demonstrate (see slide 22 in &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://media.defcon.org/DEF%20CON%2029/DEF%20CON%2029%20presentations/Sagi%20Sheinfeld%20Eyal%20Karni%20Yaron%20Zinar%20-%20Using%20Machine-in-the-Middle%20to%20Attack%20Active%20Directory%20Authentication%20Schemes.pdf&quot;&gt;their presentation&lt;/a&gt;&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;&lt;span&gt;that if you can get the AP_REQ from a non-Windows source it will not set the options flag and so no channel binding is enforced, but that was apparently not something Microsoft will fix. It is also possible that a Windows client disables channel binding through a &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://docs.microsoft.com/en-us/troubleshoot/windows-server/windows-security/authentication-fails-non-windows-ntlm-kerberos-server&quot;&gt;registry configuration option&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;, although that seems to be unlikely in real world networks.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;If the client specifies the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;ISC_REQ_MUTUAL_AUTH&lt;/span&gt;&lt;span&gt;&amp;nbsp;request flag when generating the initial AP_REQ it will enable mutual authentication between the client and server. The client expects to receive an &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Authentication Protocol Response (AP_REP)&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;token from the server after sending the AP_REQ to prove it has possession of the shared encryption key. If the server doesn&amp;#39;t return a valid AP_REP the client can assume it&amp;#39;s a spoofed server and refuse to continue the communication. &lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;From a relay perspective, mutual authentication doesn&amp;#39;t really matter as the server is the target of the relay attack, not the client. The target server will assume the authentication has completed once it&amp;#39;s accepted the AP_REQ, so that&amp;#39;s all the attacker needs to forward. While the server will generate the AP_REP and return it to the attacker they can just drop it unless they need the relayed client to continue to participate in the communication for some reason.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;One final consideration is that the SSPI APIs have two security packages which can be used to implement Kerberos authentication, &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Negotiate&lt;/span&gt;&lt;span&gt;&amp;nbsp;and &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Kerberos&lt;/span&gt;&lt;span&gt;. The &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Negotiate&lt;/span&gt;&lt;span&gt;&amp;nbsp;protocol wraps the AP_REQ (and other authentication tokens) in the &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://datatracker.ietf.org/doc/html/rfc4178&quot;&gt;SPNEGO protocol&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;whereas &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Kerberos&lt;/span&gt;&lt;span&gt;&amp;nbsp;sends the authentication tokens using a simple GSS-API wrapper (see &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://datatracker.ietf.org/doc/html/rfc4121&quot;&gt;RFC4121&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;). &lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;The first potential issue is &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Negotiate&lt;/span&gt;&lt;span&gt;&amp;nbsp;is by far the most likely package in use as it allows a network protocol the flexibility to use the most appropriate authentication protocol that the client and server both support. However, what happens if the client uses the raw &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Kerberos &lt;/span&gt;&lt;span&gt;package but the server uses &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Negotiate&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;? &lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;This isn&amp;#39;t a problem as the server implementation of &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Negotiate &lt;/span&gt;&lt;span&gt;will pass the input token to the function &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;NegpDetermineTokenPackage&lt;/span&gt;&lt;span&gt;&amp;nbsp;in &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;lsasrv.dll&lt;/span&gt;&lt;span&gt;&amp;nbsp;during the first call to &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;AcceptSecurityContext&lt;/span&gt;&lt;span&gt;. This function detects if the client has passed a GSS-API Kerberos token (or NTLM) and enables a pass through mode where &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Negotiate &lt;/span&gt;&lt;span&gt;gets out of the way. Therefore even if the client uses the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Kerberos &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;package you can still authenticate to the server and keep the client happy without having to extract the inner authentication token or wrap up response tokens.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;One actual issue for relaying is the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Negotiate &lt;/span&gt;&lt;span&gt;protocol enables integrity protection (equivalent to passing &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;ISC_REQ_INTEGRITY&lt;/span&gt;&lt;span&gt;&amp;nbsp;to the underlying package) so that it can generate a &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Message Integrity Code (MIC)&lt;/span&gt;&lt;span&gt;&amp;nbsp;for the authentication exchange to prevent tampering. Using the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Kerberos &lt;/span&gt;&lt;span&gt;package directly won&amp;#39;t add integrity protection automatically. Therefore relaying Kerberos AP_REQs from &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Negotiate &lt;/span&gt;&lt;span&gt;will likely hit issues related to automatic enabling of signing on the server. It is possible for a client to explicitly disable automatic integrity checking by passing the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;ISC_REQ_NO_INTEGRITY&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;request attribute, but that&amp;#39;s not a common case.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;It&amp;#39;s possible to disable &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Negotiate &lt;/span&gt;&lt;span&gt;from the relay if the client passes an arbitrary authentication token to the first call of the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;InitializeSecurityContext&lt;/span&gt;&lt;span&gt;&amp;nbsp;API. On the first call the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Negotiate&lt;/span&gt;&lt;span&gt;&amp;nbsp;implementation will call the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;NegpDetermineTokenPackage&lt;/span&gt;&lt;span&gt;&amp;nbsp;function to determine whether to enable authentication pass through. If the initial token is NTLM or looks like a Kerberos token then it&amp;#39;ll pass through directly to the underlying security package and it won&amp;#39;t set &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;ISC_REQ_INTEGRITY&lt;/span&gt;&lt;span&gt;, unless the client explicitly requested it. The byte sequence [0x00, 0x01, 0x40] is sufficient to get &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Negotiate &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;to detect Kerberos, and the token is then discarded so it doesn&amp;#39;t have to contain any further valid data.&lt;/span&gt;&lt;/p&gt;&lt;h2 class=&quot;c26&quot; id=&quot;h.tx92zzdoh7eu&quot;&gt;&lt;span class=&quot;c6 c19&quot;&gt;Sniffing and Proxying Traffic&lt;/span&gt;&lt;/h2&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;Before going into individual protocols that I&amp;#39;ve researched, it&amp;#39;s worth discussing some more obvious ways of getting access to Kerberos authentication targeted at other services. First is sniffing network traffic sent from client to the server. For example, if the Kerberos AP_REQ is sent to a service over an unencrypted network protocol and the attacker can view that traffic the AP_REQ could be extracted and relayed. The selection of the SPN will be based on the expected traffic so the attacker doesn&amp;#39;t need to do anything to influence it.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;The Kerberos authentication protocol has protections against this attack vector. The Kerberos AP_REQ doesn&amp;#39;t just contain the service ticket, it&amp;#39;s also accompanied by an &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Authenticator&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;which is encrypted using the ticket&amp;#39;s session key. This key is accessible by both the legitimate client and the service. The authenticator contains a timestamp of when it was generated, and the service can check if this authenticator is within an allowable time range and whether it has seen the timestamp already. This allows the service to reject replayed authenticators by caching recently received values, and the allowable time window prevents the attacker waiting for any cache to expire before replaying.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;What this means is that while an attacker could sniff the Kerberos authentication on the wire and relay it, if the service has already received the authenticator it would be rejected as being a replay. The only way to exploit it would be to somehow prevent the legitimate authentication request from reaching the service, or race the request so that the attacker&amp;#39;s packet is processed first.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c4&quot;&gt;Note, &lt;/span&gt;&lt;span class=&quot;c8 c4&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://datatracker.ietf.org/doc/html/rfc4120#section-3.2.3&quot;&gt;RFC4120&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c25 c14 c4&quot;&gt;&amp;nbsp;mentions the possibility of embedding the client&amp;#39;s network address in the authenticator so that the service could reject authentication coming from the wrong host. This isn&amp;#39;t used by the Windows Kerberos implementation as far as I can tell. No doubt it would cause too many false positives for the replay protection in anything but the simplest enterprise networks.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;Therefore the only reliable way to exploit this scenario would be to actively interpose on the network communications between the client and service. This is of course practical and has been demonstrated many times assuming the traffic isn&amp;#39;t protected using something like TLS with server verification. Various attacks would be possible such as ARP or DNS spoofing attacks or HTTP proxy redirection to perform the &lt;/span&gt;&lt;span&gt;interposition&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;of the traffic.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;However, active MitM of protocols is a known risk and therefore an enterprise might have technical defenses in place to mitigate the issue. Of course, if such enterprises have enabled all the recommended relay protections,it&amp;#39;s a moot point. Regardless, we&amp;#39;ll assume that MitM is impractical for existing services due to protections in place and consider how individual protocols handle SPN selection.&lt;/span&gt;&lt;/p&gt;&lt;h2 class=&quot;c26&quot; id=&quot;h.jst25c8kuijh&quot;&gt;&lt;span class=&quot;c6 c19&quot;&gt;IPSec and AuthIP&lt;/span&gt;&lt;/h2&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;My research into Kerberos authentication relay came about in part because I was looking into the implementation of IPSec on Windows as part of my firewall research. Specifically I was researching the &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-aips/eee3de64-3847-4451-978e-9513ff187d30&quot;&gt;AuthIP ISAKMP&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;which allows for Windows authentication protocols to be used to establish IPsec Security Associations. &lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;I noticed that the AuthIP protocol has a &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-aips/9ab1ccc0-d92e-4ca4-bae9-1c93871399ac&quot;&gt;GSS-ID payload&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;which can be sent from the server to the client. This payload contains the textual SPN to use for the Kerberos authentication during the AuthIP process. This SPN is passed verbatim to the SSPI &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;InitializeSecurityContext&lt;/span&gt;&lt;span&gt;&amp;nbsp;call by the AuthIP client.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;As no verification is done on the format of the SPN in the GSS-ID payload, it allows the attacker to fully control the values including the service class and instance name. Therefore if an attacker can induce a domain joined machine to connect to an attacker controlled service and negotiate AuthIP then a Kerberos AP_REQ for an arbitrary SPN can be captured for relay use. As this AP_REQ is never sent to the target of the SPN it will not be detected as a replay.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;Inducing authentication isn&amp;#39;t necessarily difficult. Any IP traffic which is covered by the domain &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-firewall/configure-the-rules-to-require-encryption&quot;&gt;configured security connection rules&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;will attempt to perform AuthIP. For example it&amp;#39;s possible that a UDP response for a DNS request from the domain controller might be sufficient. AuthIP supports two authenticated users, the machine and the calling user. By default it seems the machine authenticates first, so if you convinced a Domain Controller to authenticate you&amp;#39;d get the DC computer account which c&lt;/span&gt;&lt;span&gt;ould be fairly exploitable.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c4&quot;&gt;For interest&amp;#39;s sake, the SPN is also used to determine the computer account associated with the server. This computer account is then used with &lt;/span&gt;&lt;span class=&quot;c8 c4&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-sfu/3bff5864-8135-400e-bdd9-33b552051d94&quot;&gt;Service For User (S4U)&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;&amp;nbsp;to generate a local access token allowing the client to determine the identity of the server. However I don&amp;#39;t think this is that useful as the fake server can&amp;#39;t complete the authentication and the connection will be discarded.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;The security connection rules use IP address ranges to determine what hosts need IPsec authentication. If these address ranges are too broad it&amp;#39;s also possible that ISAKMP AuthIP traffic might leak to external networks. For example if the rules don&amp;#39;t limit the network ranges to the enterprise&amp;#39;s addresses, then even a connection out to a public service could be accompanied by the ISAKMP AuthIP packet. This can be then exploited by an attacker who is not co-located on the enterprise network just by getting a client to connect to their server, such as through a web URL.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c4&quot;&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/a/AVvXsEiDuaDAyi9I9zQlGa5gBZnE1I_KIMDq-jtVM1kni1B7whSMYuGvC2xaQA75T9cjmVkuBzkHxQxWbN3hiEWaEeJ-Ci1aGxReamFMy83glKslnxT_evjrIy7SZl-yMvg3OgdamPqIttMyXw7kzSKjnbyny3qcrUSQFANJCH55j_FaeOaFFnsROkTr8ABomw=s835&quot; style=&quot;display: block; padding: 1em 0;text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/a/AVvXsEiDuaDAyi9I9zQlGa5gBZnE1I_KIMDq-jtVM1kni1B7whSMYuGvC2xaQA75T9cjmVkuBzkHxQxWbN3hiEWaEeJ-Ci1aGxReamFMy83glKslnxT_evjrIy7SZl-yMvg3OgdamPqIttMyXw7kzSKjnbyny3qcrUSQFANJCH55j_FaeOaFFnsROkTr8ABomw=s835&quot; border=&quot;0&quot; alt=&quot;Diagram of a relay using a fake AuthIP server&quot; style=&quot;max-height: 750px; max-width: 600px;&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;To summarize the attack process from the diagram:&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;c24 lst-kix_d25vxsk234hv-0 start&quot; start=&quot;1&quot;&gt;&lt;li style=&quot;margin-left: 46pt;&quot; class=&quot;c0 c18 li-bullet-0&quot;&gt;&lt;span&gt;Induce a client computer to send some network traffic to &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;EVILHOST&lt;/span&gt;&lt;span&gt;. It doesn&amp;#39;t really matter what the traffic is, only that the IP address, type and port must match an IP security connection rule to use AuthIP. &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;EVILHOST &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;does not need to be domain joined to perform the attack.&lt;/span&gt;&lt;/li&gt;&lt;li style=&quot;margin-left: 46pt;&quot; class=&quot;c0 c18 li-bullet-0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;The network traffic will get the Windows IPsec client to try and establish a security association with the target host.&lt;/span&gt;&lt;/li&gt;&lt;li style=&quot;margin-left: 46pt;&quot; class=&quot;c0 c18 li-bullet-0&quot;&gt;&lt;span&gt;A fake AuthIP server on the target host receives the request to establish a security association and returns a GSS-ID payload. This payload contains the target SPN, for example &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;CIFS/FILESERVER&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;.&lt;/span&gt;&lt;/li&gt;&lt;li style=&quot;margin-left: 46pt;&quot; class=&quot;c0 c18 li-bullet-0&quot;&gt;&lt;span&gt;The IPsec client uses the SPN to create an AP_REQ token and sends it to &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;EVILHOST&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;.&lt;/span&gt;&lt;/li&gt;&lt;li style=&quot;margin-left: 46pt;&quot; class=&quot;c0 c18 li-bullet-0&quot;&gt;&lt;span class=&quot;c4&quot;&gt;EVILHOST&lt;/span&gt;&lt;span&gt;&amp;nbsp;relays the Kerberos AP_REQ to the target service on &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;FILESERVER&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;.&lt;/span&gt;&lt;/li&gt;&lt;/ol&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;Relaying this AuthIP authentication isn&amp;#39;t ideal from an attacker&amp;#39;s perspective. As the authentication will be used to sign and seal the network traffic, the request context flags for the call to &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;InitializeSecurityContext&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;will require integrity and confidentiality protection. For network protocols such as LDAP which default to requiring signing and sealing if the client supports it, this would prevent the relay attack from working. However if the service ignores the protection and doesn&amp;#39;t have any further checks in place this would be sufficient. &lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;This issue was &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=2213&quot;&gt;reported to MSRC&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;and assigned case number 66900. However Microsoft have indicated that it will not be fixed with a security bulletin. &lt;/span&gt;&lt;span&gt;I&amp;#39;ve described Microsoft&amp;#39;s rationale for not fixing this issue later in the blog post&lt;/span&gt;&lt;span&gt;. If you want to reproduce this issue there&amp;#39;s details on Project Zero&amp;#39;s &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=2213&quot;&gt;issue tracker&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;.&lt;/span&gt;&lt;/p&gt;&lt;h2 class=&quot;c26&quot; id=&quot;h.27tuyymck8fh&quot;&gt;&lt;span class=&quot;c6 c19&quot;&gt;MSRPC&lt;/span&gt;&lt;/h2&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;After discovering that AuthIP could allow for authentication relay the next protocol I looked at is &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://docs.microsoft.com/en-us/windows/win32/rpc/rpc-start-page&quot;&gt;MSRPC&lt;/a&gt;&lt;/span&gt;&lt;span&gt;. The protocol supports &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;NTLM&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Kerberos&lt;/span&gt;&lt;span&gt;&amp;nbsp;or &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Negotiate&lt;/span&gt;&lt;span&gt;&amp;nbsp;authentication protocols over connected network transports such as named pipes or TCP. These authentication protocols need to be opted into by the server using the &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/rpcdce/nf-rpcdce-rpcserverregisterauthinfo&quot;&gt;RpcServerRegisterAuthInfo&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;API by specifying the authentication service constants of &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;RPC_C_AUTHN_WINNT&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;RPC_C_AUTHN_GSS_KERBEROS&lt;/span&gt;&lt;span&gt;&amp;nbsp;or &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;RPC_C_AUTHN_GSS_NEGOTIATE&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;respectively. When registering the authentication information the server can optionally specify the SPN that needs to be used by the client.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;However, this SPN isn&amp;#39;t actually used by the RPC server itself. Instead it&amp;#39;s registered with the runtime, and a client can query the server&amp;#39;s SPN using the &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/rpcdce/nf-rpcdce-rpcmgmtinqserverprincname&quot;&gt;RpcMgmtInqServerPrincName &lt;/a&gt;&lt;/span&gt;&lt;span&gt;management API. Once the SPN is queried the client can configure its authentication for the connection using the &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/rpcdce/nf-rpcdce-rpcbindingsetauthinfo&quot;&gt;RpcBindingSetAuthInfo&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;API. However, this isn&amp;#39;t required; the client could just generate the SPN manually and set it. If the client doesn&amp;#39;t call &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;RpcBindingSetAuthInfo&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;then it will not perform any authentication on the RPC connection.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c4&quot;&gt;Aside, curiously when a connection is made to the server it can query the client&amp;#39;s authentication information using the &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/rpcdce/nf-rpcdce-rpcbindinginqauthclient&quot;&gt;RpcBindingInqAuthClient&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;&amp;nbsp;API. However, the SPN that this API returns is the one registered by RpcServerRegisterAuthInfo and NOT the one which was used by the client to authenticate. Also Microsoft does mention the call to RpcMgmtInqServerPrincName in the &amp;quot;&lt;/span&gt;&lt;span class=&quot;c8 c4&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://docs.microsoft.com/en-us/windows/win32/rpc/choosing-security-qos-options&quot;&gt;Writing a secure RPC client or server&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c25 c14 c4&quot;&gt;&amp;quot; section on MSDN. However they frame it in the context of mutual authentication and not to protect against a relay attack.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;If a client queries for the SPN from a malicious RPC server it will authenticate using a Kerberos AP_REQ for an SPN fully under the attacker&amp;#39;s control. Whether the AP_REQ has integrity or confidentiality enabled depends on the authentication level set during the call to &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;RpcBindingSetAuthInfo&lt;/span&gt;&lt;span&gt;. If this is set to &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;RPC_C_AUTHN_LEVEL_CONNECT&lt;/span&gt;&lt;span&gt;&amp;nbsp;and the client uses &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;RPC_C_AUTHN_GSS_KERBEROS&lt;/span&gt;&lt;span&gt;&amp;nbsp;then the AP_REQ won&amp;#39;t have integrity enabled. However, if &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Negotiate &lt;/span&gt;&lt;span&gt;is used or anything above &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;RPC_C_AUTHN_LEVEL_CONNECT&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;as a level is used then it will have the integrity/confidentiality flags set.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;Doing a quick scan in &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;system32 &lt;/span&gt;&lt;span&gt;the following DLLs call the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;RpcMgmtInqServerPrincName&lt;/span&gt;&lt;span&gt;&amp;nbsp;API: &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;certcli.dll, dot3api.dll, dusmsvc.dll, FrameServerClient.dll, L2SecHC.dll, luiapi.dll, msdtcprx.dll, nlaapi.dll, ntfrsapi.dll, w32time.dll, WcnApi.dll, WcnEapAuthProxy.dll, WcnEapPeerProxy.dll, witnesswmiv2provider.dll, wlanapi.dll, wlanext.exe, WLanHC.dll, wlanmsm.dll, wlansvc.dll, wwansvc.dll, wwapi.dll. &lt;/span&gt;&lt;span&gt;Some basic analysis shows that none of these clients check the value of the SPN and use it verbatim with &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;RpcBindingSetAuthInfo&lt;/span&gt;&lt;span&gt;. That said, they all seem to use &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;RPC_C_AUTHN_GSS_NEGOTIATE&lt;/span&gt;&lt;span&gt;&amp;nbsp;and set the authentication level to &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;RPC_C_AUTHN_LEVEL_PKT_PRIVACY&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;which makes them less useful as an attack vector.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;If the client specifies &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;RPC_C_AUTHN_GSS_NEGOTIATE&lt;/span&gt;&lt;span&gt;&amp;nbsp;but does not specify an SPN then the runtime generates one automatically. This is based on the target hostname with the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;RestrictedKrbHost &lt;/span&gt;&lt;span&gt;service class. The runtime doesn&amp;#39;t process the hostname, it just concatenates strings and for some reason the runtime doesn&amp;#39;t support generating the SPN for &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;RPC_C_AUTHN_GSS_KERBEROS&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;One additional quirk of the RPC runtime is that the request attribute flag &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;ISC_REQ_USE_DCE_STYLE&lt;/span&gt;&lt;span&gt;&amp;nbsp;is used when calling &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;InitializeSecurityContext&lt;/span&gt;&lt;span&gt;. This enables a &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-kile/190ab8de-dc42-49cf-bf1b-ea5705b7a087&quot;&gt;special three-leg authentication mode&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;which results in the server sending back an AP_RET and then receiving another AP_RET from the client. Until that third AP_RET has been provided to the server it won&amp;#39;t consider the authentication complete so it&amp;#39;s not sufficient to just forward the initial AP_REQ token and close the connection to the client. This just makes the relay code slightly more complex but not impossible.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;A second change that &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;ISC_REQ_USE_DCE_STYLE&lt;/span&gt;&lt;span&gt;&amp;nbsp;introduces is that the Kerberos AP_REQ token does not have an GSS-API wrapper. This causes the call to &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;NegpDetermineTokenPackage&lt;/span&gt;&lt;span&gt;&amp;nbsp;to fail to detect the package in use, making it impossible to directly forward the traffic to a server using the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Negotiate&lt;/span&gt;&lt;span&gt;&amp;nbsp;package. However, this prefix is not protected against modification so the relay code can append the appropriate value before forwarding to the server. For example the following C# code can be used to convert a DCE style AP_REQ to a GSS-API format which &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Negotiate &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;will accept.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;a id=&quot;t.3c51830e72fcb7113b1dc4666718252f7b0b751f&quot;&gt;&lt;/a&gt;&lt;a id=&quot;t.0&quot;&gt;&lt;/a&gt;&lt;table class=&quot;c21&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;c20&quot;&gt;&lt;td class=&quot;c11&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c7&quot;&gt;&lt;span class=&quot;c2 c13&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c2 c13&quot;&gt;static&lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c2 c13&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;[] EncodeLength(&lt;/span&gt;&lt;span class=&quot;c2 c13&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;c6 c2&quot;&gt;&amp;nbsp;length)&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c7&quot;&gt;&lt;span class=&quot;c6 c2&quot;&gt;{&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c7&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp; &amp;nbsp; &lt;/span&gt;&lt;span class=&quot;c2 c13&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;c2 c6&quot;&gt;&amp;nbsp;(length &amp;lt; 0x80)&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c7&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &lt;/span&gt;&lt;span class=&quot;c2 c13&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c2 c13&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c2 c13&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;[] { (&lt;/span&gt;&lt;span class=&quot;c2 c13&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;c6 c2&quot;&gt;)length };&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c7&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp; &amp;nbsp; &lt;/span&gt;&lt;span class=&quot;c2 c13&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;c6 c2&quot;&gt;&amp;nbsp;(length &amp;lt; 0x100)&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c7&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &lt;/span&gt;&lt;span class=&quot;c2 c13&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c2 c13&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c2 c13&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;[] { 0x81, (&lt;/span&gt;&lt;span class=&quot;c2 c13&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;c6 c2&quot;&gt;)length };&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c7&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp; &amp;nbsp; &lt;/span&gt;&lt;span class=&quot;c2 c13&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;c6 c2&quot;&gt;&amp;nbsp;(length &amp;lt; 0x10000)&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c7&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &lt;/span&gt;&lt;span class=&quot;c2 c13&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c2 c13&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c2 c13&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;[] { 0x82, (&lt;/span&gt;&lt;span class=&quot;c2 c13&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;c6 c2&quot;&gt;)(length &amp;gt;&amp;gt; 8), &lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c7&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; (&lt;/span&gt;&lt;span class=&quot;c2 c13&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;c6 c2&quot;&gt;)(length &amp;amp; 0xFF) };&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c7&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp; &amp;nbsp; &lt;/span&gt;&lt;span class=&quot;c2 c13&quot;&gt;throw&lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c2 c13&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;ArgumentException(&lt;/span&gt;&lt;span class=&quot;c2 c36&quot;&gt;&amp;quot;Invalid length&amp;quot;&lt;/span&gt;&lt;span class=&quot;c6 c2&quot;&gt;, nameof(length));&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c7&quot;&gt;&lt;span class=&quot;c6 c2&quot;&gt;}&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c7 c9&quot;&gt;&lt;span class=&quot;c6 c2&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c7&quot;&gt;&lt;span class=&quot;c2 c13&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c2 c13&quot;&gt;static&lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c2 c13&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;[] ConvertApReq(&lt;/span&gt;&lt;span class=&quot;c2 c13&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;c6 c2&quot;&gt;[] token)&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c7&quot;&gt;&lt;span class=&quot;c6 c2&quot;&gt;{&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c7&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp; &amp;nbsp; &lt;/span&gt;&lt;span class=&quot;c2 c13&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;c6 c2&quot;&gt;&amp;nbsp;(token.Length == 0 || token[0] != 0x6E)&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c7&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &lt;/span&gt;&lt;span class=&quot;c2 c13&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;c6 c2&quot;&gt;&amp;nbsp;token;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c7&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp; &amp;nbsp; MemoryStream stm = &lt;/span&gt;&lt;span class=&quot;c2 c13&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;c6 c2&quot;&gt;&amp;nbsp;MemoryStream();&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c7&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp; &amp;nbsp; BinaryWriter writer = &lt;/span&gt;&lt;span class=&quot;c2 c13&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;c6 c2&quot;&gt;&amp;nbsp;BinaryWriter(stm);&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c7&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp; &amp;nbsp; Console.WriteLine(&lt;/span&gt;&lt;span class=&quot;c2 c36&quot;&gt;&amp;quot;Converting DCE AP_REQ to GSS-API format.&amp;quot;&lt;/span&gt;&lt;span class=&quot;c6 c2&quot;&gt;);&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c7&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp; &amp;nbsp; &lt;/span&gt;&lt;span class=&quot;c2 c13&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;[] header = &lt;/span&gt;&lt;span class=&quot;c2 c13&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c2 c13&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;c6 c2&quot;&gt;[] { 0x06, 0x09, 0x2a, 0x86, 0x48, &lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c7&quot;&gt;&lt;span class=&quot;c6 c2&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;0x86, 0xf7, 0x12, 0x01, 0x02, 0x02, 0x01, 0x00 };&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c7&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp; &amp;nbsp; writer.Write((&lt;/span&gt;&lt;span class=&quot;c2 c13&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;c6 c2&quot;&gt;)0x60);&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c7&quot;&gt;&lt;span class=&quot;c6 c2&quot;&gt;&amp;nbsp; &amp;nbsp; writer.Write(EncodeLength(header.Length + token.Length));&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c7&quot;&gt;&lt;span class=&quot;c6 c2&quot;&gt;&amp;nbsp; &amp;nbsp; writer.Write(header);&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c7&quot;&gt;&lt;span class=&quot;c6 c2&quot;&gt;&amp;nbsp; &amp;nbsp; writer.Write(token);&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c7&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp; &amp;nbsp; &lt;/span&gt;&lt;span class=&quot;c2 c13&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;c6 c2&quot;&gt;&amp;nbsp;stm.ToArray();&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c7&quot;&gt;&lt;span class=&quot;c2&quot;&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;Subsequent tokens in the authentication process don&amp;#39;t need to be wrapped; in fact, wrapping them with their GSS-API headers will cause the authentication to fail. Relaying MSRPC requests would probably be difficult just due to the relative lack of clients which request the server&amp;#39;s SPN. Also when the SPN is requested it tends to be a conscious act of securing the client and so best practice tends to require the developer to set the maximum authentication level, making the Kerberos AP_REQ less useful.&lt;/span&gt;&lt;/p&gt;&lt;h2 class=&quot;c26&quot; id=&quot;h.pn61xux6i1ia&quot;&gt;&lt;span class=&quot;c6 c19&quot;&gt;DCOM&lt;/span&gt;&lt;/h2&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;The DCOM protocol uses MSRPC under the hood to access remote COM objects, therefore it should have the same behavior as MSRPC. The big difference is DCOM is designed to automatically handle the authentication requirements of a remote COM object through binding information contained in the &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-dcom/7fe8200b-dccd-48cf-a2fa-681e3e0a23f4&quot;&gt;DUALSTRINGARRAY&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;returned during &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Object Exporter ID (OXID)&lt;/span&gt;&lt;span&gt;&amp;nbsp;resolving. Therefore the client doesn&amp;#39;t need to explicitly call &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;RpcBindingSetAuthInfo &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;to configure the authentication.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;The binding information contains the protocol sequence and endpoint to use (such as TCP on port 30000) as well as the security bindings. Each security binding contains the RPC authentication service (&lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;wAuthnSvc&lt;/span&gt;&lt;span&gt;&amp;nbsp;in the below screenshot) to use as well as an optional SPN (&lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;aPrincName&lt;/span&gt;&lt;span&gt;) for the authentication. Therefore a malicious DCOM server can force the client to use the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;RPC_C_AUTHN_GSS_KERBEROS&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;authentication service with a completely arbitrary SPN by returning an appropriate security binding.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c14 c4 c25&quot;&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/a/AVvXsEiN78ReCzU5wVJ3qCozRJ2MSkKX4-Bm_S0zDSU2TNs6BrYoBffMIr7WZuL4AiNiO8rbVWrTkdGwjp6S2yyQptBIh82kWiKNOU-ziSntZpjGETP1TfIvXYzKFQyyW9C_qMEyoM3c1-7tdoqNLWxh2RYuq1pgbBFAtUCTjyQZzrU1h7mOxFnAl2l1PQBEuw=s1372&quot; style=&quot;display: block; padding: 1em 0;text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/a/AVvXsEiN78ReCzU5wVJ3qCozRJ2MSkKX4-Bm_S0zDSU2TNs6BrYoBffMIr7WZuL4AiNiO8rbVWrTkdGwjp6S2yyQptBIh82kWiKNOU-ziSntZpjGETP1TfIvXYzKFQyyW9C_qMEyoM3c1-7tdoqNLWxh2RYuq1pgbBFAtUCTjyQZzrU1h7mOxFnAl2l1PQBEuw=s1372&quot; border=&quot;0&quot; alt=&quot;Screenshot of part of the MS-DCOM protocol documentation showing the SECURITYBINDING structure&quot; style=&quot;max-height: 750px; max-width: 600px;&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c25 c14 c4&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;The authentication level chosen by the client depends on the value of the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;dwAuthnLevel&lt;/span&gt;&lt;span&gt;&amp;nbsp;parameter specified if the COM client calls the &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/combaseapi/nf-combaseapi-coinitializesecurity&quot;&gt;CoInitializeSecurity&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;API.&lt;/span&gt;&lt;span&gt;&amp;nbsp;If the client doesn&amp;#39;t explicitly call &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;CoInitializeSecurity&lt;/span&gt;&lt;span&gt;&amp;nbsp;then a default will be used which &lt;/span&gt;&lt;span&gt;is currently &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;RPC_C_AUTHN_LEVEL_CONNECT.&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;This means neither integrity or confidentiality will be enforced on the Kerberos AP_REQ by default.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;One limitation is that without a call to &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;CoInitializeSecurity, &lt;/span&gt;&lt;span&gt;the default impersonation level for the client is set to &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;RPC_C_IMP_LEVEL_IDENTIFY&lt;/span&gt;&lt;span&gt;. This means the access token generated by the DCOM RPC authentication can only be used for identification and not for impersonation. For some services this isn&amp;#39;t an issue, for example LDAP doesn&amp;#39;t need an impersonation level token. However for others such as SMB this would prevent access to files. It&amp;#39;s possible that you could find a COM client which sets both &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;RPC_C_AUTHN_LEVEL_CONNECT &lt;/span&gt;&lt;span&gt;and &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;RPC_C_IMP_LEVEL_IMPERSONATE&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;though there&amp;#39;s no trivial process to assess that.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;Getting a client to connect to the server isn&amp;#39;t trivial as DCOM isn&amp;#39;t a widely used protocol on modern Windows networks due to high authentication requirements. However, one use case for this is local privilege escalation. For example you could get a privileged service to connect to the malicious COM server and relay the computer account Kerberos AP_REQ which is generated. I have a working PoC for this which allows a local non-admin user to connect to the domain&amp;#39;s LDAP server using the local computer&amp;#39;s credentials. &lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;This attack is somewhat similar to the &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://github.com/antonioCoco/RemotePotato0&quot;&gt;RemotePotato&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;attack (which uses NTLM rather than Kerberos) which again Microsoft have refused to fix. I&amp;#39;ll describe this in more detail in a separate &lt;/span&gt;&lt;span&gt;blog post after this one&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;.&lt;/span&gt;&lt;/p&gt;&lt;h2 class=&quot;c26&quot; id=&quot;h.hn66nwtnflze&quot;&gt;&lt;span class=&quot;c6 c19&quot;&gt;HTTP&lt;/span&gt;&lt;/h2&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;HTTP has supported &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;NTLM&lt;/span&gt;&lt;span&gt;&amp;nbsp;and &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Negotiate&lt;/span&gt;&lt;span&gt;&amp;nbsp;authentication for a long time (see &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://datatracker.ietf.org/doc/html/draft-brezak-spnego-http-04&quot;&gt;this draft&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;from 2002 although the most recent RFC is &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://datatracker.ietf.org/doc/html/rfc4559&quot;&gt;4559&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;from 2006). To initiate a Windows authentication session the server can respond to a request with the status code 401 and specify a &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;WWW-Authenticate&lt;/span&gt;&lt;span&gt;&amp;nbsp;header with the value &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Negotiate&lt;/span&gt;&lt;span&gt;. If the client supports Windows authentication it can use &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;InitializeSecurityContext&lt;/span&gt;&lt;span&gt;&amp;nbsp;to generate a token, convert the binary token into a Base64 string and send it in the next request to the server with the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Authorization&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;header. This process is repeated until the client errors or the authentication succeeds.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;In theory only &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;NTLM&lt;/span&gt;&lt;span&gt;&amp;nbsp;and &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Negotiate&lt;/span&gt;&lt;span&gt;&amp;nbsp;are defined but a HTTP implementation could use other Windows authentication packages such as &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Kerberos &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;if it so chose to. Whether the HTTP client will automatically use the user&amp;#39;s credentials is up to the user agent or the developer using it as a library.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;All the major browsers support both authentication types as well as many non browser HTTP user agents such as those in .NET and WinHTTP. I looked at the following implementations, all running on Windows 10 21H1:&lt;/span&gt;&lt;/p&gt;&lt;ul style=&quot;padding: 0;&quot; class=&quot;c24 lst-kix_fmj6vk2ylkib-0 start&quot;&gt;&lt;li style=&quot;margin-left: 46pt;&quot; class=&quot;c0 c18 li-bullet-0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;WinINET (Internet Explorer 11)&lt;/span&gt;&lt;/li&gt;&lt;li style=&quot;margin-left: 46pt;&quot; class=&quot;c0 c18 li-bullet-0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;WinHTTP (WebClient)&lt;/span&gt;&lt;/li&gt;&lt;li style=&quot;margin-left: 46pt;&quot; class=&quot;c0 c18 li-bullet-0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;Chromium M93 (Chrome and Edge)&lt;/span&gt;&lt;/li&gt;&lt;li style=&quot;margin-left: 46pt;&quot; class=&quot;c0 c18 li-bullet-0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;Firefox 91&lt;/span&gt;&lt;/li&gt;&lt;li style=&quot;margin-left: 46pt;&quot; class=&quot;c0 c18 li-bullet-0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;.NET Framework 4.8&lt;/span&gt;&lt;/li&gt;&lt;li style=&quot;margin-left: 46pt;&quot; class=&quot;c0 c18 li-bullet-0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;.NET 5.0 and 6.0&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;This is of course not an exhaustive list, and there&amp;#39;s likely to be many different HTTP clients in Windows which might have different behaviors. I&amp;#39;ve also not looked at how non-Windows clients work in this regard. &lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;There&amp;#39;s two important behaviors that I wanted to assess with HTTP. First is how the user agent determines when to perform automatic Windows authentication using the current user&amp;#39;s credentials. In order to relay the authentication it can&amp;#39;t ask the user for their credentials. And second we want to know how the SPN is selected by the user agent when calling &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;InitializeSecurityContext&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;.&lt;/span&gt;&lt;/p&gt;&lt;h3 class=&quot;c32&quot; id=&quot;h.7drfeuxw9d9q&quot;&gt;&lt;span class=&quot;c31&quot;&gt;WinINET (Internet Explorer 11)&lt;/span&gt;&lt;/h3&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://docs.microsoft.com/en-us/windows/win32/wininet/portal&quot;&gt;WinINET&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;can be used as a generic library to handle HTTP connections and authentication. There&amp;#39;s likely many different users of WinINET but we&amp;#39;ll just look at Internet Explorer 11 as that is what it&amp;#39;s most known for. WinINET is also the originator of HTTP &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Negotiate &lt;/span&gt;&lt;span&gt;authentication&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;, so it&amp;#39;s good to get a baseline of what WinINET does in case other libraries just copied its behavior.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;First, how does WinINET determine when it should handle Windows authentication automatically? By default this is based on whether the target host is considered to be in the Intranet Zone. This means any host which bypasses the configured HTTP proxy or uses an undotted name will be considered Intranet zone and WinINET will automatically authenticate using the current user&amp;#39;s credentials.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;It&amp;#39;s possible to disable this behavior by changing the security options for the Intranet Zone to &amp;quot;Prompt for &lt;/span&gt;&lt;span&gt;user name&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;and password&amp;quot;, as shown below:&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c4&quot;&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/a/AVvXsEi0PEBYNeQYyCFc_m0LHSgoGRsniCGYJYWXZuD4Ix1SXwSklWAhLmMg5NknUrJ7q4jAjDVhx0raXfmQXk9a3TPvJqUKT0pdcyNnv2h9KzFrhdJzQGmoHRFCCUhRfp0RexYbR9hkmu3SnPy5sBKjgUMsv5gZFka1gAv7evU_d5E7iQOPegQCv4c8360SmQ=s699&quot; style=&quot;display: block; padding: 1em 0;text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/a/AVvXsEi0PEBYNeQYyCFc_m0LHSgoGRsniCGYJYWXZuD4Ix1SXwSklWAhLmMg5NknUrJ7q4jAjDVhx0raXfmQXk9a3TPvJqUKT0pdcyNnv2h9KzFrhdJzQGmoHRFCCUhRfp0RexYbR9hkmu3SnPy5sBKjgUMsv5gZFka1gAv7evU_d5E7iQOPegQCv4c8360SmQ=s699&quot; border=&quot;0&quot; alt=&quot;Screenshot of the system Internet Options Security Settings showing how to disable automatic authentication&quot; style=&quot;max-height: 750px; max-width: 600px;&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;Next, how does WinINET determine the SPN to use for &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Negotiate &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;authentication? RFC4559 says the following:&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c25 c14 c4&quot;&gt;&amp;#39;When the Kerberos Version 5 GSSAPI mechanism [RFC4121] is being used, the HTTP server will be using a principal name of the form of &amp;quot;HTTP/hostname&amp;quot;&amp;#39;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;You might assume therefore that the HTTP URL that WinINET is connecting to would be sufficient to build the SPN: just use the hostname as provided and combine with the HTTP service class. However it turns out that&amp;#39;s not entirely the case. I found a rough description of how IE and WinINET actually generate the SPN in &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://techcommunity.microsoft.com/t5/ask-the-directory-services-team/internet-explorer-behaviors-with-kerberos-authentication/ba-p/396428&quot;&gt;this blog&lt;/a&gt;&lt;/span&gt;&lt;span&gt;. &lt;/span&gt;&lt;span&gt;This blog post is over 10 years old so it was possible that things have changed, however it turns out to not be the case&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;The basic approach is that WinINET doesn&amp;#39;t necessarily trust the hostname specified in the HTTP URL. Instead it requests the canonical name of the server via DNS. It doesn&amp;#39;t seem to explicitly request a CNAME record from the DNS server. Instead it calls &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/ws2tcpip/nf-ws2tcpip-getaddrinfo&quot;&gt;getaddrinfo&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span&gt;and specifies the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;AI_CANONNAME&lt;/span&gt;&lt;span&gt;&amp;nbsp;hint. Then it uses the returned value of &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;ai_canonname&lt;/span&gt;&lt;span&gt;&amp;nbsp;and prefixes it with the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;HTTP&lt;/span&gt;&lt;span&gt;&amp;nbsp;service class&lt;/span&gt;&lt;span&gt;. In general &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;ai_canonname&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;is the name provided by the DNS server in the returned A/AAAA record.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;For example, if the HTTP URL is &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;http://fileserver.domain.com&lt;/span&gt;&lt;span&gt;, but the DNS A record contains the canonical name &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;example.domain.com&lt;/span&gt;&lt;span&gt;&amp;nbsp;the generated SPN is &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;HTTP/example.domain.com&lt;/span&gt;&lt;span&gt;&amp;nbsp;and not &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;HTTP/fileserver.domain.com&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;. Therefore to provide an arbitrary SPN you need to get the name in the DNS address record to differ from the IP address in that record so that IE will connect to a server we control while generating Kerberos authentication for a different target name.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;The most obvious technique would be to specify a DNS CNAME record which redirects to another hostname. However, at least if the client is using a Microsoft DNS server (which is likely for a domain environment) then the CNAME record is not directly returned to the client. Instead the DNS server will perform a recursive lookup, and then return the CNAME along with the validated address record to the client. &lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;Therefore, if an attacker sets up a CNAME record for &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;www.evil.com&lt;/span&gt;&lt;span&gt;, which redirects to &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;fileserver.domain.com&lt;/span&gt;&lt;span&gt;&amp;nbsp;the DNS server will return the CNAME record and an address record for the real IP address of &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;fileserver.domain.com&lt;/span&gt;&lt;span&gt;. WinINET will try to connect to the HTTP service on &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;fileserver.domain.com&lt;/span&gt;&lt;span&gt;&amp;nbsp;rather than &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;www.evil.com&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;which is what is needed for the attack to function.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;I tried various ways of tricking the DNS client into making a direct request to a DNS server I controlled but I couldn&amp;#39;t seem to get it to work. However, it turns out there is a way to get the DNS resolver to accept arbitrary DNS responses, via local DNS resolution protocols such as &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://datatracker.ietf.org/doc/html/rfc6762&quot;&gt;Multicast DNS (MDNS)&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;and &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://datatracker.ietf.org/doc/html/rfc4795&quot;&gt;Link-Local Multicast Name Resolution (LLMNR)&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;. &lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;These two protocols use a lightly modified DNS packet structure, so you can return a response to the name resolution request with an address record with the IP address of the malicious web server, but the canonical name of any server. WinINET will then make the HTTP connection to the malicious web server but construct the SPN for the spoofed canonical name. I&amp;#39;ve verified this with LLMNR and in theory MDNS should work as well.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;Is spoofing the canonical name a bug in the Windows DNS client resolver? I don&amp;#39;t believe any DNS protocol requires the query name to exactly match the answer name. If the DNS server has a CNAME record for the queried host then there&amp;#39;s no obvious requirement for it to return that record when it could just return the address record. Of course if a public DNS server could spoof a host for a DNS zone which it didn&amp;#39;t control, that&amp;#39;d be a &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://www.cs.cornell.edu/~shmat/shmat_securecomm10.pdf&quot;&gt;serious security issue&lt;/a&gt;&lt;/span&gt;&lt;span&gt;. It&amp;#39;s also worth noting that this doesn&amp;#39;t spoof the name generally. As the cached DNS entry on Windows is based on the query name, if the client now resolves &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;fileserver.domain.com&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;a new DNS request will be made and the DNS server would return the real address.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;Attacking local name resolution protocols is a well known weakness abused for MitM attacks, so it&amp;#39;s likely that some security conscious networks will disable the protocols. However, the advantage of using LLMNR this way over its use for MitM is that the resolved name can be anything. As in, normally you&amp;#39;d want to spoof the DNS name of an existing host, in our example you&amp;#39;d spoof the request for the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;fileserver&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;name. But for registered computers on the network the DNS client will usually satisfy the name resolution via the network&amp;#39;s DNS server before ever trying local DNS resolution. Therefore local DNS resolution would never be triggered and it wouldn&amp;#39;t be possible to spoof it. For relaying Kerberos authentication we don&amp;#39;t care, you can induce a client to connect to an unregistered host name which will fallback to local DNS resolution.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;The big problem with the local DNS resolution attack vector is that the attacker must be in the same multicast domain as the victim computer. However, the attacker can still start the process by getting a user to connect to an external domain which looks legitimate then redirect to an undotted name to both force automatic authentication and local DNS resolving.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c4&quot;&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/a/AVvXsEjm2PtQTZlQobqpEmVuy_72dJbu90cytEZH8jKN3ZwLkCzOMKQa0Rwfk0FVqKaPu5fyDimYp_gWkAxJHjdZU45OIVRD3EiPE_sd1jEmTCTLtPgMz96bHOM6SQrTPx7OJt3A3O65vdC1lRtF3y8pKchdwcst1J7oJCMIFb_PMGOcvy9CFEKz6Y3vbMTZ9g=s877&quot; style=&quot;display: block; padding: 1em 0;text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/a/AVvXsEjm2PtQTZlQobqpEmVuy_72dJbu90cytEZH8jKN3ZwLkCzOMKQa0Rwfk0FVqKaPu5fyDimYp_gWkAxJHjdZU45OIVRD3EiPE_sd1jEmTCTLtPgMz96bHOM6SQrTPx7OJt3A3O65vdC1lRtF3y8pKchdwcst1J7oJCMIFb_PMGOcvy9CFEKz6Y3vbMTZ9g=s877&quot; border=&quot;0&quot; alt=&quot;Diagram of the local DNS resolving attack against WinINET&quot; style=&quot;max-height: 750px; max-width: 600px;&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;To summarize the attack process as shown in the above diagram:&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;c24 lst-kix_i2wckd3yhfhe-0 start&quot; start=&quot;1&quot;&gt;&lt;li style=&quot;margin-left: 46pt;&quot; class=&quot;c0 c18 li-bullet-0&quot;&gt;&lt;span&gt;The attacker sets up an LLMNR service on a machine in the same multicast domain at the victim computer. The attacker listens for a target name request such as &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;EVILHOST&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;.&lt;/span&gt;&lt;/li&gt;&lt;li style=&quot;margin-left: 46pt;&quot; class=&quot;c0 c18 li-bullet-0&quot;&gt;&lt;span&gt;Trick the victim to use IE (or another WinINET client, such as via a document format like DOCX) to connect to the attacker&amp;#39;s server on &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;http://EVILHOST&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;.&lt;/span&gt;&lt;/li&gt;&lt;li style=&quot;margin-left: 46pt;&quot; class=&quot;c0 c18 li-bullet-0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;The LLMNR server receives the lookup request and responds by setting the address record&amp;#39;s hostname to the SPN target host to spoof and the IP address to the attacker-controlled server.&lt;/span&gt;&lt;/li&gt;&lt;li style=&quot;margin-left: 46pt;&quot; class=&quot;c0 c18 li-bullet-0&quot;&gt;&lt;span&gt;The WinINET client extracts the spoofed canonical name, appends the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;HTTP &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;service class to the SPN and requests the Kerberos service ticket. This Kerberos ticket is then sent to the attacker&amp;#39;s HTTP service.&lt;/span&gt;&lt;/li&gt;&lt;li style=&quot;margin-left: 46pt;&quot; class=&quot;c0 c18 li-bullet-0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;The attacker receives the Negotiate/Kerberos authentication for the spoofed SPN and relays it to the real target server.&lt;/span&gt;&lt;/li&gt;&lt;/ol&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;An example LLMNR response decoded by Wireshark for the name &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;evilhost&lt;/span&gt;&lt;span&gt;&amp;nbsp;(with IP address 10.0.0.80), spoofing &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;fileserver.domain.com&lt;/span&gt;&lt;span&gt;&amp;nbsp;(which is &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;not &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;address 10.0.0.80) is shown below:&lt;/span&gt;&lt;/p&gt;&lt;a id=&quot;t.b649351b399dcc493def89e3b9168ea435d7a3e3&quot;&gt;&lt;/a&gt;&lt;a id=&quot;t.1&quot;&gt;&lt;/a&gt;&lt;table class=&quot;c21&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;c20&quot;&gt;&lt;td class=&quot;c11&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c12 c14 c4&quot;&gt;Link-local Multicast Name Resolution (response)&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c12 c14 c4&quot;&gt;&amp;nbsp; &amp;nbsp; Transaction ID: 0x910f&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c12 c14 c4&quot;&gt;&amp;nbsp; &amp;nbsp; Flags: 0x8000 Standard query response, No error&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c12 c14 c4&quot;&gt;&amp;nbsp; &amp;nbsp; Questions: 1&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c12 c14 c4&quot;&gt;&amp;nbsp; &amp;nbsp; Answer RRs: 1&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c12 c14 c4&quot;&gt;&amp;nbsp; &amp;nbsp; Authority RRs: 0&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c12 c14 c4&quot;&gt;&amp;nbsp; &amp;nbsp; Additional RRs: 0&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c12 c14 c4&quot;&gt;&amp;nbsp; &amp;nbsp; Queries&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c12 c14 c4&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; evilhost: type A, class IN&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c12 c14 c4&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Name: evilhost&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c12 c14 c4&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; [Name Length: 8]&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c12 c4 c14&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; [Label Count: 1]&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c12 c14 c4&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Type: A (Host Address) (1)&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c12 c14 c4&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Class: IN (0x0001)&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c12 c14 c4&quot;&gt;&amp;nbsp; &amp;nbsp; Answers&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c12 c14 c4&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; fileserver.domain.com: type A, class IN, addr 10.0.0.80&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c12 c14 c4&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Name: fileserver.domain.com&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c12 c14 c4&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Type: A (Host Address) (1)&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c12 c14 c4&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Class: IN (0x0001)&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c12 c14 c4&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Time to live: 1 (1 second)&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c12 c14 c4&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Data length: 4&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c4 c42&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Address: 10.0.0.80&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;You might assume that the SPN always having the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;HTTP &lt;/span&gt;&lt;span&gt;service class would be a problem. However, the Active Directory default SPN mapping will map &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;HTTP &lt;/span&gt;&lt;span&gt;to the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;HOST &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;service class which is always registered. Therefore you can target any domain joined system without needing to register an explicit SPN. As long as the receiving service doesn&amp;#39;t then verify the SPN it will work to authenticate to the computer account, which is used by privileged services. You can use the following PowerShell script to list all the configured SPN mappings in a domain.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;a id=&quot;t.28ed80520ca46d9c5e76e6e7185f42f9102dbf8d&quot;&gt;&lt;/a&gt;&lt;a id=&quot;t.2&quot;&gt;&lt;/a&gt;&lt;table class=&quot;c21&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;c20&quot;&gt;&lt;td class=&quot;c11&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c2&quot;&gt;PS&amp;gt; &lt;/span&gt;&lt;span class=&quot;c2 c23&quot;&gt;$base_dn&lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c2 c17&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;(&lt;/span&gt;&lt;span class=&quot;c2 c13&quot;&gt;Get-ADRootDSE&lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;c2 c17&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;c6 c2&quot;&gt;configurationNamingContext&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c2&quot;&gt;PS&amp;gt; &lt;/span&gt;&lt;span class=&quot;c2 c23&quot;&gt;$dn&lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c2 c17&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c2 c27&quot;&gt;&amp;quot;CN=Directory Service,CN=Windows NT,CN=Services,&lt;/span&gt;&lt;span class=&quot;c2 c23&quot;&gt;$base_dn&lt;/span&gt;&lt;span class=&quot;c2 c27&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c2&quot;&gt;PS&amp;gt; (&lt;/span&gt;&lt;span class=&quot;c2 c13&quot;&gt;Get-ADObject&lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c2 c23&quot;&gt;$dn&lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c2 c34&quot;&gt;-Properties&lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c2 c35&quot;&gt;sPNMappings&lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;c2 c17&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;c6 c2&quot;&gt;sPNMappings&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;One interesting behavior of WinINET is that it always requests &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Kerberos&lt;/span&gt;&lt;span&gt;&amp;nbsp;delegation, although that will only be useful if the SPN&amp;#39;s target account is registered for delegation. I couldn&amp;#39;t convince WinINET to default to a Kerberos only mode; sending back a &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;WWW-Authenticate: Kerberos&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;header causes the authentication process to stop. This means the Kerberos AP_REQ will always have Integrity enabled even though the user agent doesn&amp;#39;t explicitly request it.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;Another user of WinINET is Office. For example you can set a template located on an HTTP URL which will generate local Windows authentication if in the Intranet zone just by opening a Word document. This is probably a good vector for getting the authentication started rather than relying on Internet Explorer being available.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;WinINET does have some &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/platform-apis/ms537164(v=vs.85)&quot;&gt;feature controls&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;which can be enabled on a per-executable basis which affect the behavior of the SPN lookup process, specifically &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;FEATURE_USE_CNAME_FOR_SPN_KB911149&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;and &lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c4&quot;&gt;FEATURE_ALWAYS_USE_DNS_FOR_SPN_KB3022771&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;. However these only seem to come into play if the HTTP connection is being proxied, which we&amp;#39;re assuming isn&amp;#39;t the case.&lt;/span&gt;&lt;/p&gt;&lt;h3 class=&quot;c32&quot; id=&quot;h.8vgvwmfq3mv1&quot;&gt;&lt;span class=&quot;c31&quot;&gt;WinHTTP (WebDAV WebClient)&lt;/span&gt;&lt;/h3&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;The &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://docs.microsoft.com/en-us/windows/win32/winhttp/about-winhttp&quot;&gt;WinHTTP library&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;is an alternative to using WinINET in a client application. It&amp;#39;s a cleaner API and doesn&amp;#39;t have the baggage of being used in Internet Explorer. As an example client I chose to use the built-in WebDAV WebClient service because it gives the interesting property that it converts a UNC file name request into a potentially exploitable HTTP request. If the WebClient service is installed and running then opening a file of the form &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;\\EVIL\abc&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;will cause an HTTP request to be sent out to a server under the attacker&amp;#39;s control.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;From what I can tell the behavior of WinHTTP when used with the WebClient service is almost exactly the same as for WinINET. I could exploit the SPN generation through local DNS resolution, but not from a public DNS name record. WebDAV seems to consider undotted names to be Intranet zone, however the default for WinHTTP seems to depend on whether the connection would bypass the proxy. The automatic authentication decision is based on the value of the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;WINHTTP_OPTION_AUTOLOGON_POLICY&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;policy.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;At least as used with WebDAV WinHTTP handles a &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;WWW-Authenticate&lt;/span&gt;&lt;span&gt;&amp;nbsp;header of &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Kerberos&lt;/span&gt;&lt;span&gt;, however it ends up using the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Negotiate&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;package regardless and so Integrity will always be enabled. It also enables Kerberos delegation automatically like WinINET.&lt;/span&gt;&lt;/p&gt;&lt;h3 class=&quot;c32&quot; id=&quot;h.pjg6jrw6yjqn&quot;&gt;&lt;span class=&quot;c31&quot;&gt;Chromium M93&lt;/span&gt;&lt;/h3&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;Chromium based browsers such as Chrome and Edge are open source so it&amp;#39;s a bit easier to check the implementation. By default Chromium will automatically authenticate to intranet zone sites, it uses the same Internet Security Manager used by WinINET to make the zone determination in &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://source.chromium.org/chromium/chromium/src/+/main:net/http/url_security_manager_win.cc;drc=739ccc21289257112c667e04a40d9a5a2db466bf;l=50&quot;&gt;URLSecurityManagerWin::CanUseDefaultCredentials&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;. An administrator can set GPOs to change this behavior to only allow automatic authentication to a set of hosts.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;The SPN is generated in &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://source.chromium.org/chromium/chromium/src/+/main:net/http/http_auth_handler_negotiate.cc;drc=78c0778431c6fdd3dead532b1774270486829251;l=248&quot;&gt;HttpAuthHandlerNegotiate::CreateSPN&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;which is called from &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://source.chromium.org/chromium/chromium/src/+/main:net/http/http_auth_handler_negotiate.cc;drc=a412d0ef42cd54ca75e76023a8ccf13d6f58bf06;l=356&quot;&gt;HttpAuthHandlerNegotiate::DoResolveCanonicalNameComplete&lt;/a&gt;&lt;/span&gt;&lt;span&gt;. While the documentation for &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;CreateSPN &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;mentions it&amp;#39;s basically a copy of the behavior in IE, it technically isn&amp;#39;t. Instead of taking the canonical name from the initial DNS request it does a second DNS request, and the result of that is used to generate the SPN. &lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;This second DNS request is important as it means that we now have a way of exploiting this from a public DNS name. If you set the TTL of the initial host DNS record to a very low value, then it&amp;#39;s possible to change the DNS response between the lookup for the host to connect to and the lookup for the canonical name to use for the SPN. &lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;This will also work with local DNS resolution as well, though in that case the response doesn&amp;#39;t need to be switched as one response is sufficient. This second DNS lookup behavior can be disabled with a &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://admx.help/?Category=Chrome&amp;Policy=Google.Policies.Chrome::DisableAuthNegotiateCnameLookup&quot;&gt;GPO&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;. If this is disabled then neither local DNS resolution nor public DNS will work as Chromium will use the host specified in the URL for the SPN.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;In a domain environment where the Chromium browser is configured to only authenticate to Intranet sites we can abuse the fact that by default authenticated users can add new DNS records to the Microsoft DNS server through LDAP (see &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://www.netspi.com/blog/technical/network-penetration-testing/exploiting-adidns/&quot;&gt;this blog post&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;by &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://twitter.com/kevin_robertson&quot;&gt;Kevin Robertson&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;). Using the domain&amp;#39;s DNS server is useful as the DNS record could be looked up using a short Intranet name rather than a public DNS name meaning it&amp;#39;s likely to be considered a target for automatic authentication.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;One problem with using LDAP to add the DNS record is the time before the DNS server will refresh its records is at least 180 seconds. This would make it difficult to switch the response from a normal address record to a CNAME record in a short enough time frame to be useful. Instead we can add an NS record to the DNS server which forwards the lookup to our own DNS server. As long as the TTL for the DNS response is short the domain&amp;#39;s DNS server will rerequest the record and we can return different responses without any waiting for the DNS server to update from LDAP. This is very similar to &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://en.wikipedia.org/wiki/DNS_rebinding&quot;&gt;DNS rebinding attack&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;, except instead of swapping the IP address, we&amp;#39;re swapping the canonical name.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c25 c14 c4&quot;&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/a/AVvXsEh1TOvmY3p9cuk3lJdRZ8WKstDkX6N1_3iBLKo-IKFncIiRuokfjzJE4sXdb3O89inLCz5s6H7lO4_Pq8HVdMwzyJvYIao-IhSKRJm-vHBSlDzBFfe7vJhL05iKhn_1Jy9mft4nSrNY7eggb2KsfjO2JXEtSlqfV44Pd8cDODKHEK087TBDryW82cGTHA=s898&quot; style=&quot;display: block; padding: 1em 0;text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/a/AVvXsEh1TOvmY3p9cuk3lJdRZ8WKstDkX6N1_3iBLKo-IKFncIiRuokfjzJE4sXdb3O89inLCz5s6H7lO4_Pq8HVdMwzyJvYIao-IhSKRJm-vHBSlDzBFfe7vJhL05iKhn_1Jy9mft4nSrNY7eggb2KsfjO2JXEtSlqfV44Pd8cDODKHEK087TBDryW82cGTHA=s898&quot; border=&quot;0&quot; alt=&quot;Diagram of two DNS request attack against Chromium&quot; style=&quot;max-height: 750px; max-width: 600px;&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c25 c14 c4&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;Therefore a working exploit as shown in the diagram would be the following:&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;c24 lst-kix_wkcrlfh2qk3l-0 start&quot; start=&quot;1&quot;&gt;&lt;li style=&quot;margin-left: 46pt;&quot; class=&quot;c0 c18 li-bullet-0&quot;&gt;&lt;span&gt;Register an NS record with the DNS server for &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;evilhost.domain.com&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;using existing authenticated credentials via LDAP. Wait for the DNS server to pick up the record.&lt;/span&gt;&lt;/li&gt;&lt;li style=&quot;margin-left: 46pt;&quot; class=&quot;c0 c18 li-bullet-0&quot;&gt;&lt;span&gt;Direct the browser to connect to &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;http://evilhost&lt;/span&gt;&lt;span&gt;. T&lt;/span&gt;&lt;span&gt;his allows Chromium to automatically authenticate as it&amp;#39;s an undotted Intranet host. The browser will lookup &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;evilhost.domain.com&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;by adding its primary DNS suffix. &lt;/span&gt;&lt;/li&gt;&lt;li style=&quot;margin-left: 46pt;&quot; class=&quot;c0 c18 li-bullet-0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;This request goes to the client&amp;#39;s DNS server, which then follows the NS record and performs a recursive query to the attacker&amp;#39;s DNS server. &lt;/span&gt;&lt;/li&gt;&lt;li style=&quot;margin-left: 46pt;&quot; class=&quot;c0 c18 li-bullet-0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;The attacker&amp;#39;s DNS server returns a normal address record for their HTTP server with a very short TTL.&lt;/span&gt;&lt;/li&gt;&lt;li style=&quot;margin-left: 46pt;&quot; class=&quot;c0 c18 li-bullet-0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;The browser makes a request to the HTTP server, at this point the attacker delays the response long enough for the cached DNS request to expire. It can then return a 401 to get the browser to authenticate.&lt;/span&gt;&lt;/li&gt;&lt;li style=&quot;margin-left: 46pt;&quot; class=&quot;c0 c18 li-bullet-0&quot;&gt;&lt;span&gt;The browser makes a second DNS lookup for the canonical name. As the original request has expired, another will be made for &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;evilhost.domain.com&lt;/span&gt;&lt;span&gt;. For this lookup the attacker returns a CNAME record for the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;fileserver.domain.com&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;target. The client&amp;#39;s DNS server will look up the IP address for the CNAME host and return that.&lt;/span&gt;&lt;/li&gt;&lt;li style=&quot;margin-left: 46pt;&quot; class=&quot;c0 c18 li-bullet-0&quot;&gt;&lt;span&gt;The browser will generate the SPN based on the CNAME record and that&amp;#39;ll be used to generate the AP_REQ, sending it to the attacker&amp;#39;s HTTP server.&lt;/span&gt;&lt;/li&gt;&lt;li style=&quot;margin-left: 46pt;&quot; class=&quot;c0 c18 li-bullet-0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;The attacker can relay the AP_REQ to the target server.&lt;/span&gt;&lt;/li&gt;&lt;/ol&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;It&amp;#39;s possible that we can combine the local and public DNS attack mechanisms to only need one DNS request. In this case we could set up an NS record to our own DNS server and get the client to resolve the hostname. The client&amp;#39;s DNS server would do a recursive query, and at this point our DNS server shouldn&amp;#39;t respond immediately. We could then start a classic DNS spoofing attack to return a DNS response packet directly to the client with the spoofed address record.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;In general DNS spoofing is limited by requiring the source IP address, transaction ID and the UDP source port to match before the DNS client will accept the response packet. The source IP address should be spoofable on a local network and the client&amp;#39;s IP address can be known ahead of time through an initial HTTP connection, so the only problems are the transaction ID and port.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;As most clients have a relatively long timeout of 3-5 seconds, that might be enough time to try the majority of the combinations for the ID and port. Of course there isn&amp;#39;t really a penalty for trying multiple times. If this attack was practical then you could do the attack on a local network even if local DNS resolution was disabled and enable the attack for libraries which only do a single lookup such as WinINET and WinHTTP. The response could have a long TTL, so that when the access is successful it doesn&amp;#39;t need to be repeated for every request.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;I couldn&amp;#39;t get Chromium to downgrade &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Negotiate &lt;/span&gt;&lt;span&gt;to &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Kerberos&lt;/span&gt;&lt;span&gt;&amp;nbsp;only so Integrity will be enabled. Also since Delegation is not enabled by default, an administrator needs to configure an &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://admx.help/?Category=Chrome&amp;Policy=Google.Policies.Chrome::AuthNegotiateDelegateWhitelist&quot;&gt;allow list GPO&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;to specify what targets are allowed to receive delegated credentials.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;A bonus quirk for Chromium: It seems to be the only browser which still supports URL based user credentials. If you pass user credentials in the request and get the server to return a request for &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Negotiate &lt;/span&gt;&lt;span&gt;authentication then it&amp;#39;ll authenticate automatically regardless of the zone of the site. You can also pass credentials using &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;XMLHttpRequest::open&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;While not very practical, this can be used to test a user&amp;#39;s password from an arbitrary host. If the username/password is correct and the SPN is spoofed then Chromium will send a validated Kerberos AP_REQ, otherwise either NTLM or no authentication will be sent. &lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;NTLM can be always generated as it doesn&amp;#39;t require any proof the password is valid, whereas Kerberos requires the password to be correct to allow the authentication to succeed. You need to specify the domain name when authenticating so you use a URL of the form &lt;/span&gt;&lt;span class=&quot;c25 c14 c4&quot;&gt;http://DOMAIN%5CUSER:PASSWORD@host.com.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;One other quirk of this is you can specify a fully qualified domain name (FQDN) and user name and the Windows Kerberos implementation will try and authenticate using that server based on the DNS SRV records. For example &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;http://EVIL.COM%5CUSER:PASSWORD@host.com&lt;/span&gt;&lt;span&gt;&amp;nbsp;will try to authenticate to the Kerberos service specified through the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;_kerberos._tcp.evil.com&lt;/span&gt;&lt;span&gt;&amp;nbsp;SRV record&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;. This trick works even on non-domain joined systems to generate Kerberos authentication, however it&amp;#39;s not clear if this trick has any practical use.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;It&amp;#39;s worth noting that I did discuss the implications of the Chromium HTTP vector with team members internally and the general conclusion that this behavior is by design as it&amp;#39;s trying to copy the behavior expected of existing user agents such as IE.&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;Therefore there was no expectation it would be fixed.&lt;/span&gt;&lt;/p&gt;&lt;h3 class=&quot;c32&quot; id=&quot;h.xfgb3dttm6vh&quot;&gt;&lt;span class=&quot;c31&quot;&gt;Firefox 91&lt;/span&gt;&lt;/h3&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;As with Chromium, Firefox is open source so we can find the &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://searchfox.org/mozilla-central/source/extensions/auth/nsHttpNegotiateAuth.cpp#170&quot;&gt;implementation&lt;/a&gt;&lt;/span&gt;&lt;span&gt;. Unlike the other HTTP implementations researched up to this point, Firefox doesn&amp;#39;t perform Windows authentication by default. An administrator needs to configure either a list of hosts that are allowed to automatically authenticate, or the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;network.negotiate-auth.allow-non-fqdn&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;setting can be enabled to authenticate to non-dotted host names.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;If authentication is enabled it works with both local DNS resolving and public DNS as it does a second DNS lookup when constructing the SPN for &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Negotiate &lt;/span&gt;&lt;span&gt;in &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://searchfox.org/mozilla-central/source/extensions/auth/nsAuthSSPI.cpp#93&quot;&gt;nsAuthSSPI::MakeSN&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;. Unlike Chromium there doesn&amp;#39;t seem to be a setting to disable this behavior.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;Once again I couldn&amp;#39;t get Firefox to use raw Kerberos, so Integrity is enabled. Also Delegation is not enabled unless an administrator configures the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;network.negotiate-auth.delegation-uris&lt;/span&gt;&lt;span&gt;&amp;nbsp;setting.&lt;/span&gt;&lt;/p&gt;&lt;h3 class=&quot;c32&quot; id=&quot;h.hj80sqr0xa9u&quot;&gt;&lt;span class=&quot;c31&quot;&gt;.NET Framework 4.8&lt;/span&gt;&lt;/h3&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;The .NET Framework 4.8 officially has two HTTP libraries, the original &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.net.webrequest&quot;&gt;System.Net.HttpWebRequest&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;and derived APIs and the newer &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient&quot;&gt;System.Net.Http.HttpClient&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;API. However in the .NET framework the newer API uses the older one under the hood, so we&amp;#39;ll only consider the older of the two.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;Windows authentication is only generated automatically if the &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.net.httpwebrequest.usedefaultcredentials&quot;&gt;UseDefaultCredentials&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;property is set to true on the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;HttpWebRequest&lt;/span&gt;&lt;span&gt;&amp;nbsp;object as shown below &lt;/span&gt;&lt;span&gt;(technically this sets the &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.net.credentialcache.defaultcredentials&quot;&gt;CredentialCache.DefaultCredentials&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;object, but it&amp;#39;s easier to use the boolean property). Once the default credentials are set the client will automatically authenticate using Windows authentication to any host, it doesn&amp;#39;t seem to care if that host is in the Intranet zone.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;a id=&quot;t.7e4822d1f02afd7da5d70f6bb7cc98084373024a&quot;&gt;&lt;/a&gt;&lt;a id=&quot;t.3&quot;&gt;&lt;/a&gt;&lt;table class=&quot;c21&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;c20&quot;&gt;&lt;td class=&quot;c11&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c7&quot;&gt;&lt;span class=&quot;c2 c13&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;request = WebRequest.CreateHttp(&lt;/span&gt;&lt;span class=&quot;c2 c36&quot;&gt;&amp;quot;http://www.evil.com&amp;quot;&lt;/span&gt;&lt;span class=&quot;c6 c2&quot;&gt;);&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c7&quot;&gt;&lt;span class=&quot;c2&quot;&gt;request.UseDefaultCredentials = &lt;/span&gt;&lt;span class=&quot;c2 c13&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;c6 c2&quot;&gt;;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c7&quot;&gt;&lt;span class=&quot;c2 c13&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;response = (HttpWebResponse)request.GetResponse();&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;The SPN is generated in the &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://referencesource.microsoft.com/#System/net/System/Net/_AuthenticationState.cs,114&quot;&gt;System.Net.AuthenticationState.GetComputeSpn&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;function which we can find in the .NET reference source. The SPN is built from the canonical name returned by the initial DNS lookup, which means it supports the local but not public DNS resolution. If you follow the code it does support doing a second DNS lookup if the host is undotted, however this is only if the client code sets an explicit &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Host &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;header as far as I can tell. Note that the code here is slightly different in .NET 2.0 which might support looking up the canonical name as long as the host name is undotted, but I&amp;#39;ve not verified that.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;The .NET Framework supports specifying &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Kerberos&lt;/span&gt;&lt;span&gt;&amp;nbsp;directly as the authentication type in the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;WWW-Authentication&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;header. As the client code doesn&amp;#39;t explicitly request integrity, this allows the Kerberos AP_REQ to not have Integrity enabled. &lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;The code also supports the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;WWW-Authentication&lt;/span&gt;&lt;span&gt;&amp;nbsp;header having an initial token, so even if Kerberos wasn&amp;#39;t directly supported, you could use &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Negotiate&lt;/span&gt;&lt;span&gt;&amp;nbsp;and specify the stub token I described at the start to force Kerberos authentication. For example returning the following header with the initial 401 status response will force &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Kerberos &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;through auto-detection:&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;a id=&quot;t.47f2d775b3f960ad13600d96e3bddd754ab896ed&quot;&gt;&lt;/a&gt;&lt;a id=&quot;t.4&quot;&gt;&lt;/a&gt;&lt;table class=&quot;c21&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;c20&quot;&gt;&lt;td class=&quot;c11&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2&quot;&gt;WWW-Authenticate: Negotiate AAFA&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;Finally, the authentication code always enables delegation regardless of the target host.&lt;/span&gt;&lt;/p&gt;&lt;h3 class=&quot;c32&quot; id=&quot;h.55txgo3a2wq5&quot;&gt;&lt;span class=&quot;c31&quot;&gt;.NET 5.0&lt;/span&gt;&lt;/h3&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;The .NET 5.0 runtime has deprecated the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;HttpWebRequest&lt;/span&gt;&lt;span&gt;&amp;nbsp;API in favor of the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;HttpClient&lt;/span&gt;&lt;span&gt;&amp;nbsp;API. It uses a new backend class called the &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.net.http.socketshttphandler&quot;&gt;SocketsHttpHandler&lt;/a&gt;&lt;/span&gt;&lt;span&gt;. As it&amp;#39;s all open source we can find the &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://github.com/dotnet/runtime/blob/791a0d896052f61161aff4c1ccb5f3425328f9a8/src/libraries/System.Net.Http/src/System/Net/Http/SocketsHttpHandler/AuthenticationHelper.NtAuth.cs&quot;&gt;implementation&lt;/a&gt;&lt;/span&gt;&lt;span&gt;, specifically the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;AuthenticationHelper &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;class which is a complete rewrite from the .NET Framework version.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;To automatically authenticate, the client code must either use the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;HttpClientHandler &lt;/span&gt;&lt;span&gt;class and set the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;UseDefaultCredentials &lt;/span&gt;&lt;span&gt;property as shown below. Or if using &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;SocketsHttpHandler&lt;/span&gt;&lt;span&gt;, set the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Credentials &lt;/span&gt;&lt;span&gt;property to the default credentials. This handler must then be specified when creating the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;HttpClient &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;object.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;a id=&quot;t.558674b491818f584c342a8a8dd3989575c4c999&quot;&gt;&lt;/a&gt;&lt;a id=&quot;t.5&quot;&gt;&lt;/a&gt;&lt;table class=&quot;c21&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;c20&quot;&gt;&lt;td class=&quot;c11&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c7&quot;&gt;&lt;span class=&quot;c2 c13&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;handler = &lt;/span&gt;&lt;span class=&quot;c2 c13&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;c6 c2&quot;&gt;&amp;nbsp;HttpClientHandler();&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c7&quot;&gt;&lt;span class=&quot;c2&quot;&gt;handler.UseDefaultCredentials = &lt;/span&gt;&lt;span class=&quot;c2 c13&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;c6 c2&quot;&gt;;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c7&quot;&gt;&lt;span class=&quot;c2 c13&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;client = &lt;/span&gt;&lt;span class=&quot;c2 c13&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;c6 c2&quot;&gt;&amp;nbsp;HttpClient(handler);&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c7&quot;&gt;&lt;span class=&quot;c2 c13&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;client.GetStringAsync(&lt;/span&gt;&lt;span class=&quot;c2 c36&quot;&gt;&amp;quot;http://www.evil.com&amp;quot;&lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;);&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;Unless the client specified an explicit &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Host &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;header in the request the authentication will do a DNS lookup for the canonical name. This is separate from the DNS lookup for the HTTP connection so it supports both local and public DNS attacks.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;While the implementation doesn&amp;#39;t support Kerberos directly like the .NET Framework, it does support passing an initial token so it&amp;#39;s still possible to force raw Kerberos which will disable the Integrity requirement.&lt;/span&gt;&lt;/p&gt;&lt;h3 class=&quot;c32&quot; id=&quot;h.9k5bin8hhfky&quot;&gt;&lt;span class=&quot;c31&quot;&gt;.NET 6.0&lt;/span&gt;&lt;/h3&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;The .NET 6.0 runtime is basically the same as .NET 5.0, except that Integrity is specified explicitly when creating the client authentication context. This means that rolling back to Kerberos no longer has any advantage. &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://github.com/dotnet/runtime/commit/17481fef502ee6aed6f9e8fc76e45bb5863c68b5&quot;&gt;This change&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;seems to be down to a broken implementation of NTLM on macOS and not as some anti-NTLM relay measure.&lt;/span&gt;&lt;/p&gt;&lt;h3 class=&quot;c32&quot; id=&quot;h.liq0ng1hwkl2&quot;&gt;&lt;span class=&quot;c31&quot;&gt;HTTP Overview&lt;/span&gt;&lt;/h3&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;The following table summarizes the results of the HTTP protocol research:&lt;/span&gt;&lt;/p&gt;&lt;ul style=&quot;padding: 0;&quot; class=&quot;c24 lst-kix_2yktnm17nyl7-0 start&quot;&gt;&lt;li style=&quot;margin-left: 46pt;&quot; class=&quot;c0 c18 li-bullet-0&quot;&gt;&lt;span&gt;The &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;LLMNR &lt;/span&gt;&lt;span&gt;column &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;indicates it&amp;#39;s possible to influence the SPN using a local DNS resolver attack &lt;/span&gt;&lt;/li&gt;&lt;li style=&quot;margin-left: 46pt;&quot; class=&quot;c0 c18 li-bullet-0&quot;&gt;&lt;span class=&quot;c4&quot;&gt;DNS CNAME&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;indicates a public DNS resolving attack &lt;/span&gt;&lt;/li&gt;&lt;li style=&quot;margin-left: 46pt;&quot; class=&quot;c0 c18 li-bullet-0&quot;&gt;&lt;span class=&quot;c4&quot;&gt;Delegation &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;indicates the HTTP user agent enables Kerberos delegation &lt;/span&gt;&lt;/li&gt;&lt;li style=&quot;margin-left: 46pt;&quot; class=&quot;c0 c18 li-bullet-0&quot;&gt;&lt;span class=&quot;c4&quot;&gt;Integrity &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;indicates that integrity protection is requested which reduces the usefulness of the relayed authentication if the target server automatically detects the setting.&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;a id=&quot;t.6768360573c54e4f01434a9fa509149b13842614&quot;&gt;&lt;/a&gt;&lt;a id=&quot;t.6&quot;&gt;&lt;/a&gt;&lt;table class=&quot;c21&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;c20&quot;&gt;&lt;td class=&quot;c15 c33&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c25 c14 c4&quot;&gt;User Agent&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c29 c33&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c25 c14 c4&quot;&gt;LLMNR&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c30 c33&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c25 c14 c4&quot;&gt;DNS CNAME&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c10 c33&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c25 c14 c4&quot;&gt;Delegation&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c22 c33&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c4&quot;&gt;Integrity&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;c20&quot;&gt;&lt;td class=&quot;c15&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c3&quot;&gt;Internet Explorer 11 (WinINET)&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c29&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c3&quot;&gt;Yes&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c30&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c3&quot;&gt;No&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c10&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c3&quot;&gt;Yes&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c22&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c3&quot;&gt;Yes&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;c20&quot;&gt;&lt;td class=&quot;c15&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c3&quot;&gt;WebDAV (WinHTTP)&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c29&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c3&quot;&gt;Yes&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c30&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c3&quot;&gt;No&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c10&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c3&quot;&gt;Yes&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c22&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c3&quot;&gt;Yes&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;c20&quot;&gt;&lt;td class=&quot;c15&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c3&quot;&gt;Chromium (M93)&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c29&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c3&quot;&gt;Yes&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c30&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c3&quot;&gt;Yes&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c10&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span&gt;No&lt;/span&gt;&lt;span class=&quot;c25 c38&quot;&gt;&amp;dagger;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c22&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c3&quot;&gt;Yes&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;c20&quot;&gt;&lt;td class=&quot;c15&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c3&quot;&gt;Firefox 91&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c29&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c3&quot;&gt;Yes&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c30&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c3&quot;&gt;Yes&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c10&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span&gt;No&lt;/span&gt;&lt;span class=&quot;c41&quot;&gt;&amp;dagger;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c22&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c3&quot;&gt;Yes&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;c20&quot;&gt;&lt;td class=&quot;c15&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c3&quot;&gt;.NET Framework 4.8&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c29&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c3&quot;&gt;Yes&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c30&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span&gt;No&lt;/span&gt;&lt;span class=&quot;c38 c25&quot;&gt;&amp;Dagger;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c10&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c3&quot;&gt;Yes&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c22&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c3&quot;&gt;No&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;c20&quot;&gt;&lt;td class=&quot;c15&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c3&quot;&gt;.NET 5.0&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c29&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c3&quot;&gt;Yes&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c30&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c3&quot;&gt;Yes&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c10&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c3&quot;&gt;No&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c22&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c3&quot;&gt;No&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;c20&quot;&gt;&lt;td class=&quot;c15&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c3&quot;&gt;.NET 6.0&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c29&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c3&quot;&gt;Yes&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c30&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c3&quot;&gt;Yes&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c10&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c3&quot;&gt;No&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c22&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c3&quot;&gt;Yes&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&amp;dagger; Chromium and Firefox can enable delegation only on a per-site basis through a GPO.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&amp;Dagger; .NET Framework supports DNS resolving in special circumstances for non-dotted hostnames.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;By far the most permissive client is .NET 5.0. It supports authenticating to any host as long as it has been configured to authenticate automatically. It also supports arbitrary SPN spoofing from a public DNS name as well as disabling integrity through Kerberos fallback. However, as .NET 5.0 is designed to be something usable cross platform, it&amp;#39;s possible that few libraries written with it in mind will ever enable automatic authentication.&lt;/span&gt;&lt;/p&gt;&lt;h2 class=&quot;c26&quot; id=&quot;h.ip4rfjjchenz&quot;&gt;&lt;span class=&quot;c6 c19&quot;&gt;LDAP&lt;/span&gt;&lt;/h2&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;Windows has a built-in general purpose LDAP library in &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/_ldap/&quot;&gt;wldap32.dll&lt;/a&gt;&lt;/span&gt;&lt;span&gt;. This is used by the majority of OS components when accessing Active Directory and is also used by the .NET &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.directoryservices.protocols.ldapconnection&quot;&gt;LdapConnection&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;class. There doesn&amp;#39;t seem to be a way of specifying the SPN manually for the LDAP connection using the API. Instead it&amp;#39;s built manually based on the canonical name based on the DNS lookup. Therefore it&amp;#39;s exploitable in a similar manner to &lt;/span&gt;&lt;span&gt;WinINET&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;via local DNS resolution.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;The name of the LDAP server can also be found by querying for a SRV record for the hostname. This is used to support accessing the LDAP server from the top-level Windows domain name. This will usually return an address record alongside, all this does is change the server resolution process which doesn&amp;#39;t seem to give any advantages to exploitation.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;Whether the LDAP client enables integrity checking is based on the value of the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;LDAP_OPT_SIGN&lt;/span&gt;&lt;span&gt;&amp;nbsp;flag. As the connection only supports &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Negotiate &lt;/span&gt;&lt;span&gt;authentication the client passes the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;ISC_REQ_NO_INTEGRITY&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;flag if signing is disabled so that the server won&amp;#39;t accidentally auto-detect the signing capability enabled for the Negotiate MIC and accidentally enable signing protection.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;As part of &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://support.microsoft.com/en-us/topic/2020-ldap-channel-binding-and-ldap-signing-requirements-for-windows-ef185fb8-00f7-167d-744c-f299a66fc00a&quot;&gt;recent changes&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;to LDAP signing the client is forced to enable Integrity by the &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/network-security-ldap-client-signing-requirements&quot;&gt;LdapClientIntegrity policy&lt;/a&gt;&lt;/span&gt;&lt;span&gt;. This means that regardless of whether the LDAP server needs integrity protection it&amp;#39;ll be enabled on the client which in turn will automatically enable it on the server. Changing the value of &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;LDAP_OPT_SIGN&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;in the client has no effect once this policy is enabled.&lt;/span&gt;&lt;/p&gt;&lt;h2 class=&quot;c26&quot; id=&quot;h.m3ajz9uje54l&quot;&gt;&lt;span class=&quot;c6 c19&quot;&gt;SMB&lt;/span&gt;&lt;/h2&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;SMB is one of the most commonly exploited protocols for NTLM relay, as it&amp;#39;s easy to convert access to a file into authentication. It would be convenient if it was also exploitable for Kerberos relay. While SMBv1 is deprecated and not even installed on newer installs of Windows, it&amp;#39;s still worth looking at the implementation of v1 and v2 to determine if either are exploitable.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;The client implementations of SMB 1 and 2 are in &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;mrxsmb10.sys&lt;/span&gt;&lt;span&gt;&amp;nbsp;and &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;mrxsmb20.sys&lt;/span&gt;&lt;span&gt;&amp;nbsp;respectively with some common code in &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;mrxsmb.sys&lt;/span&gt;&lt;span&gt;. Both protocols support specifying a name for the SPN which is related to DFS. The SPN name needs to be specified through the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;GUID_ECP_DOMAIN_SERVICE_NAME_CONTEXT&lt;/span&gt;&lt;span&gt;&amp;nbsp;ECP and is only enabled if the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;NETWORK_OPEN_ECP_OUT_FLAG_RET_MUTUAL_AUTH &lt;/span&gt;&lt;span&gt;flag in the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;GUID_ECP_NETWORK_OPEN_CONTEXT &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;ECP (set by MUP) is specified. This is related to UNC hardening which was added to protect things like group policies.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;It&amp;#39;s easy enough to trigger the conditions to set the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;NETWORK_OPEN_ECP_OUT_FLAG_RET_MUTUAL_AUTH&lt;/span&gt;&lt;span&gt;&amp;nbsp;flag. The default UNC hardening rules always add SYSVOL and NETLOGON UNC paths with a wildcard hostname. Therefore a request to &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;\\evil.com\SYSVOL&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;will cause the flag to be set and the SPN potentially overridable. The server should be a DFS server for this to work, however even with the flag set I&amp;#39;ve not found a way of setting an arbitrary SPN value remotely.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;Even if you could spoof the SPN, the SMB clients always enable Integrity protection. Like LDAP, SMB will enable signing and encryption opportunistically if available from the client, unless UNC hardening measures are in place.&lt;/span&gt;&lt;/p&gt;&lt;h2 class=&quot;c26&quot; id=&quot;h.kia6c4byjbr3&quot;&gt;&lt;span class=&quot;c6 c19&quot;&gt;Marshaled Target Information SPN&lt;/span&gt;&lt;/h2&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;While investigating the SMB implementation I noticed something interesting. The SMB clients use the function &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-secmakespnex2&quot;&gt;SecMakeSPNEx2&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;to build the SPN value from the service class and name. You might assume this would just return the SPN as-is, however that&amp;#39;s not the case. Instead for the hostname of &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;fileserver &lt;/span&gt;&lt;span&gt;with the service class &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;cifs&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;you get back an SPN which looks like the following:&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;a id=&quot;t.0468306ab73a53f6535ab8bb12a4cae517044efb&quot;&gt;&lt;/a&gt;&lt;a id=&quot;t.7&quot;&gt;&lt;/a&gt;&lt;table class=&quot;c21&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;c20&quot;&gt;&lt;td class=&quot;c11&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2 c4&quot;&gt;cifs/fileserver1UWhRCAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAfileserversBAAAA&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;Looking at the implementation of &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;SecMakeSPNEx2&lt;/span&gt;&lt;span&gt;&amp;nbsp;it makes a call to the API function &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/ntsecpkg/nf-ntsecpkg-credmarshaltargetinfo&quot;&gt;CredMarshalTargetInfo&lt;/a&gt;&lt;/span&gt;&lt;span&gt;. This API takes a list of target information in a &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/wincred/ns-wincred-credential_target_informationw&quot;&gt;CREDENTIAL_TARGET_INFORMATION&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;structure and marshals it using a base64 string encoding. This marshaled string is then appended to the end of the real SPN.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;The code is therefore just appending some additional target information to the end of the SPN, presumably so it&amp;#39;s easier to pass around. My initial assumption would be this information is stripped off before passing to the SSPI APIs by the SMB client. However, passing this SPN value to &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;InitializeSecurityContext&lt;/span&gt;&lt;span&gt;&amp;nbsp;as the target name succeeds and gets a Kerberos service ticket for &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;cifs/fileserver&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;. How does that work?&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;Inside the function &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;SspiExProcessSecurityContext &lt;/span&gt;&lt;span&gt;in &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;lsasrv.dll&lt;/span&gt;&lt;span&gt;, which is the main entrypoint of &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;InitializeSecurityContext, &lt;/span&gt;&lt;span&gt;there&amp;#39;s a call to the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;CredUnmarshalTargetInfo &lt;/span&gt;&lt;span&gt;API, which parses the marshaled target information. However &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;SspiExProcessSecurityContext &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;doesn&amp;#39;t care about the unmarshalled results, instead it just gets the length of the marshaled data and removes that from the end of the target SPN string. Therefore before the Kerberos package gets the target name it has already been restored to the original SPN.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;The encoded SPN shown earlier, minus the service class, is a valid DNS component name and therefore could be used as the hostname in a public or local DNS resolution request. This is interesting as this potentially gives a way of spoofing a hostname which is distinct from the real target service, but when processed by the SSPI API requests the spoofed service ticket. As in if you use the string &lt;/span&gt;&lt;span class=&quot;c42 c4&quot;&gt;fileserver1UWhRCAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAfileserversBAAAA&lt;/span&gt;&lt;span&gt;&amp;nbsp;as the DNS name, and if the client appends a service class to the name and passes it to SSPI it will get a service ticket for &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;fileserver&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;, however the DNS resolving can trivially return an unrelated IP address.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;There are some big limitations to abusing this behavior. The marshaled target information must be valid, the last 6 characters is an encoded length of the entire marshaled buffer and the buffer is prefixed with a 28 byte header with a magic value of 0x91856535 in the first 4 bytes. If this length is invalid (e.g. larger than the buffer or not a multiple of 2) or the magic isn&amp;#39;t present then the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;CredUnmarshalTargetInfo &lt;/span&gt;&lt;span&gt;call fails and &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;SspiExProcessSecurityContext&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;leaves the SPN as is which will subsequently fail to query a Kerberos ticket for the SPN.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;The easiest way that the name could be invalid is by it being converted to lowercase. DNS is case insensitive, however generally the servers are case preserving. Therefore you could lookup the case sensitive name and the DNS server would return that unmodified. However the HTTP clients tested all seem to lowercase the hostname before use, therefore by the time it&amp;#39;s used to build an SPN it&amp;#39;s now a different string. When unmarshalling &amp;#39;a&amp;#39; and &amp;#39;A&amp;#39; represent different binary values and so parsing of the marshaled information will fail.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;Another issue is that the size limit of a single name in DNS is 63 characters. The minimum valid marshaled buffer is 44 characters long leaving only 19 characters for the SPN part. This is at least larger than the minimum NetBIOS name limit of 15 characters so as long as there&amp;#39;s an SPN for that shorter name registered it should be sufficient. However if there&amp;#39;s no short SPN name registered then it&amp;#39;s going to be more difficult to exploit.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;In theory you could specify the SPN using its FQDN. However it&amp;#39;s hard to construct such a name. The length value must be at the end of the string and needs to be a valid marshaled value so you can&amp;#39;t have any dots within its 6 characters. It&amp;#39;s possible to have a TLD which is 6 characters or longer and as the embedded marshaled values are not escaped this can be used to construct a valid FQDN which would then resolve to another SPN target. For example:&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;a id=&quot;t.18557f87bd0691805cf0d36ab288c563e4a9d02e&quot;&gt;&lt;/a&gt;&lt;a id=&quot;t.8&quot;&gt;&lt;/a&gt;&lt;table class=&quot;c21&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;c20&quot;&gt;&lt;td class=&quot;c11&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2 c4&quot;&gt;fileserver1UWhRCAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAA.domain.oBAAAA&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;is a valid DNS name which would resolve to an SPN for &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;fileserver&lt;/span&gt;&lt;span&gt;. Except that &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;oBAAAA&lt;/span&gt;&lt;span&gt;&amp;nbsp;is not a valid public TLD. Pulling the list of &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://data.iana.org/TLD/tlds-alpha-by-domain.txt&quot;&gt;valid TLDs&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;from ICANN&amp;#39;s website and converting all values which are 6 characters or longer into the expected length value, the smallest length which is a multiple of 2 is from &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;WEBCAM&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;span&gt;which results in a DNS name at least 264331 characters long, which is somewhat above the 255 character limit usually considered valid for a FQDN in DNS.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;Therefore this would still be limited to more local attacks and only for limited sets of protocols. For example an authenticated user could register a DNS entry for the local domain using this value and trick an RPC client to connect to it using its undotted hostname. As long as the client doesn&amp;#39;t modify the name other than putting the service class on it (or it gets automatically generated by the RPC runtime) then this spoofs the SPN for the request.&lt;/span&gt;&lt;/p&gt;&lt;h2 class=&quot;c26&quot; id=&quot;h.bxbpd7nw1n75&quot;&gt;&lt;span class=&quot;c6 c19&quot;&gt;Microsoft&amp;#39;s Response to the Research&lt;/span&gt;&lt;/h2&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;I didn&amp;#39;t initially start looking at Kerberos authentication relay, as mentioned I found it inadvertently when looking at IPsec and AuthIP which I subsequently reported to Microsoft. After doing more research into other network protocols I decided to use the AuthIP issue as a bellwether on Microsoft&amp;#39;s views on whether relaying Kerberos authentication and spoofing SPNs would cross a security boundary.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;As I mentioned earlier the AuthIP issue was classed as &amp;quot;vNext&amp;quot;, which denotes it might be fixed in a future version of Windows, but not as a security update for any currently shipping version of Windows. This was because Microsoft determined it to be a Moderate severity issue (see &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://query.prod.cms.rt.microsoft.com/cms/api/am/binary/RE2A3xt&quot;&gt;this&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;for the explanation of the severities). Only Important or above will be serviced.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;It seems that the general rule is that any network protocol where the SPN can be spoofed to generate Kerberos authentication which can be relayed, is not sufficient to meet the severity level for a fix. However, any network facing service which can be used to induce authentication where the attacker does not have existing network authentication credentials is considered an Important severity spoofing issue and will be fixed. This is why PetitPotam was fixed as &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2021-36942&quot;&gt;CVE-2021-36942&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;, as it could be exploited from an unauthenticated user.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;As my research focused entirely on the network protocols themselves and not the ways of inducing authentication, they will all be covered under the same Moderate severity. This means that if they were to be fixed at all, it&amp;#39;d be in unspecified future versions of Windows.&lt;/span&gt;&lt;/p&gt;&lt;h2 class=&quot;c26&quot; id=&quot;h.7zz0k0f1r0u6&quot;&gt;&lt;span class=&quot;c6 c19&quot;&gt;Available Mitigations&lt;/span&gt;&lt;/h2&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;How can you defend yourself against authentication relay attacks presented in this blog post? While I think I&amp;#39;ve made the case that it&amp;#39;s possible to relay Kerberos authentication, it&amp;#39;s somewhat more limited in scope than NTLM relay. This means that disabling NTLM is still an invaluable option for mitigating authentication relay issues on a Windows enterprise network. &lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;Also, except for disabling NTLM, all the mitigations for NTLM relay apply to Kerberos relay. Requiring signing or sealing on the protocol if possible is sufficient to prevent the majority of attack vectors, especially on important network services such as LDAP.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;For TLS encapsulated protocols, channel binding prevents the authentication being relayed as I didn&amp;#39;t find any way of spoofing the TLS certificate at the same time. If the network service supports EPA, such as HTTPS or LDAPS it should be enabled. Even if the protocol doesn&amp;#39;t support EPA, enabling TLS protection if possible is still valuable. This not only provides more robust server authentication, which Kerberos mutual authentication doesn&amp;#39;t really provide, it&amp;#39;ll also hide Kerberos authentication tokens from sniffing or MitM attacks.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;Some libraries, such as WinHTTP and .NET set the undocumented &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;ISC_REQ_UNVERIFIED_TARGET_NAME&lt;/span&gt;&lt;span&gt;&amp;nbsp;request attribute when calling &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;InitializeSecurityContext&lt;/span&gt;&lt;span&gt;&amp;nbsp;in certain circumstances&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;. This affects the behavior of the server when querying for the SPN used during authentication. Some servers such as SMB and IIS with EPA can be configured to validate the SPN. If this request attribute flag is set then while the authentication will succeed when the server goes to check the SPN, it gets an empty string which will not match the server&amp;#39;s expectations. If you&amp;#39;re a developer you should use this flag if the SPN has been provided from an untrustworthy source, although this will only be beneficial if the server is checking the received SPN.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;A common thread through the research is abusing local DNS resolution to spoof the SPN. Disabling LLMNR and MDNS should always be best practice, and this just highlights the dangers of leaving them enabled. While it might be possible to perform the same attacks through DNS spoofing attacks, these are likely to be much less reliable than local DNS spoofing attacks.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;If Windows authentication isn&amp;#39;t needed from a network client, it&amp;#39;d be wise to disable it if supported. For example, some HTTP user agents support disabling automatic Windows authentication entirely, while others such as Firefox don&amp;#39;t enable it by default. Chromium also supports disabling the DNS lookup process for generating the SPN through group policy.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;Finally, blocking untrusted devices on the network such as through 802.1X or requiring authenticated IPsec/IKEv2 for all network communications to high value services would go some way to limiting the impact of all authentication relay attacks. Although of course, an attacker could still compromise a trusted host and use that to mount the attack.&lt;/span&gt;&lt;/p&gt;&lt;h2 class=&quot;c26&quot; id=&quot;h.lhddftsoy07y&quot;&gt;&lt;span class=&quot;c6 c19&quot;&gt;Conclusions&lt;/span&gt;&lt;/h2&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;I hope that this blog post has demonstrated that Kerberos relay attacks are feasible and just disabling NTLM is not a sufficient mitigation strategy in an enterprise environment. While DNS is a common thread and is the root cause of the majority of these protocol issues, it&amp;#39;s still possible to spoof SPNs using other protocols such as AuthIP and MSRPC without needing to play DNS tricks.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;While I wrote my own tooling to perform the LLMNR attack there are various public tools which can mount an LLMNR and MDNS spoofing attack such as the venerable &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;&lt;a class=&quot;c51&quot; href=&quot;https://github.com/SpiderLabs/Responder&quot;&gt;Python Responder&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;. It shouldn&amp;#39;t be hard to modify one of the tools to verify my findings.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;I&amp;#39;ve also not investigated every possible network protocol which might perform Kerberos authentication. I&amp;#39;ve also not looked at non-Windows systems which might support Kerberos such as Linux and macOS. It&amp;#39;s possible that in more heterogeneous networks the impact might be more pronounced as some of the security changes in Microsoft&amp;#39;s Kerberos implementation might not be present.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3&quot;&gt;If you&amp;#39;re doing your own research into this area, you should look at how the SPN is specified by the protocol, but also how the implementation builds it. For example the HTTP Negotiate RFC states how to build the SPN for Kerberos, but then each implementation does it slightly differently and not to the RFC specification.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0 c9&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span&gt;You should be especially wary of any protocol where an untrusted server can specify an arbitrary SPN. This is the case in AuthIP, MSRPC and DCOM. It&amp;#39;s almost certain that when these protocols were originally designed many years ago, that no thought was given to the possible abuse of this design for relaying the Kerberos network authentication. &lt;/span&gt;&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='https://googleprojectzero.blogspot.com/feeds/6510029969921067809/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='https://googleprojectzero.blogspot.com/2021/10/using-kerberos-for-authentication-relay.html#comment-form' title='0 Comments'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/4838136820032157985/posts/default/6510029969921067809'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/4838136820032157985/posts/default/6510029969921067809'/><link rel='alternate' type='text/html' href='https://googleprojectzero.blogspot.com/2021/10/using-kerberos-for-authentication-relay.html' title='Using Kerberos for Authentication Relay Attacks'/><author><name>Anonymous</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/blank.gif'/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://blogger.googleusercontent.com/img/a/AVvXsEjeIXhBwnBcGsUREqJ9YPAEyeTw99GDlcn_PmW7fyuxGGkop9HvtErkOKfvy6WXzeXZFfXdOR8C-StQgu3qPaE-t48EHnQ0xPbUgBDm3-jyO_dij-bFHf4Vw6v-ryL9D7FixnLa6I88bzvbkx-QNGx7Wxhc3GGWmJGa9Xbu1-HIZGM0SA1HQWcERC_y2w=s72-c" height="72" width="72"/><thr:total>0</thr:total></entry>