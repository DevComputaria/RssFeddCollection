<?xml version='1.0' encoding='UTF-8'?><?xml-stylesheet href="http://www.blogger.com/styles/atom.css" type="text/css"?><entry xmlns='http://www.w3.org/2005/Atom' xmlns:blogger='http://schemas.google.com/blogger/2008' xmlns:georss='http://www.georss.org/georss' xmlns:gd='http://schemas.google.com/g/2005' xmlns:thr='http://purl.org/syndication/thread/1.0'><id>tag:blogger.com,1999:blog-4838136820032157985.post-5444284102989534433</id><published>2021-09-14T10:14:00.002-07:00</published><updated>2022-08-23T12:32:29.457-07:00</updated><title type='text'>Fuzzing Closed-Source JavaScript Engines with Coverage Feedback</title><content type='html'>&lt;style type=&quot;text/css&quot;&gt;ul.lst-kix_do14k59gl4sr-0{list-style-type:none}ul.lst-kix_do14k59gl4sr-1{list-style-type:none}ul.lst-kix_do14k59gl4sr-2{list-style-type:none}ul.lst-kix_do14k59gl4sr-3{list-style-type:none}.lst-kix_u927wi79aeqb-0&gt;li:before{content:&quot;-  &quot;}.lst-kix_u927wi79aeqb-1&gt;li:before{content:&quot;-  &quot;}.lst-kix_u927wi79aeqb-2&gt;li:before{content:&quot;-  &quot;}.lst-kix_do14k59gl4sr-2&gt;li:before{content:&quot;-  &quot;}ul.lst-kix_do14k59gl4sr-4{list-style-type:none}.lst-kix_u927wi79aeqb-5&gt;li:before{content:&quot;-  &quot;}ul.lst-kix_do14k59gl4sr-5{list-style-type:none}.lst-kix_do14k59gl4sr-1&gt;li:before{content:&quot;-  &quot;}ul.lst-kix_do14k59gl4sr-6{list-style-type:none}ul.lst-kix_do14k59gl4sr-7{list-style-type:none}.lst-kix_do14k59gl4sr-0&gt;li:before{content:&quot;-  &quot;}ul.lst-kix_do14k59gl4sr-8{list-style-type:none}.lst-kix_u927wi79aeqb-3&gt;li:before{content:&quot;-  &quot;}.lst-kix_u927wi79aeqb-4&gt;li:before{content:&quot;-  &quot;}.lst-kix_u927wi79aeqb-6&gt;li:before{content:&quot;-  &quot;}.lst-kix_do14k59gl4sr-3&gt;li:before{content:&quot;-  &quot;}.lst-kix_do14k59gl4sr-4&gt;li:before{content:&quot;-  &quot;}.lst-kix_u927wi79aeqb-7&gt;li:before{content:&quot;-  &quot;}.lst-kix_u927wi79aeqb-8&gt;li:before{content:&quot;-  &quot;}li.li-bullet-0:before{margin-left:-18pt;white-space:nowrap;display:inline-block;min-width:18pt}ul.lst-kix_u927wi79aeqb-0{list-style-type:none}.lst-kix_do14k59gl4sr-6&gt;li:before{content:&quot;-  &quot;}ul.lst-kix_u927wi79aeqb-2{list-style-type:none}.lst-kix_do14k59gl4sr-5&gt;li:before{content:&quot;-  &quot;}.lst-kix_do14k59gl4sr-7&gt;li:before{content:&quot;-  &quot;}ul.lst-kix_u927wi79aeqb-1{list-style-type:none}ul.lst-kix_u927wi79aeqb-4{list-style-type:none}ul.lst-kix_u927wi79aeqb-3{list-style-type:none}ul.lst-kix_u927wi79aeqb-6{list-style-type:none}ul.lst-kix_u927wi79aeqb-5{list-style-type:none}ul.lst-kix_u927wi79aeqb-8{list-style-type:none}ul.lst-kix_u927wi79aeqb-7{list-style-type:none}.lst-kix_do14k59gl4sr-8&gt;li:before{content:&quot;-  &quot;}ol{margin:0;padding:0}table td,table th{padding:0}.c0{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:&quot;Arial&quot;;font-style:normal}.c9{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:20pt;font-family:&quot;Arial&quot;;font-style:normal}.c2{padding-top:20pt;padding-bottom:6pt;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c10{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:&quot;Arial&quot;;font-style:italic}.c12{padding-top:0pt;padding-bottom:0pt;line-height:1.5;orphans:2;widows:2;text-align:center}.c1{padding-top:0pt;padding-bottom:0pt;line-height:1.5;orphans:2;widows:2;text-align:left}.c7{color:#000000;text-decoration:none;vertical-align:baseline;font-size:11pt;font-style:normal}.c5{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline}.c14{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c6{font-weight:400;font-family:&quot;Courier New&quot;}.c3{margin-left:36pt;padding-left:0pt}.c13{padding:0;margin:0}.c8{color:inherit;text-decoration:inherit}.c11{font-style:italic}.c4{height:11pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:&quot;Arial&quot;}p{margin:0;color:#000000;font-size:11pt;font-family:&quot;Arial&quot;}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}&lt;/style&gt;&lt;/head&gt;&lt;body class=&quot;c14&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;Posted by Ivan Fratric, Project Zero&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c4&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span&gt;tl;dr I combined &lt;/span&gt;&lt;span class=&quot;c5&quot;&gt;&lt;a class=&quot;c81&quot; href=&quot;https://github.com/googleprojectzero/fuzzilli&quot;&gt;Fuzzilli&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;(an open-source JavaScript engine fuzzer), with &lt;/span&gt;&lt;span class=&quot;c5&quot;&gt;&lt;a class=&quot;c81&quot; href=&quot;https://github.com/googleprojectzero/TinyInst&quot;&gt;TinyInst&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;(an open-source dynamic instrumentation library for fuzzing). I also added grammar-based mutation support to &lt;/span&gt;&lt;span class=&quot;c5&quot;&gt;&lt;a class=&quot;c81&quot; href=&quot;https://github.com/googleprojectzero/Jackalope&quot;&gt;Jackalope&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;(my black-box binary fuzzer). So far, these two approaches resulted in finding three security issues in jscript9.dll (default JavaScript engine used by Internet Explorer).&lt;/span&gt;&lt;/p&gt;&lt;h1 class=&quot;c2&quot; id=&quot;h.hggl0cdn9982&quot;&gt;&lt;span class=&quot;c9&quot;&gt;Introduction or &amp;ldquo;when you can&amp;rsquo;t beat them, join them&amp;rdquo;&lt;/span&gt;&lt;/h1&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span&gt;In the past, I&amp;rsquo;ve invested a lot of time in generation-based fuzzing, which was a successful way to find vulnerabilities in various targets, especially those that take some form of language as input. For example, Domato, my grammar-based generational fuzzer, found &lt;/span&gt;&lt;span class=&quot;c5&quot;&gt;&lt;a class=&quot;c81&quot; href=&quot;https://bugs.chromium.org/p/project-zero/issues/list?q=ifratric%20webkit&amp;can=1&quot;&gt;over 40 vulnerabilities in WebKit&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;and &lt;/span&gt;&lt;span class=&quot;c5&quot;&gt;&lt;a class=&quot;c81&quot; href=&quot;https://bugs.chromium.org/p/project-zero/issues/list?q=ifratric%20jscript&amp;can=1&quot;&gt;numerous bugs in Jscript&lt;/a&gt;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c4&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span&gt;While generation-based fuzzing is still a good way to fuzz many complex targets, it was demonstrated that, for finding vulnerabilities in modern JavaScript engines, especially engines with JIT compilers, better results can be achieved with mutational, coverage-guided approaches. My colleague Samuel Gro&amp;szlig; gives a compelling case on why that is in his &lt;/span&gt;&lt;span class=&quot;c5&quot;&gt;&lt;a class=&quot;c81&quot; href=&quot;https://www.youtube.com/watch?v=OHjq9Y66yfc&quot;&gt;OffensiveCon talk&lt;/a&gt;&lt;/span&gt;&lt;span&gt;. Samuel is also the author of &lt;/span&gt;&lt;span class=&quot;c5&quot;&gt;&lt;a class=&quot;c81&quot; href=&quot;https://github.com/googleprojectzero/fuzzilli&quot;&gt;Fuzzilli&lt;/a&gt;&lt;/span&gt;&lt;span&gt;, an open-source JavaScript engine fuzzer based on mutating a custom intermediate language. Fuzzilli has found a large number of bugs in various JavaScript engines.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c4&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span&gt;While there has been a lot of development on coverage-guided fuzzers over the last few years, most of the public tooling focuses on open-source targets or software running on the Linux operating system. Meanwhile, I focused on developing tooling for fuzzing of closed-source binaries on operating systems where such software is more prevalent (currently Windows and macOS). Some years back, I published &lt;/span&gt;&lt;span class=&quot;c5&quot;&gt;&lt;a class=&quot;c81&quot; href=&quot;https://github.com/googleprojectzero/winafl&quot;&gt;WinAFL&lt;/a&gt;&lt;/span&gt;&lt;span&gt;, the first performant AFL-based fuzzer for Windows. About a year and a half ago, however, I started working on a brand new toolset for black-box coverage-guided fuzzing. &lt;/span&gt;&lt;span class=&quot;c5&quot;&gt;&lt;a class=&quot;c81&quot; href=&quot;https://github.com/googleprojectzero/TinyInst&quot;&gt;TinyInst&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;and &lt;/span&gt;&lt;span class=&quot;c5&quot;&gt;&lt;a class=&quot;c81&quot; href=&quot;https://github.com/googleprojectzero/Jackalope&quot;&gt;Jackalope&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;are the two outcomes of this effort.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c4&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;It comes somewhat naturally to combine the tooling I&amp;rsquo;ve been working on with techniques that have been so successful in finding JavaScript bugs, and try to use the resulting tooling to fuzz JavaScript engines for which the source code is not available. Of such engines, I know two: jscript and jscript9 (implemented in jscript.dll and jscript9.dll) on Windows, which are both used by the Internet Explorer web browser. Of these two, jscript9 is probably more interesting in the context of mutational coverage-guided fuzzing since it includes a JIT compiler and more advanced engine features.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c4&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span&gt;While you might think that Internet Explorer is a &lt;/span&gt;&lt;span class=&quot;c5&quot;&gt;&lt;a class=&quot;c81&quot; href=&quot;https://blogs.windows.com/windowsexperience/2021/05/19/the-future-of-internet-explorer-on-windows-10-is-in-microsoft-edge/&quot;&gt;thing of the past&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;and it doesn&amp;rsquo;t make sense to spend energy looking for bugs in it, the fact remains that Internet Explorer is still heavily exploited by real-world attackers. &lt;/span&gt;&lt;span&gt;In &lt;/span&gt;&lt;span class=&quot;c5&quot;&gt;&lt;a class=&quot;c81&quot; href=&quot;https://docs.google.com/spreadsheets/d/1lkNJ0uQwbeC1ZTRrxdtuPLCIl7mlUreoKfSIgajnSyY/edit#gid=1869060786&quot;&gt;2020&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;there were two Internet Explorer 0days exploited in the wild and three in &lt;/span&gt;&lt;span class=&quot;c5&quot;&gt;&lt;a class=&quot;c81&quot; href=&quot;https://docs.google.com/spreadsheets/d/1lkNJ0uQwbeC1ZTRrxdtuPLCIl7mlUreoKfSIgajnSyY/edit#gid=2129022708&quot;&gt;2021&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;so far&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;. One of these vulnerabilities was in the JIT compiler of jscript9. I&amp;rsquo;ve personally vowed several times that I&amp;rsquo;m done looking into Internet Explorer, but each time, more 0days in the wild pop up and I change my mind.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c4&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;Additionally, the techniques described here could be applied to any closed-source or even open-source software, not just Internet Explorer. In particular, grammar-based mutational fuzzing described two sections down can be applied to targets other than JavaScript engines by simply changing the input grammar.&lt;/span&gt;&lt;/p&gt;&lt;h1 class=&quot;c2&quot; id=&quot;h.6xk10d57ptf2&quot;&gt;&lt;span class=&quot;c9&quot;&gt;Approach 1: Fuzzilli + TinyInst&lt;/span&gt;&lt;/h1&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c5&quot;&gt;&lt;a class=&quot;c81&quot; href=&quot;https://github.com/googleprojectzero/fuzzilli&quot;&gt;Fuzzilli&lt;/a&gt;&lt;/span&gt;&lt;span&gt;, as said above&lt;/span&gt;&lt;span&gt;, is a state-of-the-art JavaScript engine fuzzer and &lt;/span&gt;&lt;span class=&quot;c5&quot;&gt;&lt;a class=&quot;c81&quot; href=&quot;https://github.com/googleprojectzero/TinyInst&quot;&gt;TinyInst&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;is a dynamic instrumentation library. Although TinyInst is general-purpose and could be used in other applications, it comes with various features useful for fuzzing, such as out-of-the-box support for persistent fuzzing, various types of coverage instrumentations etc. TinyInst is meant to be simple to integrate with other software, in particular fuzzers, and has already been integrated with some.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c4&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;So, integrating with Fuzzilli was meant to be simple. However, there were still various challenges to overcome for different reasons:&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c4&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c10&quot;&gt;Challenge 1: Getting Fuzzilli to build on Windows where our targets are.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c4&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;
   &lt;p class=&quot;c1&quot; style=&quot;font-style: italic&quot;&gt;&lt;span&gt;&lt;span style=&quot;font-weight: bold&quot;&gt;Edit 2021-09-20&lt;/span&gt;: The version of Swift for Windows used in this project was from January 2021, when I first started working on it. Since version 5.4, Swift Package Manager is supported on Windows, so building Swift code should be much easier now. Additionally, static linking is supported for C/C++ code.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c4&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span&gt;Fuzzilli was written in Swift and the support for Swift on Windows is currently not great. While &lt;/span&gt;&lt;span class=&quot;c5&quot;&gt;&lt;a class=&quot;c81&quot; href=&quot;https://github.com/compnerd/swift-build&quot;&gt;Swift on Windows&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;builds&lt;/span&gt;&lt;span&gt;&amp;nbsp;exist (I&amp;rsquo;m linking to the builds by Saleem Abdulrasool instead of the official ones because the latter didn&amp;rsquo;t work for me), not all features that you would find on Linux and macOS are there. For example, one does not simply run &lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;swift build&lt;/span&gt;&lt;span&gt;&amp;nbsp;on Windows, as the build system is one of the features that didn&amp;rsquo;t get ported (yet). Fortunately, CMake and Ninja &amp;nbsp;support Swift, so the solution to this problem is to switch to the CMake build system. There are &lt;/span&gt;&lt;span class=&quot;c5&quot;&gt;&lt;a class=&quot;c81&quot; href=&quot;https://github.com/compnerd/swift-cmake-examples&quot;&gt;helpful examples&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;on how to do this, once again from Saleem Abdulrasool.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c4&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span&gt;Another feature that didn&amp;rsquo;t make it to Swift for Windows is statically linking libraries. This means that all libraries (such as those written in C and C++ that the user wants to include in their Swift project) need to be dynamically linked. This goes for libraries already included in the Fuzzilli project, but also for TinyInst. Since TinyInst also uses the CMake build system, my first attempt at integrating TinyInst was to include it via the Fuzzilli CMake project, and simply have it built as a shared library. However, the same tooling that was successful in building Fuzzilli would fail to build TinyInst (probably due to various platform libraries TinyInst uses). That&amp;rsquo;s why, in the end, TinyInst was being built separately into a .dll and this .dll loaded &amp;ldquo;manually&amp;rdquo; into Fuzzilli via the &lt;/span&gt;&lt;span class=&quot;c5&quot;&gt;&lt;a class=&quot;c81&quot; href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya&quot;&gt;LoadLibrary&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;API. This turned out not to be so bad - Swift build tooling for Windows was quite slow, and so it was much faster to only build TinyInst when needed, rather than build the entire Fuzzilli project (even when the changes made were minor).&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c4&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;The Linux/macOS parts of Fuzzilli, of course, also needed to be rewritten. Fortunately, it turned out that the parts that needed to be rewritten were the parts written in C, and the parts written in Swift worked as-is (other than a couple of exceptions, mostly related to networking). As someone with no previous experience with Swift, this was quite a relief. The main parts that needed to be rewritten were the networking library (libsocket), the library used to run and monitor the child process (libreprl) and the library for collecting coverage (libcoverage). The latter two were changed to use TinyInst. Since these are separate libraries in Fuzzilli, but TinyInst handles both of these tasks, some plumbing through Swift code was needed to make sure both of these libraries talk to the same TinyInst instance for a given target.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c4&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c10&quot;&gt;Challenge 2: Threading woes&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c4&quot;&gt;&lt;span class=&quot;c10&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span&gt;Another feature that made the integration less straightforward than hoped for was the use of threading in Swift. TinyInst is built on a custom debugger and, on Windows, it uses the Windows debugging API. One specific feature of the Windows debugging API, for example &lt;/span&gt;&lt;span class=&quot;c5&quot;&gt;&lt;a class=&quot;c81&quot; href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/debugapi/nf-debugapi-waitfordebugevent&quot;&gt;WaitForDebugEvent&lt;/a&gt;&lt;/span&gt;&lt;span&gt;, is that it does not take a debugee pid or a process handle as an argument. So then, the question is, if you have multiple debugees, to which of them does the API call refer? The answer to that is, when a debugger on Windows attaches to a debugee (or starts a debugee process), the &lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;thread&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp; that started/attached it is the debugger. Any subsequent calls for that particular debugee need to be issued on that same thread.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c4&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span&gt;In contrast, the preferred Swift coding style (that Fuzzilli also uses) is to take advantage of threading primitives such as &lt;/span&gt;&lt;span class=&quot;c5&quot;&gt;&lt;a class=&quot;c81&quot; href=&quot;https://developer.apple.com/documentation/dispatch/dispatchqueue&quot;&gt;DispatchQueue&lt;/a&gt;&lt;/span&gt;&lt;span&gt;. When tasks get posted on a DispatchQueue, they can run in parallel on &amp;ldquo;background&amp;rdquo; threads. However, with the background threads, there is no guarantee that a certain task is always going to run on the same thread. So it would happen that calls to the same TinyInst instance happened from different threads, thus breaking the Windows debugging model. &lt;/span&gt;&lt;span&gt;This is why, for the purposes of this project, TinyInst was modified to create its own thread (one for each target process) and ensure that any debugger calls for a particular child process always happen on that thread.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c4&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c10&quot;&gt;Various minor changes&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c4&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span&gt;Some examples of features Fuzzilli requires that needed to be added to TinyInst are &lt;/span&gt;&lt;span&gt;stdin/stdout&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;redirection and a channel for reading out the &amp;ldquo;status&amp;rdquo; of JavaScript execution (specifically, to be able to tell if JavaScript code was throwing an exception or executing successfully). Some of these features were already integrated into the &amp;ldquo;mainline&amp;rdquo; TinyInst or will be integrated in the future.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c4&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;After all of that was completed though, the Fuzzilli/Tinyinst hybrid was running in a stable manner:&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c4&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c12&quot;&gt;&lt;/p&gt;
  
 &lt;p class=&quot;c12&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiry3nRhxaazq03y2AKG_3VBvYocm8t5239naPV7YNNU_FWG9uUcVsOjUTDwf9JDft3dkh7Qpxr-UgRfshNt7FAtbYARvIbpbTIYWK3RS_hFhSjX-7rAy4WmN_5nsgIlktzDWNBzZEpDVJWlERlFwc0hcOgZl8rg_-akQ6w9918lhrM_oFisW7F_43P/s1999/image2%20%283%29.png&quot; style=&quot;display: block; padding: 1em 0;text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiry3nRhxaazq03y2AKG_3VBvYocm8t5239naPV7YNNU_FWG9uUcVsOjUTDwf9JDft3dkh7Qpxr-UgRfshNt7FAtbYARvIbpbTIYWK3RS_hFhSjX-7rAy4WmN_5nsgIlktzDWNBzZEpDVJWlERlFwc0hcOgZl8rg_-akQ6w9918lhrM_oFisW7F_43P/s1999/image2%20%283%29.png&quot; border=&quot;0&quot; alt=&quot;&quot; style=&quot;max-height: 750px; max-width: 600px;&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c12 c4&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span&gt;Note that coverage percentage reported by Fuzzilli is incorrect. Because TinyInst is a dynamic instrumentation library, it cannot know the number of basic blocks/edges in advance. &lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c4&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span&gt;Primarily because of the current Swift on Windows issues, this closed-source mode of Fuzzilli is not something we want to officially support. However, the sources and the build we used can be downloaded &lt;/span&gt;&lt;span class=&quot;c5&quot;&gt;&lt;a class=&quot;c81&quot; href=&quot;https://drive.google.com/file/d/10q4bIZHYAxQRkEVSk27Z7NPjKNnB6dKq/view&quot;&gt;here&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;.&lt;/span&gt;&lt;/p&gt;&lt;h1 class=&quot;c2&quot; id=&quot;h.xashu4kji8s8&quot;&gt;&lt;span class=&quot;c9&quot;&gt;Approach 2: Grammar-based mutation fuzzing with Jackalope&lt;/span&gt;&lt;/h1&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c5&quot;&gt;&lt;a class=&quot;c81&quot; href=&quot;https://github.com/googleprojectzero/Jackalope&quot;&gt;Jackalope&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;is a coverage-guided fuzzer I developed for fuzzing black-box binaries on Windows and, recently, macOS. Jackalope initially included mutators suitable for fuzzing of binary formats. However, a key feature of Jackalope is modularity: it is meant to be easy to plug in or replace individual components, including, but not limited to, sample mutators.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c4&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;After observing how Fuzzilli works more closely during Approach 1, as well as observing samples it generated and the bugs it found, the idea was to extend Jackalope to allow mutational JavaScript fuzzing, but also in the future, mutational fuzzing of other targets whose samples can be described by a context-free grammar.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c4&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span&gt;Jackalope uses a grammar syntax similar to that of &lt;/span&gt;&lt;span class=&quot;c5&quot;&gt;&lt;a class=&quot;c81&quot; href=&quot;https://github.com/googleprojectzero/domato&quot;&gt;Domato&lt;/a&gt;&lt;/span&gt;&lt;span&gt;, but somewhat simplified (with some features not supported at this time). This grammar format is easy to write and easy to modify (but also easy to parse). The grammar syntax, as well as the list of builtin symbols, can be found on &lt;/span&gt;&lt;span class=&quot;c5&quot;&gt;&lt;a class=&quot;c81&quot; href=&quot;https://github.com/googleprojectzero/Jackalope/tree/main/mutators/grammar&quot;&gt;this page&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;and the JavaScript grammar used in this project can be found &lt;/span&gt;&lt;span class=&quot;c5&quot;&gt;&lt;a class=&quot;c81&quot; href=&quot;https://github.com/googleprojectzero/Jackalope/tree/main/examples/grammar&quot;&gt;here&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c4&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span&gt;One addition to the Domato grammar syntax that allows for more natural mutations, but also sample minimization, are the &lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;&amp;lt;repeat_*&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;grammar nodes. A &lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;&amp;lt;repeat_x&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;symbol tells the grammar engine that it can be represented as zero or more &lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;&amp;lt;x&amp;gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;nodes. For example, in our JavaScript grammar, we have&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c4&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c6 c7&quot;&gt;&amp;lt;statementlist&amp;gt; = &amp;lt;repeat_statement&amp;gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c4&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span&gt;telling the grammar engine that &lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;&amp;lt;statementlist&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;can be constructed by concatenating zero or more &lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;&amp;lt;statement&amp;gt;&lt;/span&gt;&lt;span&gt;s. In our JavaScript grammar, a &lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;&amp;lt;statement&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;expands to an actual JavaScript statement. This helps the mutation engine in the following way: it now knows it can mutate a sample by inserting another &lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;&amp;lt;statement&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;node anywhere in the &lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;&amp;lt;statementlist&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;node. It can also remove &lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;&amp;lt;statement&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;nodes from the &lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;&amp;lt;statementlist&amp;gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;node. Both of these operations will keep the sample valid (in the grammar sense).&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c4&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span&gt;It&amp;rsquo;s not mandatory to have &lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;&amp;lt;repeat_*&amp;gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;nodes in the grammar, as the mutation engine knows how to mutate other nodes as well (see the list of mutations below). However, including them where it makes sense might help make mutations in a more natural way, as is the case of the JavaScript grammar.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c4&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;Internally, grammar-based mutation works by keeping a tree representation of the sample instead of representing the sample just as an array of bytes (Jackalope must in fact represent a grammar sample as a sequence of bytes at some points in time, e.g when storing it to disk, but does so by serializing the tree and deserializing when needed). Mutations work by modifying a part of the tree in a manner that ensures the resulting tree is still valid within the context of the input grammar. Minimization works by removing those nodes that are determined to be unnecessary.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c4&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;Jackalope&amp;rsquo;s mutation engine can currently perform the following operations on the tree:&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c4&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul style=&quot;padding: 0;&quot; class=&quot;c13 lst-kix_u927wi79aeqb-0 start&quot;&gt;&lt;li style=&quot;margin-left: 46pt;&quot; class=&quot;c1 c3 li-bullet-0&quot;&gt;&lt;span&gt;Generate a new tree from scratch&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;. This is not really a mutation and is mainly used to bootstrap the fuzzers when no input samples are provided. In fact, grammar fuzzing mode in Jackalope must either start with an empty corpus or a corpus generated by a previous session. This is because there is currently no way to parse a text file (e.g. a JavaScript source file) into its grammar tree representation (in general, there is no guaranteed unique way to parse a sample with a context-free grammar).&lt;/span&gt;&lt;/li&gt;&lt;li style=&quot;margin-left: 46pt;&quot; class=&quot;c1 c3 li-bullet-0&quot;&gt;&lt;span class=&quot;c0&quot;&gt;Select a random node in the sample&amp;#39;s tree representation. Generate just this node anew while keeping the rest of the tree unchanged.&lt;/span&gt;&lt;/li&gt;&lt;li style=&quot;margin-left: 46pt;&quot; class=&quot;c1 c3 li-bullet-0&quot;&gt;&lt;span class=&quot;c0&quot;&gt;Splice: Select a random node from the current sample and a node with the same symbol from another sample. Replace the node in the current sample with a node from the other sample.&lt;/span&gt;&lt;/li&gt;&lt;li style=&quot;margin-left: 46pt;&quot; class=&quot;c1 c3 li-bullet-0&quot;&gt;&lt;span&gt;Repeat node mutation: One or more new children get added to a &lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;&amp;lt;repeat_*&amp;gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;node, or some of the existing children get replaced.&lt;/span&gt;&lt;/li&gt;&lt;li style=&quot;margin-left: 46pt;&quot; class=&quot;c1 c3 li-bullet-0&quot;&gt;&lt;span&gt;Repeat splice: Selects a &lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;&amp;lt;repeat_*&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;node from the current sample and a similar &lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;&amp;lt;repeat_*&amp;gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;node from another sample. Mixes children from the other node into the current node.&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;
 &lt;p class=&quot;c1 c4&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span&gt;JavaScript grammar was initially constructed by following &amp;nbsp;the &lt;/span&gt;&lt;span class=&quot;c5&quot;&gt;&lt;a class=&quot;c81&quot; href=&quot;https://tc39.es/ecma262/#sec-grammar-summary&quot;&gt;ECMAScript 2022 specification&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;. However, as always when constructing fuzzing grammars from specifications or in a (semi)automated way, this grammar was only a starting point. More manual work was needed to make the grammar output valid and generate interesting samples more frequently.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c4&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span&gt;Jackalope &lt;/span&gt;&lt;span&gt;now supports&lt;/span&gt;&lt;span&gt;&amp;nbsp;grammar fuzzing out-of-the box, and, in order to use it, you just need to add &lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;-grammar &amp;lt;path_to_grammar_file&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;to Jackalope&amp;rsquo;s command lines. In addition to running against closed-source targets on Windows and macOS, Jackalope can now run against open-source targets on Linux using &lt;/span&gt;&lt;span class=&quot;c5&quot;&gt;&lt;a class=&quot;c81&quot; href=&quot;https://clang.llvm.org/docs/SanitizerCoverage.html&quot;&gt;Sanitizer Coverage&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;based instrumentation. This is to allow experimentation with grammar-based mutation fuzzing on open-source software.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c4&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;The following image shows Jackalope running against jscript9.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c4&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c12&quot;&gt;&lt;/p&gt;
  
 &lt;p class=&quot;c12&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg0ICp0XcQvQKPsp_TLgLwihBn_mtCG1gcIsh63iWACU035qj7GOJt7GYuaSL_mHhFVVcIl0FJNlPFfBAZhx7CguYk_tgfPpLZlZWXjaZoR8vEBPEul4iL-5yHMeJt31SFXXIPQTfD1n3M3EjHLPO_HhD9pRryHjOZFRDNCsC4iD2bPLv111rg9IxZC/s1563/image1%20%284%29.png&quot; style=&quot;display: block; padding: 1em 0;text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg0ICp0XcQvQKPsp_TLgLwihBn_mtCG1gcIsh63iWACU035qj7GOJt7GYuaSL_mHhFVVcIl0FJNlPFfBAZhx7CguYk_tgfPpLZlZWXjaZoR8vEBPEul4iL-5yHMeJt31SFXXIPQTfD1n3M3EjHLPO_HhD9pRryHjOZFRDNCsC4iD2bPLv111rg9IxZC/s1563/image1%20%284%29.png&quot; border=&quot;0&quot; alt=&quot;Jackalope running against jscript9.&quot; style=&quot;max-height: 750; max-width: 600px;&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;h1 class=&quot;c2&quot; id=&quot;h.fclhv96v1gpn&quot;&gt;&lt;span class=&quot;c9&quot;&gt;Results&lt;/span&gt;&lt;/h1&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span&gt;I ran Fuzzilli for several weeks on 100 cores. This resulted in finding two vulnerabilities, &lt;/span&gt;&lt;span class=&quot;c5&quot;&gt;&lt;a class=&quot;c81&quot; href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=2157&quot;&gt;CVE-2021-26419&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;and &lt;/span&gt;&lt;span class=&quot;c5&quot;&gt;&lt;a class=&quot;c81&quot; href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=2168&quot;&gt;CVE-2021-31959&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;. Note that the bugs that were analyzed and determined not to have security impact are not counted here. Both of the vulnerabilities found were in the bytecode generator, a part of the JavaScript engine that is typically not very well tested by generation-based fuzzing approaches. Both of these bugs were found relatively early in the fuzzing process and would be findable even by fuzzing on a single machine.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c4&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span&gt;The second of the two bugs was particularly interesting because it initially manifested only as a NULL pointer dereference that happened occasionally, and it took quite a bit of effort (including tracing JavaScript interpreter execution &lt;/span&gt;&lt;span&gt;in cases where it crashed and in cases where it didn&amp;rsquo;t to see where the execution flow diverges&lt;/span&gt;&lt;span&gt;) to reach the root cause. &lt;/span&gt;&lt;span class=&quot;c5&quot;&gt;&lt;a class=&quot;c81&quot; href=&quot;https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/time-travel-debugging-overview&quot;&gt;Time travel debugging&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;was also useful here - it would be quite difficult if not impossible to analyze the sample without it. The reader is referred to the &lt;/span&gt;&lt;span class=&quot;c5&quot;&gt;&lt;a class=&quot;c81&quot; href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=2168&quot;&gt;vulnerability report&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;for further details about the issue.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c4&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;Jackalope was run on a similar setup: for several weeks on 100 cores. Interestingly, at least against jscript9, Jackalope with grammar-based mutations behaved quite similarly to Fuzzilli: it was hitting a similar level of coverage and finding similar bugs. It also found CVE-2021-26419 quickly into the fuzzing process. Of course, it&amp;rsquo;s easy to re-discover bugs once they have already been found with another tool, but neither the grammar engine nor the JavaScript grammar contain anything specifically meant for finding these bugs.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c4&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span&gt;About a week and a half into fuzzing with Jackalope, it triggered a bug I hadn&amp;#39;t seen before, &lt;/span&gt;&lt;span class=&quot;c5&quot;&gt;&lt;a class=&quot;c81&quot; href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=2188&quot;&gt;CVE-2021-34480&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;. This time, the bug was in the JIT compiler, which is another component not exercised very well with generation-based approaches. I was quite happy with this find, because it validated the feasibility of a grammar-based approach for finding JIT bugs.&lt;/span&gt;&lt;/p&gt;&lt;h1 class=&quot;c2&quot; id=&quot;h.7g4pmu1rpz1q&quot;&gt;&lt;span class=&quot;c9&quot;&gt;Limitations and improvement ideas&lt;/span&gt;&lt;/h1&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;While successful coverage-guided fuzzing of closed-source JavaScript engines is certainly possible as demonstrated above, it does have its limitations. The biggest one is inability to compile the target with additional debug checks. Most of the modern open-source JavaScript engines include additional checks that can be compiled in if needed, and enable catching certain types of bugs more easily, without requiring that the bug crashes the target process. If jscript9 source code included such checks, they are lost in the release build we fuzzed.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c4&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span&gt;Related to this, we also can&amp;rsquo;t compile the target with something like &lt;/span&gt;&lt;span class=&quot;c5&quot;&gt;&lt;a class=&quot;c81&quot; href=&quot;https://clang.llvm.org/docs/AddressSanitizer.html&quot;&gt;Address Sanitizer&lt;/a&gt;&lt;/span&gt;&lt;span&gt;. The usual workaround for this on Windows would be to enable &lt;/span&gt;&lt;span class=&quot;c5&quot;&gt;&lt;a class=&quot;c81&quot; href=&quot;https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/gflags-and-pageheap&quot;&gt;Page Heap&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;for the target. However, it does not work well here. The reason is, jscript9 uses a custom allocator for JavaScript objects. As Page Heap works by replacing the default malloc(), it simply does not apply here.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c4&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span&gt;A way to get around this would be to use instrumentation (TinyInst is already a general-purpose instrumentation library so it could be used for this in addition to code coverage) to instrument the allocator and either insert additional checks or replace it completely. However, doing this was out-of-scope for this project.&lt;/span&gt;&lt;/p&gt;&lt;h1 class=&quot;c2&quot; id=&quot;h.pmn70hy7a340&quot;&gt;&lt;span class=&quot;c9&quot;&gt;Conclusion&lt;/span&gt;&lt;/h1&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;Coverage-guided fuzzing of closed-source targets, even complex ones such as JavaScript engines is certainly possible, and there are plenty of tools and approaches available to accomplish this.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c4&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;In the context of this project, Jackalope fuzzer was extended to allow grammar-based mutation fuzzing. These extensions have potential to be useful beyond just JavaScript fuzzing and can be adapted to other targets by simply using a different input grammar. It would be interesting to see which other targets the broader community could think of that would benefit from a mutation-based approach.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c4&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span&gt;Finally, despite being targeted by security researchers for a long time now, Internet Explorer still has many exploitable bugs that can be found even without large resources. After the development on this project was complete, Microsoft announced that they will be &lt;/span&gt;&lt;span class=&quot;c5&quot;&gt;&lt;a class=&quot;c81&quot; href=&quot;https://blogs.windows.com/windowsexperience/2021/05/19/the-future-of-internet-explorer-on-windows-10-is-in-microsoft-edge/&quot;&gt;removing Internet Explorer as a separate browser&lt;/a&gt;&lt;/span&gt;&lt;span&gt;. This is a good first step, but with Internet Explorer (or Internet Explorer engine) integrated into various &lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;other&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;products (most notably, Microsoft Office, as also exploited by in-the-wild attackers), I wonder how long it will truly take before attackers stop abusing it. &lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c4&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c4&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='https://googleprojectzero.blogspot.com/feeds/5444284102989534433/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='https://googleprojectzero.blogspot.com/2021/09/fuzzing-closed-source-javascript.html#comment-form' title='0 Comments'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/4838136820032157985/posts/default/5444284102989534433'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/4838136820032157985/posts/default/5444284102989534433'/><link rel='alternate' type='text/html' href='https://googleprojectzero.blogspot.com/2021/09/fuzzing-closed-source-javascript.html' title='Fuzzing Closed-Source JavaScript Engines with Coverage Feedback'/><author><name>Anonymous</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/blank.gif'/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiry3nRhxaazq03y2AKG_3VBvYocm8t5239naPV7YNNU_FWG9uUcVsOjUTDwf9JDft3dkh7Qpxr-UgRfshNt7FAtbYARvIbpbTIYWK3RS_hFhSjX-7rAy4WmN_5nsgIlktzDWNBzZEpDVJWlERlFwc0hcOgZl8rg_-akQ6w9918lhrM_oFisW7F_43P/s72-c/image2%20%283%29.png" height="72" width="72"/><thr:total>0</thr:total></entry>