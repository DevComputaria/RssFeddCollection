<?xml version='1.0' encoding='UTF-8'?><?xml-stylesheet href="http://www.blogger.com/styles/atom.css" type="text/css"?><entry xmlns='http://www.w3.org/2005/Atom' xmlns:blogger='http://schemas.google.com/blogger/2008' xmlns:georss='http://www.georss.org/georss' xmlns:gd='http://schemas.google.com/g/2005' xmlns:thr='http://purl.org/syndication/thread/1.0'><id>tag:blogger.com,1999:blog-4838136820032157985.post-7843265571440320887</id><published>2021-01-21T11:33:00.002-08:00</published><updated>2022-08-24T11:18:08.364-07:00</updated><title type='text'>Windows Exploitation Tricks: Trapping Virtual Memory Access</title><content type='html'>&lt;style type=&quot;text/css&quot;&gt;.lst-kix_rewf8lfzymzq-6&gt;li{counter-increment:lst-ctn-kix_rewf8lfzymzq-6}ol.lst-kix_rewf8lfzymzq-4.start{counter-reset:lst-ctn-kix_rewf8lfzymzq-4 0}.lst-kix_rewf8lfzymzq-0&gt;li{counter-increment:lst-ctn-kix_rewf8lfzymzq-0}.lst-kix_rewf8lfzymzq-7&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_rewf8lfzymzq-7,lower-latin) &quot;. &quot;}.lst-kix_rewf8lfzymzq-8&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_rewf8lfzymzq-8,lower-roman) &quot;. &quot;}.lst-kix_fmvhww8n3gvt-6&gt;li:before{content:&quot;\0025cf  &quot;}.lst-kix_fmvhww8n3gvt-5&gt;li:before{content:&quot;\0025a0  &quot;}.lst-kix_fmvhww8n3gvt-7&gt;li:before{content:&quot;\0025cb  &quot;}ol.lst-kix_rewf8lfzymzq-1.start{counter-reset:lst-ctn-kix_rewf8lfzymzq-1 0}.lst-kix_fmvhww8n3gvt-4&gt;li:before{content:&quot;\0025cb  &quot;}.lst-kix_fmvhww8n3gvt-8&gt;li:before{content:&quot;\0025a0  &quot;}ol.lst-kix_rewf8lfzymzq-8.start{counter-reset:lst-ctn-kix_rewf8lfzymzq-8 0}.lst-kix_2duiues326zm-1&gt;li:before{content:&quot;\0025cb  &quot;}.lst-kix_2duiues326zm-0&gt;li:before{content:&quot;\0025cf  &quot;}ol.lst-kix_rewf8lfzymzq-4{list-style-type:none}ol.lst-kix_rewf8lfzymzq-0.start{counter-reset:lst-ctn-kix_rewf8lfzymzq-0 0}ol.lst-kix_rewf8lfzymzq-5{list-style-type:none}ol.lst-kix_rewf8lfzymzq-2{list-style-type:none}ol.lst-kix_rewf8lfzymzq-3{list-style-type:none}ol.lst-kix_rewf8lfzymzq-8{list-style-type:none}ol.lst-kix_rewf8lfzymzq-6{list-style-type:none}.lst-kix_rewf8lfzymzq-7&gt;li{counter-increment:lst-ctn-kix_rewf8lfzymzq-7}ol.lst-kix_rewf8lfzymzq-7{list-style-type:none}ol.lst-kix_rewf8lfzymzq-0{list-style-type:none}ol.lst-kix_rewf8lfzymzq-1{list-style-type:none}.lst-kix_rewf8lfzymzq-1&gt;li{counter-increment:lst-ctn-kix_rewf8lfzymzq-1}.lst-kix_rewf8lfzymzq-4&gt;li{counter-increment:lst-ctn-kix_rewf8lfzymzq-4}ul.lst-kix_fmvhww8n3gvt-8{list-style-type:none}ul.lst-kix_fmvhww8n3gvt-7{list-style-type:none}ul.lst-kix_fmvhww8n3gvt-6{list-style-type:none}ul.lst-kix_fmvhww8n3gvt-5{list-style-type:none}ul.lst-kix_fmvhww8n3gvt-4{list-style-type:none}ul.lst-kix_fmvhww8n3gvt-3{list-style-type:none}ul.lst-kix_fmvhww8n3gvt-2{list-style-type:none}ul.lst-kix_fmvhww8n3gvt-1{list-style-type:none}ol.lst-kix_rewf8lfzymzq-7.start{counter-reset:lst-ctn-kix_rewf8lfzymzq-7 0}ul.lst-kix_fmvhww8n3gvt-0{list-style-type:none}.lst-kix_rewf8lfzymzq-3&gt;li{counter-increment:lst-ctn-kix_rewf8lfzymzq-3}ul.lst-kix_2duiues326zm-8{list-style-type:none}ul.lst-kix_2duiues326zm-7{list-style-type:none}ul.lst-kix_2duiues326zm-6{list-style-type:none}ul.lst-kix_2duiues326zm-5{list-style-type:none}ul.lst-kix_2duiues326zm-4{list-style-type:none}ul.lst-kix_2duiues326zm-3{list-style-type:none}ol.lst-kix_rewf8lfzymzq-6.start{counter-reset:lst-ctn-kix_rewf8lfzymzq-6 0}ul.lst-kix_2duiues326zm-2{list-style-type:none}ul.lst-kix_2duiues326zm-1{list-style-type:none}ul.lst-kix_2duiues326zm-0{list-style-type:none}ol.lst-kix_rewf8lfzymzq-3.start{counter-reset:lst-ctn-kix_rewf8lfzymzq-3 0}.lst-kix_2duiues326zm-2&gt;li:before{content:&quot;\0025a0  &quot;}.lst-kix_2duiues326zm-3&gt;li:before{content:&quot;\0025cf  &quot;}.lst-kix_fmvhww8n3gvt-0&gt;li:before{content:&quot;\0025cf  &quot;}.lst-kix_2duiues326zm-4&gt;li:before{content:&quot;\0025cb  &quot;}.lst-kix_2duiues326zm-5&gt;li:before{content:&quot;\0025a0  &quot;}.lst-kix_fmvhww8n3gvt-2&gt;li:before{content:&quot;\0025a0  &quot;}.lst-kix_rewf8lfzymzq-2&gt;li{counter-increment:lst-ctn-kix_rewf8lfzymzq-2}.lst-kix_fmvhww8n3gvt-1&gt;li:before{content:&quot;\0025cb  &quot;}.lst-kix_fmvhww8n3gvt-3&gt;li:before{content:&quot;\0025cf  &quot;}.lst-kix_rewf8lfzymzq-1&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_rewf8lfzymzq-1,lower-latin) &quot;) &quot;}ol.lst-kix_rewf8lfzymzq-5.start{counter-reset:lst-ctn-kix_rewf8lfzymzq-5 0}li.li-bullet-0:before{margin-left:-18pt;white-space:nowrap;display:inline-block;min-width:18pt}.lst-kix_2duiues326zm-6&gt;li:before{content:&quot;\0025cf  &quot;}.lst-kix_rewf8lfzymzq-0&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_rewf8lfzymzq-0,decimal) &quot;) &quot;}.lst-kix_rewf8lfzymzq-5&gt;li:before{content:&quot;(&quot; counter(lst-ctn-kix_rewf8lfzymzq-5,lower-roman) &quot;) &quot;}.lst-kix_2duiues326zm-7&gt;li:before{content:&quot;\0025cb  &quot;}.lst-kix_rewf8lfzymzq-8&gt;li{counter-increment:lst-ctn-kix_rewf8lfzymzq-8}.lst-kix_rewf8lfzymzq-5&gt;li{counter-increment:lst-ctn-kix_rewf8lfzymzq-5}.lst-kix_2duiues326zm-8&gt;li:before{content:&quot;\0025a0  &quot;}.lst-kix_rewf8lfzymzq-6&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_rewf8lfzymzq-6,decimal) &quot;. &quot;}.lst-kix_rewf8lfzymzq-2&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_rewf8lfzymzq-2,lower-roman) &quot;) &quot;}.lst-kix_rewf8lfzymzq-3&gt;li:before{content:&quot;(&quot; counter(lst-ctn-kix_rewf8lfzymzq-3,decimal) &quot;) &quot;}ol.lst-kix_rewf8lfzymzq-2.start{counter-reset:lst-ctn-kix_rewf8lfzymzq-2 0}.lst-kix_rewf8lfzymzq-4&gt;li:before{content:&quot;(&quot; counter(lst-ctn-kix_rewf8lfzymzq-4,lower-latin) &quot;) &quot;}ol{margin:0;padding:0}table td,table th{padding:0}.c23{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:210pt;border-top-color:#000000;border-bottom-style:solid}.c34{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:123.8pt;border-top-color:#000000;border-bottom-style:solid}.c10{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:468pt;border-top-color:#000000;border-bottom-style:solid}.c2{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:135.8pt;border-top-color:#000000;border-bottom-style:solid}.c37{-webkit-text-decoration-skip:none;color:#000000;font-weight:400;text-decoration:line-through;vertical-align:baseline;text-decoration-skip-ink:none;font-size:11pt;font-family:&quot;Arial&quot;;font-style:normal}.c44{padding-top:18pt;padding-bottom:6pt;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c0{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:&quot;Arial&quot;;font-style:normal}.c4{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:&quot;Courier New&quot;;font-style:normal}.c47{padding-top:16pt;padding-bottom:4pt;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c31{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:16pt;font-family:&quot;Arial&quot;;font-style:normal}.c3{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:&quot;Courier New&quot;;font-style:normal}.c36{color:#434343;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:14pt;font-family:&quot;Arial&quot;;font-style:normal}.c26{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:&quot;Arial&quot;;font-style:normal}.c39{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-family:&quot;Arial&quot;;font-style:normal}.c6{padding-top:0pt;padding-bottom:0pt;line-height:1.500000000000001;orphans:2;widows:2;text-align:left}.c11{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:&quot;Arial&quot;}.c5{padding-top:0pt;padding-bottom:0pt;line-height:1.5;orphans:2;widows:2;text-align:left}.c16{font-size:10pt;font-family:&quot;Courier New&quot;;color:#000080;font-weight:400}.c8{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:left}.c14{font-size:10pt;font-family:&quot;Courier New&quot;;color:#0000ff;font-weight:400}.c15{border-spacing:0;border-collapse:collapse;margin-right:auto}.c27{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline}.c45{text-decoration:none;vertical-align:baseline;font-size:11pt;font-style:normal}.c12{font-size:10pt;font-family:&quot;Courier New&quot;;color:#800080;font-weight:400}.c9{font-family:&quot;Courier New&quot;;color:#3c78d8;font-weight:400}.c32{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c38{-webkit-text-decoration-skip:none;text-decoration:underline;text-decoration-skip-ink:none}.c29{border:1px solid black;margin:5px}.c17{font-weight:400;font-family:&quot;Courier New&quot;}.c18{font-size:10pt;color:#a82d00}.c22{font-size:10pt;color:#696969}.c21{font-weight:700;font-family:&quot;Courier New&quot;}.c20{color:inherit;text-decoration:inherit}.c19{padding:0;margin:0}.c33{margin-left:36pt;padding-left:0pt}.c41{color:#a31515}.c28{background-color:#e69138}.c24{background-color:#f6b26b}.c35{color:#8b0000}.c1{font-style:italic}.c7{height:11pt}.c43{color:#8a2be2}.c46{color:#3c78d8}.c13{height:0pt}.c42{background-color:#d9d9d9}.c40{background-color:#6aa84f}.c30{color:#6aa84f}.c25{font-size:10pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:&quot;Arial&quot;}p{margin:0;color:#000000;font-size:11pt;font-family:&quot;Arial&quot;}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}&lt;/style&gt;&lt;/head&gt;&lt;body class=&quot;c32&quot;&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c0&quot;&gt;Posted by James Forshaw, Project Zero&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c0&quot;&gt;This blog is a continuation of my series of Windows exploitation tricks. This one describes an exploitation trick I&amp;rsquo;ve been trying to develop for years, succeeding (mostly, more on that later) on the latest versions of Windows 10. It&amp;rsquo;s a trick to trap access to virtual memory, get feedback when it occurs and delay access indefinitely. The blog will go into some of the background for why this technique is useful, an overview of the research I did to find the trick as well as an overview of the types of vulnerabilities it can be used with.&lt;/span&gt;&lt;/p&gt;&lt;h2 class=&quot;c44&quot; id=&quot;h.uqhfhcghbqm4&quot;&gt;&lt;span class=&quot;c31&quot;&gt;Background&lt;/span&gt;&lt;/h2&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;When would you need such an exploitation trick? A good example of the types of security vulnerabilities which can benefit can be found in the seminal &lt;/span&gt;&lt;span class=&quot;c27&quot;&gt;&lt;a class=&quot;c201&quot; href=&quot;https://storage.googleapis.com/pub-tools-public-publication-data/pdf/42189.pdf&quot;&gt;Bochspwn research&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;by Mateusz Jurczyk and Gynvael Coldwind. The research showed a way of automating the discovery of memory double-fetches in the Windows kernel.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c0&quot;&gt;If you&amp;rsquo;ve not read the paper, a double-fetch is a type of Time-of-Check Time-of-Use (TOCTOU) vulnerability where code reads a value from memory, such as a buffer length, verifies that value is within bounds and then rereads the value from memory before use. By swapping the value in memory between the first and second fetches the verification is bypassed which can lead to security issues such as privilege escalation or information disclosure. The following is a simple example of a double fetch taken from the original paper.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;a id=&quot;t.f96b8fca46080573d1ca2eedbb94fac318e4cab3&quot;&gt;&lt;/a&gt;&lt;a id=&quot;t.0&quot;&gt;&lt;/a&gt;&lt;table class=&quot;c15&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;c13&quot;&gt;&lt;td class=&quot;c10&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c9&quot;&gt;DWORD&lt;/span&gt;&lt;span class=&quot;c21 c46&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;c17&quot;&gt;&amp;nbsp;lpInputPtr&lt;/span&gt;&lt;span class=&quot;c21&quot;&gt;&amp;nbsp;=&lt;/span&gt;&lt;span class=&quot;c17&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c17 c30&quot;&gt;// &lt;/span&gt;&lt;span class=&quot;c17 c30&quot;&gt;controlled user-mode address&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c9&quot;&gt;UCHAR&lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;&amp;nbsp; LocalBuffer[256];&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c4&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c17&quot;&gt;if &lt;/span&gt;&lt;span class=&quot;c21&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;c21 c24&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;c17 c24&quot;&gt;lpInputPtr&lt;/span&gt;&lt;span class=&quot;c17&quot;&gt;&amp;nbsp;&amp;gt; &lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;c21&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;c17&quot;&gt;LocalBuffer&lt;/span&gt;&lt;span class=&quot;c21&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;&amp;nbsp;{ &amp;#9312;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c17&quot;&gt;&amp;nbsp; &lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;&amp;nbsp;STATUS_INVALID_PARAMETER;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c4&quot;&gt;}&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c17&quot;&gt;RtlCopyMemory&lt;/span&gt;&lt;span class=&quot;c21&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;c17&quot;&gt;LocalBuffer, lpInputPtr, &lt;/span&gt;&lt;span class=&quot;c21 c24&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;c17 c24&quot;&gt;lpInputPtr&lt;/span&gt;&lt;span class=&quot;c21&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;;&amp;#9313;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;This code copies a buffer from a controlled user mode address into a fixed sized stack buffer. The buffer starts with a &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;DWORD &lt;/span&gt;&lt;span&gt;size value which indicates the total size of the buffer. Memory corruption can occur if the size value pointed to by &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;lpInputBuffer&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;changes between the first read of the size value to compare against the buffer size &amp;#9312; and the second read of the size when copying into the buffer &amp;#9313;. For example, if the first time the value is read it&amp;rsquo;s 100 and the second it&amp;rsquo;s 400 then the code will pass the size check as 100 is less than 256 but will then copy 400 bytes into that buffer corrupting the stack.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c0&quot;&gt;Once a vulnerability such as this example was discovered Mateusz and Gynvael needed to exploit it. How they achieved exploitation is detailed in section 4 of the paper. The exploit techniques that were identified were all probabilistic. Exploitation typically required two threads racing each other, with one reading and one writing. The probabilistic nature of success is due to the probability that in between the first read from a memory location and the second read the writing thread sets a new value which exploits the vulnerability.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c0&quot;&gt;To widen the TOCTOU window many of the techniques described abuse the behavior of virtual memory on Windows. A process on Windows can typically access a large virtual memory region up to 8TiB size. This size is likely to be significantly larger than the physical memory in the system, especially considering the limit is per-process, not per-system. Therefore to maintain the illusion of such a large memory address space the kernel uses on-demand memory paging.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c0&quot;&gt;When memory is allocated in the process the CPU&amp;rsquo;s page tables are set up to indicate the presence of the memory region but are marked as invalid. At this point the virtual memory region has been allocated but there is no physical memory backing it. When the process tries to access that memory region the CPU will generate an exception, generally referred to as a page-fault, which is handled by the kernel. &lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c0&quot;&gt;The kernel can look up the memory address which was accessed to cause the page-fault and try and fix the address. How the page-fault is fixed depends on the type of memory access. A simple example is if the memory was allocated but not yet used the kernel will get a physical memory page, initialize it to zeros then adjust the page tables to map that new physical memory page at the faulting address. Once the page-fault has been fixed the faulting thread can be restarted at the instruction which accessed the memory and the memory access should now succeed as if it was always present.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c0&quot;&gt;A more complex scenario is if the page is part of a memory mapped file. In this case the kernel will need to request that the page&amp;rsquo;s data is read back from disk before it can satisfy the page-fault. This can take quite a long time, at least for spinning rust disks, so it might require the faulting thread to be suspended while it waits for the page to be read. Once the page has been read the memory can be fixed up, the original thread can be resumed and the thread restarted at the faulting instruction.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;/p&gt;
  
&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEguHIRfKCvq_K5S5w5-xaLcOS5TyeCoO3ERoRIFDUEWb5lh98mijADeGnRHfs6hy4Nto06n9Lyb1u41F7KfVMKWQWGmkeCdHJRGl4c_kvt9ricS0NMSETy7De1IPEqLV7wb6pte6KK4PRjFanlQBM6jsmbmakm5lvxSldvMqeieEPvD4XFnMadrbVUB/s602/image6%281%29.png&quot; style=&quot;display: block; padding: 1em 0; text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEguHIRfKCvq_K5S5w5-xaLcOS5TyeCoO3ERoRIFDUEWb5lh98mijADeGnRHfs6hy4Nto06n9Lyb1u41F7KfVMKWQWGmkeCdHJRGl4c_kvt9ricS0NMSETy7De1IPEqLV7wb6pte6KK4PRjFanlQBM6jsmbmakm5lvxSldvMqeieEPvD4XFnMadrbVUB/s602/image6%281%29.png&quot; border=&quot;0&quot; alt=&quot;Overview diagram of page fault causing access to the file system. A user application is shown reading memory from a file mapped into memory. When the memory read occurs a page fault is generated in the kernel. As the memory is part of a file mapping this calls into the IO Manager which then requests the file data from the file system. The read data is then returned back through the kernel to satisfy the page fault and the user application can complete the memory read.&quot; style=&quot;max-height: 750; max-width: 600px;&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c0&quot;&gt;The end result is it can take a significant amount of time, relative to a CPU&amp;rsquo;s native speed that is, to handle a page-fault. However, abusing these virtual memory behaviors only widens the TOCTOU window, it didn&amp;rsquo;t allow for precise timing to swap values in memory. The result is the exploitation techniques still came with limitations. For example, it was very slow if not impossible in some cases to exploit on a machine with a single CPU core as it relies on having concurrent threads reading and writing. &lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c0&quot;&gt;An ideal exploit primitive would be one where the exploitation window can be made arbitrarily large so that it becomes trivial to win the race. Taking previous experience and knowledge of existing bug classes my ideal primitive would be one which meets a set of criteria:&lt;/span&gt;&lt;/p&gt;&lt;ul style=&#39;padding: 0;&#39; class=&quot;c19 lst-kix_fmvhww8n3gvt-0 start&quot;&gt;&lt;li style=&#39;margin-left: 46pt;&#39; class=&quot;c5 c33 li-bullet-0&quot;&gt;&lt;span class=&quot;c0&quot;&gt;Works on a default installation of Windows 10 20H2.&lt;/span&gt;&lt;/li&gt;&lt;li style=&#39;margin-left: 46pt;&#39; class=&quot;c5 c33 li-bullet-0&quot;&gt;&lt;span class=&quot;c0&quot;&gt;Gives a clear signal when memory is read or written.&lt;/span&gt;&lt;/li&gt;&lt;li style=&#39;margin-left: 46pt;&#39; class=&quot;c5 c33 li-bullet-0&quot;&gt;&lt;span class=&quot;c0&quot;&gt;Works when memory is accessed from both user and kernel mode.&lt;/span&gt;&lt;/li&gt;&lt;li style=&#39;margin-left: 46pt;&#39; class=&quot;c5 c33 li-bullet-0&quot;&gt;&lt;span class=&quot;c0&quot;&gt;Allows for delaying memory access indefinitely.&lt;/span&gt;&lt;/li&gt;&lt;li style=&#39;margin-left: 46pt;&#39; class=&quot;c5 c33 li-bullet-0&quot;&gt;&lt;span class=&quot;c0&quot;&gt;The data in the memory accessed is arbitrary.&lt;/span&gt;&lt;/li&gt;&lt;li style=&#39;margin-left: 46pt;&#39; class=&quot;c5 c33 li-bullet-0&quot;&gt;&lt;span class=&quot;c0&quot;&gt;The primitive can be set up from a range of privilege levels.&lt;/span&gt;&lt;/li&gt;&lt;li style=&#39;margin-left: 46pt;&#39; class=&quot;c5 c33 li-bullet-0&quot;&gt;&lt;span class=&quot;c0&quot;&gt;Can trap multiple times during the same exploit.&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c0&quot;&gt;While meeting all these criteria would be ideal, there&amp;rsquo;s no guarantee we&amp;rsquo;ll meet all or any of them. If we only meet some then the range of exploitation vulnerabilities might be limited. Let&amp;rsquo;s start with a quick overview of the existing work which might give us an idea of how to proceed to find a primitive.&lt;/span&gt;&lt;/p&gt;&lt;h2 class=&quot;c44&quot; id=&quot;h.f1loo4w1iipo&quot;&gt;&lt;span class=&quot;c31&quot;&gt;Existing Work&lt;/span&gt;&lt;/h2&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;Having spoken to Mateusz and made an effort to look for any subsequent work there seems to be little novel work over and above the original Bochspwn paper on the exploitation of these types of TOCTOU issues. At least this is true for exploitation on Windows, however, novel techniques have been developed on other platforms, &lt;/span&gt;&lt;span class=&quot;c27&quot;&gt;&lt;a class=&quot;c201&quot; href=&quot;https://static.sched.com/hosted_files/lsseu2019/04/LSSEU2019%20-%20Exploiting%20race%20conditions%20on%20Linux.pdf&quot;&gt;specifically Linux&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;. Both of these techniques rely on the behavior of virtual memory I previously described.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;The first technique in Linux makes use of &lt;/span&gt;&lt;span class=&quot;c27&quot;&gt;&lt;a class=&quot;c201&quot; href=&quot;https://man7.org/linux/man-pages/man2/userfaultfd.2.html&quot;&gt;Userfault File Descriptor (userfaultfd)&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;to get notifications when page-faults occur in a process. With &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;userfaultfd &lt;/span&gt;&lt;span&gt;enabled a secondary thread in the process can read a notification and handle the page-fault in user mode. Handling the fault could be mapping memory at the appropriate location or changing page protection. The key is the faulting thread is suspended until the page-fault is handled by another thread. Therefore if a kernel function accessed the memory the request will be trapped until it&amp;#39;s completed. This allows for a primitive where the memory access can be delayed indefinitely as well as having a timing signal for the access. Using &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;userfaultfd&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;also allows the fault to be distinguished between read and write faults as the memory page can be write-protected &lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;Using &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;userfaultdd &lt;/span&gt;&lt;span&gt;works for in-process access such as from the kernel, but is not really useful if the code accessing the memory is in another process.&lt;/span&gt;&lt;span&gt;&amp;nbsp;To solve that problem you can use the &lt;/span&gt;&lt;span class=&quot;c27&quot;&gt;&lt;a class=&quot;c201&quot; href=&quot;https://www.kernel.org/doc/html/latest/filesystems/fuse.html&quot;&gt;FUSE file system&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;as Jann Horn demonstrated in a previous Project Zero &lt;/span&gt;&lt;span class=&quot;c27&quot;&gt;&lt;a class=&quot;c201&quot; href=&quot;https://googleprojectzero.blogspot.com/2016/06/exploiting-recursion-in-linux-kernel_20.html&quot;&gt;blog post&lt;/a&gt;&lt;/span&gt;&lt;span&gt;. A FUSE file system is implemented entirely in user mode, but any requests for the file go through the Linux kernel&amp;rsquo;s Virtual File System APIs. As a file is accessed as if it was implemented by an in-kernel file system it&amp;rsquo;s possible to map that file into memory using &lt;/span&gt;&lt;span class=&quot;c27&quot;&gt;&lt;a class=&quot;c201&quot; href=&quot;https://man7.org/linux/man-pages/man2/mmap.2.html&quot;&gt;mmap&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;. When a page-fault occurs on a FUSE backed memory region a request will be made to the user-mode file system daemon which can delay the read or write request indefinitely. &lt;/span&gt;&lt;/p&gt;&lt;h2 class=&quot;c44&quot; id=&quot;h.8obi7645vcqz&quot;&gt;&lt;span class=&quot;c31&quot;&gt;Remote File Systems&lt;/span&gt;&lt;/h2&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;As far as I can tell there&amp;rsquo;s nothing equivalent to Linux&amp;rsquo;s &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;userfaultd&lt;/span&gt;&lt;span&gt;&amp;nbsp;on Windows. One feature which caught my eye was &lt;/span&gt;&lt;span class=&quot;c27&quot;&gt;&lt;a class=&quot;c201&quot; href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-getwritewatch&quot;&gt;memory write watches&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;. But those seem to just allow an application to query if memory had been written to since the last time it was checked and doesn&amp;rsquo;t allow memory writes to be trapped.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;If we can&amp;rsquo;t just trap page-faults to virtual memory what about mapping a file on a user-mode filesystem like FUSE? Unfortunately there is no built-in FUSE driver in Windows 10 (yet?), but that doesn&amp;rsquo;t mean there&amp;rsquo;s no mechanism to implement a file system in user-mode. There are some efforts to make a real FUSE on Windows, such as the &lt;/span&gt;&lt;span class=&quot;c27&quot;&gt;&lt;a class=&quot;c201&quot; href=&quot;http://www.secfs.net/winfsp/&quot;&gt;WinFsp project&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;, but I&amp;rsquo;d expect the chances of them being installed on a real system to be vanishingly small.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;The first thought I had was to try to exploit &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;Multiple UNC Provider (MUP)&lt;/span&gt;&lt;span&gt;&amp;nbsp;clients. When you access a file via a UNC path, e.g. &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;\\server\share\file.bin, &lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;this will be handled by a MUP driver in the kernel, which will pass it to one of the registered client drivers. As far as the kernel is concerned the opened file is a regular file (with some caveats) which generally means the file can be mapped into memory. However, any requests for the contents of that file will not be handled directly, but instead handled by a server over a network protocol.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;Ideally we should be able to implement our own server, handle the read or write requests to a file mapping which will allow us to detect or delay the request so that we can exploit any TOCTOU. &lt;/span&gt;&lt;span&gt;The following table contains only Microsoft MUP drivers that I identified. The table contains what versions of Windows 10 the driver is supported on and whether it&amp;rsquo;s something enabled by default.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;a id=&quot;t.311f22f71e251be4fa8b2991f349fb7079737414&quot;&gt;&lt;/a&gt;&lt;a id=&quot;t.1&quot;&gt;&lt;/a&gt;&lt;table class=&quot;c15&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;c13&quot;&gt;&lt;td class=&quot;c2 c42&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c26&quot;&gt;Remote File System&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c34 c42&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c26&quot;&gt;Supported Version&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c23 c42&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c26&quot;&gt;Default?&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;c13&quot;&gt;&lt;td class=&quot;c2&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c27&quot;&gt;&lt;a class=&quot;c201&quot; href=&quot;https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-smb2/5606ad47-5ee0-437a-817e-70c366052962&quot;&gt;SMB&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c34&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c0&quot;&gt;Everything&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c23&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c0&quot;&gt;Yes (SMBv1 might be disabled)&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;c13&quot;&gt;&lt;td class=&quot;c2&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c27&quot;&gt;&lt;a class=&quot;c201&quot; href=&quot;https://tools.ietf.org/html/rfc4918&quot;&gt;WebDAV&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c34&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c0&quot;&gt;Everything&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c23&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c0&quot;&gt;Yes (except Server SKUs)&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;c13&quot;&gt;&lt;td class=&quot;c2&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c27&quot;&gt;&lt;a class=&quot;c201&quot; href=&quot;https://docs.microsoft.com/en-us/windows-server/storage/nfs/nfs-overview&quot;&gt;NFS&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c34&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c0&quot;&gt;Everything&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c23&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c0&quot;&gt;No&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;c13&quot;&gt;&lt;td class=&quot;c2&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c27&quot;&gt;&lt;a class=&quot;c201&quot; href=&quot;https://www.tiraniddo.dev/2019/07/digging-into-wsl-p9-file-system.html&quot;&gt;P9&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c34&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c0&quot;&gt;Windows 10 1903&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c23&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c0&quot;&gt;No (needs WSL)&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;c13&quot;&gt;&lt;td class=&quot;c2&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c27&quot;&gt;&lt;a class=&quot;c201&quot; href=&quot;https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdsod/072543f9-4bd4-4dc6-ab97-9a04bf9d2c6a&quot;&gt;Remote Desktop Client&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c34&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c0&quot;&gt;Everything&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c23&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c0&quot;&gt;Yes&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c0&quot;&gt;While MUP was designed for remote file systems there&amp;rsquo;s no requirement that the file system server is actually remote. SMB, WebDAV and NFS are IP based protocols and can be redirected to localhost. P9 uses a local Unix Socket which can&amp;rsquo;t be remoted anyway. The terminal services client sends file access requests back to the client system over the RDP protocol. For all these protocols we can implement the server with varying degrees of effort and see if we can detect and delay reads and writes to the file mapping.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c0&quot;&gt;I decided to focus only on two, SMB and WebDAV. These were the only two which are enabled by default and are trivially usable. While the Remote Desktop Client is in theory installed by default the RDP server is not normally enabled by default. Also setting up the RDP session is complex and might require valid authentication credentials therefore I decided against it.&lt;/span&gt;&lt;/p&gt;&lt;h3 class=&quot;c47&quot; id=&quot;h.b9zmr45b126&quot;&gt;&lt;span class=&quot;c36&quot;&gt;Server Message Block&lt;/span&gt;&lt;/h3&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c0&quot;&gt;SMB is almost as old as Windows itself, having been introduced in Lan Manager 1.0 back in 1987. The latest SMB version 3.1 protocol only bears a passing resemblance to that original version having shed its NetBIOS roots for a TCP/IP connection. Its lineage does mean it&amp;rsquo;s the best integrated of any of the network file systems, with the MUP APIs being designed around the needs of SMB.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;I decided to do a simple test of the behavior of mapping a file over SMB. This is fairly easy as you can access SMB on the same machine via localhost. I first created a 1GiB file on a local disk, the rationale being if SMB supports caching file data it&amp;rsquo;s unlikely to read something that large in one go. I then started &lt;/span&gt;&lt;span class=&quot;c27&quot;&gt;&lt;a class=&quot;c201&quot; href=&quot;https://www.wireshark.org/&quot;&gt;Wireshark&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;and monitored the loopback interface to capture the SMB traffic as shown below.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;/p&gt;


&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c11 c1&quot;&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhlk8VL79FRlFIOyg42wkU3mHmH8kDTcGhQhRcyRCIf9PajihQ-eT95CiY3W2abnY6nVAHl4GFW85XXFCi0EY_HFSt2zbTvlSk82zpLScHm6mOkH05e3CxK05Kzmv0UFARK0VmLUQfFtPQKySTAN405eamtuS2-nVo0xsSvdMLnyhwM-hWylgfpZas8/s957/image1%20%281%29.png&quot; style=&quot;display: block; padding: 1em 0; text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhlk8VL79FRlFIOyg42wkU3mHmH8kDTcGhQhRcyRCIf9PajihQ-eT95CiY3W2abnY6nVAHl4GFW85XXFCi0EY_HFSt2zbTvlSk82zpLScHm6mOkH05e3CxK05Kzmv0UFARK0VmLUQfFtPQKySTAN405eamtuS2-nVo0xsSvdMLnyhwM-hWylgfpZas8/s957/image1%20%281%29.png&quot; border=&quot;0&quot; alt=&quot;Overview diagram of SMB test with wireshark in place to inspect the network traffic from the SMB client to the SMB server. The diagram starts overview with a user application reading memory of a mapped file which causes a page fault. As the file is on an SMB share this calls into the SMB client which sends a request to the SMB server and from there to the file system. In between the SMB client and SMB server components the Wireshark logo indicates where we are monitoring the network traffic.&quot; style=&quot;max-height: 750; max-width: 600px;&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c0&quot;&gt;I then wrote a quick PowerShell script which will map the file into memory and then reads a few bytes from memory at a few different offsets.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;a id=&quot;t.c8c8c2cba13a8921ac57c2f036ed9a8e5123c4d1&quot;&gt;&lt;/a&gt;&lt;a id=&quot;t.2&quot;&gt;&lt;/a&gt;&lt;table class=&quot;c15&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;c13&quot;&gt;&lt;td class=&quot;c10&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p class=&quot;c6&quot;&gt;&lt;span class=&quot;c14&quot;&gt;Use-NtObject&lt;/span&gt;&lt;span class=&quot;c17 c25&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;c17 c18&quot;&gt;$f&lt;/span&gt;&lt;span class=&quot;c17 c25&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c17 c22&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;c17 c25&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c14&quot;&gt;Get-NtFile&lt;/span&gt;&lt;span class=&quot;c17 c25&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c17 c35 c25&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;c17 c35 c25 c38&quot;&gt;\\localhost\c$\root\file.bin&lt;/span&gt;&lt;span class=&quot;c17 c25 c35&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;c17 c25&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c16&quot;&gt;-Win32Path&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;) {&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c6&quot;&gt;&lt;span class=&quot;c17 c25&quot;&gt;&amp;nbsp; &amp;nbsp; &lt;/span&gt;&lt;span class=&quot;c14&quot;&gt;Use-NtObject&lt;/span&gt;&lt;span class=&quot;c17 c25&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;c17 c18&quot;&gt;$s&lt;/span&gt;&lt;span class=&quot;c17 c25&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c17 c22&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;c17 c25&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c14&quot;&gt;New-NtSection&lt;/span&gt;&lt;span class=&quot;c17 c25&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c16&quot;&gt;-File&lt;/span&gt;&lt;span class=&quot;c17 c25&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c17 c18&quot;&gt;$f&lt;/span&gt;&lt;span class=&quot;c17 c25&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c16&quot;&gt;-Protection&lt;/span&gt;&lt;span class=&quot;c17 c25&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c17 c43 c25&quot;&gt;ReadWrite&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;) {&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c6&quot;&gt;&lt;span class=&quot;c17 c25&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &lt;/span&gt;&lt;span class=&quot;c14&quot;&gt;Use-NtObject&lt;/span&gt;&lt;span class=&quot;c17 c25&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;c17 c18&quot;&gt;$m&lt;/span&gt;&lt;span class=&quot;c17 c25&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c17 c22&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;c17 c25&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c14&quot;&gt;Add-NtSection&lt;/span&gt;&lt;span class=&quot;c17 c25&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c16&quot;&gt;-Section&lt;/span&gt;&lt;span class=&quot;c17 c25&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c17 c18&quot;&gt;$s&lt;/span&gt;&lt;span class=&quot;c17 c25&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c16&quot;&gt;-Protection&lt;/span&gt;&lt;span class=&quot;c17 c25&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c17 c25 c43&quot;&gt;ReadWrite&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;) {&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c6&quot;&gt;&lt;span class=&quot;c17 c18&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; $m&lt;/span&gt;&lt;span class=&quot;c17 c22&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;c17 c25&quot;&gt;ReadBytes(&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;c17 c22&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;c17 c25&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;)&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c6&quot;&gt;&lt;span class=&quot;c17 c18&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; $m&lt;/span&gt;&lt;span class=&quot;c17 c22&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;c17 c25&quot;&gt;ReadBytes(&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;256&lt;/span&gt;&lt;span class=&quot;c17 c22&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;c17 c22&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;c17 c22&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;c17 c25&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;)&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c6&quot;&gt;&lt;span class=&quot;c17 c25&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &lt;/span&gt;&lt;span class=&quot;c17 c18&quot;&gt;$m&lt;/span&gt;&lt;span class=&quot;c17 c22&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;c17 c25&quot;&gt;ReadBytes(&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;512&lt;/span&gt;&lt;span class=&quot;c17 c22&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;c17 c22&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;c17 c22&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;c17 c25&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;)&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c6&quot;&gt;&lt;span class=&quot;c17 c18&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; $m&lt;/span&gt;&lt;span class=&quot;c17 c22&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;c17 c25&quot;&gt;ReadBytes(&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;768&lt;/span&gt;&lt;span class=&quot;c17 c22&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;c17 c22&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;c17 c22&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;c17 c25&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;)&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c6&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c6&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c6&quot;&gt;&lt;span class=&quot;c17 c25&quot;&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;This just reads 4 bytes from offset, 0, 256MiB, 512MiB and 768MiB. Going back to Wireshark I filtered the output to only SMBv2 read requests using the display filter &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;smb2.cmd == 8&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;, and the following four packets can be observed.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;a id=&quot;t.781998ecbfdfd185ba84b304b816e4ca702e5afc&quot;&gt;&lt;/a&gt;&lt;a id=&quot;t.3&quot;&gt;&lt;/a&gt;&lt;table class=&quot;c15&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;c13&quot;&gt;&lt;td class=&quot;c10&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c4&quot;&gt;Read Request Len:32768 Off:0 File: root\file.bin&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c4&quot;&gt;Read Request Len:32768 Off:268435456 File: root\file.bin&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c4&quot;&gt;Read Request Len:32768 Off:536870912 File: root\file.bin&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c17&quot;&gt;Read Request Len:32768 Off:805306368 File: root\file.bin&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;c6 c7&quot;&gt;&lt;span class=&quot;c4&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c0&quot;&gt;This corresponds with the exact memory offsets we accessed in the script although the length is always 32KiB in size, not the 4 we requested. Note, that it&amp;rsquo;s not the typical Windows memory allocation granularity of 64KiB which you might expect. In my testing I&amp;rsquo;ve never seen anything other than 32KiB requested. &lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c0&quot;&gt;All the bytes we&amp;rsquo;ve tested are aligned to the 32KiB block, what if the bytes were not aligned, for example if we accessed 4 bytes from address 512MiB minus 2? Changing the script to add the following allows us to check the behavior:&lt;/span&gt;&lt;/p&gt;&lt;a id=&quot;t.fa7dd910dbb19e5fd97872373baa2a6c49afee7e&quot;&gt;&lt;/a&gt;&lt;a id=&quot;t.4&quot;&gt;&lt;/a&gt;&lt;table class=&quot;c15&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;c13&quot;&gt;&lt;td class=&quot;c10&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p class=&quot;c6&quot;&gt;&lt;span class=&quot;c17 c18&quot;&gt;$m&lt;/span&gt;&lt;span class=&quot;c17 c22&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;c17 c25&quot;&gt;Read&lt;/span&gt;&lt;span class=&quot;c17 c25&quot;&gt;Bytes(&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;512&lt;/span&gt;&lt;span class=&quot;c17 c22&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;c17 c22&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;1024 - 2&lt;/span&gt;&lt;span class=&quot;c17 c22&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;c17 c25&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;c17 c25&quot;&gt;)&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c0&quot;&gt;In Wireshark we see the following read requests.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;a id=&quot;t.fa304928ef3c31dda5574da10e2deacc43708368&quot;&gt;&lt;/a&gt;&lt;a id=&quot;t.5&quot;&gt;&lt;/a&gt;&lt;table class=&quot;c15&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;c13&quot;&gt;&lt;td class=&quot;c10&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c17&quot;&gt;Read Request Len:32768 Off:536838144 File: root\file.bin&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c17&quot;&gt;Read Request Len:32768 Off:536870912 File: root\file.bin&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c0&quot;&gt;The accesses are still at 32KiB boundaries, however as the request straddles two blocks the kernel has fetched the preceding 32KiB of data from the file and then the following 32KiB. You might think that all makes sense, however this behavior turned out to be a fluke of testing. &lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;/p&gt;


&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEj4RRO4vym994JRlD7ioOhiirMxygVy09LQd4QO3ahW5IEpuFyCRzP7Xg-yombm1VVkUQocNDjlSXIg84IAhYs9qjdIZeue92hpCDIgXWx6LPg4LJH6LwZVFP8Ki9BZub2LF81UBqpB7wiKaoWuf9SEY3wtRy7hiZ273oyY0KTCpodJ4yaAd5knveNj/s656/image5%281%29.png&quot; style=&quot;display: block; padding: 1em 0; text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEj4RRO4vym994JRlD7ioOhiirMxygVy09LQd4QO3ahW5IEpuFyCRzP7Xg-yombm1VVkUQocNDjlSXIg84IAhYs9qjdIZeue92hpCDIgXWx6LPg4LJH6LwZVFP8Ki9BZub2LF81UBqpB7wiKaoWuf9SEY3wtRy7hiZ273oyY0KTCpodJ4yaAd5knveNj/s656/image5%281%29.png&quot; border=&quot;0&quot; alt=&quot;Overview diagram of memory read layout. In the middle is a set of boxes representing the native 4KiB pages being read. All the boxes are contained within a single larger region which is the large page size. Above the boxes are arrows which show that from the base of the 4KiB box a 32KiB read will be made into the file which can satisfy the reads from other 4KiB pages. The final box shows that the last 32KiB of the large page size will always be read as a single page regardless of where in the box the read occurs.&quot; style=&quot;max-height: 750; max-width: 600px;&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c11 c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;The diagram above shows the structure of how mapped file reads are handled. When an address is read the kernel will request 32KiB from the closest 4KiB page boundary, not the 32KiB boundary. However, there&amp;rsquo;s then a secondary structure on top based on the supported size of &lt;/span&gt;&lt;span class=&quot;c27&quot;&gt;&lt;a class=&quot;c201&quot; href=&quot;https://docs.microsoft.com/en-us/windows/win32/memory/large-page-support&quot;&gt;large pages&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;. If the read is anywhere within 32KiB of the end of a large page the read offset is always for the last 32KiB.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;For example, on my system the large page size (as queried using the &lt;/span&gt;&lt;span class=&quot;c27&quot;&gt;&lt;a class=&quot;c201&quot; href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-getlargepageminimum&quot;&gt;GetLargePageMinimum&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;API) is 2MiB. Therefore if you start at offset 512MiB, between 512 and 514 - 32KiB the kernel will read 32KiB from the offset truncated to the closest 4KiB boundary. Between 514 - 32KiB and 514MiB the read will always request offset 514 - 32KiB so that the 32KiB doesn&amp;rsquo;t cross the large page boundary.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;This allows reads at 4KiB boundaries, however the amount of data read is still 32KiB. This means that once one 4KiB page is accessed the kernel will populate the current page and 7 following pages. Is there any way to only populate a single native page? Based on a comment from Mateusz I tested returning short reads. If the SMB server returns fewer bytes than requested from the read then rather than failing it only populates the pages covered by the read. By returning these short reads we can get trap granularity down to the native page size except for the final 32KiB of a large page. If a read request is shorter than the native page size the rest of the page is zeroed.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;What about writing? Let&amp;rsquo;s change the script again to call &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;WriteBytes&lt;/span&gt;&lt;span&gt;&amp;nbsp;rather than &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;ReadBytes&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;, for example:&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;a id=&quot;t.3d062bd046e65f691bd1dc2383ef68ff5ba76daa&quot;&gt;&lt;/a&gt;&lt;a id=&quot;t.6&quot;&gt;&lt;/a&gt;&lt;table class=&quot;c15&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;c13&quot;&gt;&lt;td class=&quot;c10&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p class=&quot;c6&quot;&gt;&lt;span class=&quot;c17 c18&quot;&gt;$m&lt;/span&gt;&lt;span class=&quot;c17 c22&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;c17 c25&quot;&gt;WriteBytes(&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;256&lt;/span&gt;&lt;span class=&quot;c17 c22&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;c17 c22&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;c17 c22&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;c17 c25&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;@(0xAA, 0xBB, 0xCC, 0xDD)&lt;/span&gt;&lt;span class=&quot;c17 c25&quot;&gt;)&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c0&quot;&gt;You will see a write request to the file in Wireshark, similar to the following:&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;a id=&quot;t.6278e8d0815ac87f566ed149df8683a184989b46&quot;&gt;&lt;/a&gt;&lt;a id=&quot;t.7&quot;&gt;&lt;/a&gt;&lt;table class=&quot;c15&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;c13&quot;&gt;&lt;td class=&quot;c10&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c17&quot;&gt;Write Request Len:4096 Off:268435456 File: root\file.bin&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;However, if you dig a bit deeper you&amp;rsquo;ll notice that the write only happens once the file is closed, not in response to the WriteBytes call. &lt;/span&gt;&lt;span&gt;This makes sense, there isn&amp;rsquo;t any easy way to detect when the write happened to force the page to be flushed back to the file system. Even if there was a way flushing to a network server for every write would have a massive performance impact.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c0&quot;&gt;All is not lost however, before the memory is safe to write it must be populated with the contents from the file. Therefore if you look before the write you&amp;rsquo;ll see a corresponding read request for the 32KiB region which encompasses the write location which is synchronous with the read. You can detect a write through its corresponding read but you can&amp;rsquo;t distinguish read from a write at the protocol level.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;All this testing indicates if we have control over the server we can detect memory access to the mapped file. Can we delay the access as well? I wrote a simple SMB server in .NET 5 using the &lt;/span&gt;&lt;span class=&quot;c27&quot;&gt;&lt;a class=&quot;c201&quot; href=&quot;https://github.com/TalAloni/SMBLibrary&quot;&gt;SMBLibrary&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;by Tal Aloni. I implemented the server with a custom filesystem handler and added some code to the read path which delays for 10 seconds when the file offset is greater than 512MiB.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;a id=&quot;t.e19ea66214a46277c033fbe4e211e29447cdcd32&quot;&gt;&lt;/a&gt;&lt;a id=&quot;t.8&quot;&gt;&lt;/a&gt;&lt;table class=&quot;c15&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;c13&quot;&gt;&lt;td class=&quot;c10&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p class=&quot;c6&quot;&gt;&lt;span class=&quot;c14&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp;(Position &amp;gt;= (512 * 1024 * 1024)) {&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c6&quot;&gt;&lt;span class=&quot;c17 c25&quot;&gt;&amp;nbsp; &amp;nbsp; Console.WriteLine(&lt;/span&gt;&lt;span class=&quot;c17 c41 c25&quot;&gt;&amp;quot;====&amp;gt; Delaying at Position {0:X}&amp;quot;&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;, Position);&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c6&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&amp;nbsp; &amp;nbsp; Thread.Sleep(10000);&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c6&quot;&gt;&lt;span class=&quot;c17 c25&quot;&gt;&amp;nbsp; &amp;nbsp; Console.WriteLine(&lt;/span&gt;&lt;span class=&quot;c17 c25 c41&quot;&gt;&amp;quot;====&amp;gt; Continuing.&amp;quot;&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;);&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c6&quot;&gt;&lt;span class=&quot;c17 c25&quot;&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;The data returned by the read operation can be arbitrary, you just need to fill in the appropriate byte buffers in the read. To test the access times I wrapped the memory read requests inside a &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;Measure-Command&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;call to time the memory access.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;a id=&quot;t.53f9db697677b11db6ff0543fe5a0c850ad2fc52&quot;&gt;&lt;/a&gt;&lt;a id=&quot;t.9&quot;&gt;&lt;/a&gt;&lt;table class=&quot;c15&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;c13&quot;&gt;&lt;td class=&quot;c10&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p class=&quot;c6&quot;&gt;&lt;span class=&quot;c14&quot;&gt;Measure-Command&lt;/span&gt;&lt;span class=&quot;c17 c25&quot;&gt;&amp;nbsp;{ &lt;/span&gt;&lt;span class=&quot;c17 c18&quot;&gt;$m&lt;/span&gt;&lt;span class=&quot;c17 c22&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;c17 c25&quot;&gt;ReadBytes(&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;512&lt;/span&gt;&lt;span class=&quot;c17 c22&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;c17 c22&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;1024 - 4&lt;/span&gt;&lt;span class=&quot;c17 c22&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;c17 c25&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;) }&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c6&quot;&gt;&lt;span class=&quot;c14&quot;&gt;Measure-Command&lt;/span&gt;&lt;span class=&quot;c17 c25&quot;&gt;&amp;nbsp;{ &lt;/span&gt;&lt;span class=&quot;c17 c18&quot;&gt;$m&lt;/span&gt;&lt;span class=&quot;c17 c22&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;c17 c25&quot;&gt;ReadBytes(&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;512&lt;/span&gt;&lt;span class=&quot;c17 c22&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;c17 c22&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;1024 - 4&lt;/span&gt;&lt;span class=&quot;c17 c22&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;c17 c25&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;) }&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c6&quot;&gt;&lt;span class=&quot;c14&quot;&gt;Measure-Command&lt;/span&gt;&lt;span class=&quot;c17 c25&quot;&gt;&amp;nbsp;{ &lt;/span&gt;&lt;span class=&quot;c17 c18&quot;&gt;$m&lt;/span&gt;&lt;span class=&quot;c17 c22&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;c17 c25&quot;&gt;ReadBytes(&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;512&lt;/span&gt;&lt;span class=&quot;c17 c22&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;c17 c22&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;c17 c22&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;c17 c25&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;) }&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c6&quot;&gt;&lt;span class=&quot;c14&quot;&gt;Measure-Command&lt;/span&gt;&lt;span class=&quot;c17 c25&quot;&gt;&amp;nbsp;{ &lt;/span&gt;&lt;span class=&quot;c17 c18&quot;&gt;$m&lt;/span&gt;&lt;span class=&quot;c17 c22&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;c17 c25&quot;&gt;ReadBytes(&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;512&lt;/span&gt;&lt;span class=&quot;c17 c22&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;c17 c22&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;c17 c22&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;c17 c25&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;) }&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c0&quot;&gt;To compare the access time a read request is made to a location 4 bytes below the 512MiB boundary and then at the 512MiB boundary. By making two requests we should be able to see if the results differ per-read. The results were as follows:&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;a id=&quot;t.1b10c488dac72e26bdb507ea70f012f42fb416be&quot;&gt;&lt;/a&gt;&lt;a id=&quot;t.10&quot;&gt;&lt;/a&gt;&lt;table class=&quot;c15&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;c13&quot;&gt;&lt;td class=&quot;c10&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c4&quot;&gt;# Below 512MiB (Request 1)&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c4&quot;&gt;Days &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;: 0&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c4&quot;&gt;Hours &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; : 0&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c4&quot;&gt;Minutes &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; : 0&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c4 c28&quot;&gt;Seconds &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; : 1&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c4 c28&quot;&gt;Milliseconds &amp;nbsp; &amp;nbsp; &amp;nbsp;: 25&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c4&quot;&gt;...&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c8 c7&quot;&gt;&lt;span class=&quot;c4&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c4&quot;&gt;# Below 512MiB (Request 2)&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c4&quot;&gt;Days &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;: 0&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c4&quot;&gt;Hours &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; : 0&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c4&quot;&gt;Minutes &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; : 0&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c4 c28&quot;&gt;Seconds &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; : 0&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c4 c28&quot;&gt;Milliseconds &amp;nbsp; &amp;nbsp; &amp;nbsp;: 1&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c4&quot;&gt;...&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c8 c7&quot;&gt;&lt;span class=&quot;c4&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c8 c7&quot;&gt;&lt;span class=&quot;c4&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c4&quot;&gt;# Above 512MiB (Request 1)&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c4&quot;&gt;Days &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;: 0&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c4&quot;&gt;Hours &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; : 0&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c4&quot;&gt;Minutes &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; : 0&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c4 c40&quot;&gt;Seconds &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; : 10&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c4 c40&quot;&gt;Milliseconds &amp;nbsp; &amp;nbsp; &amp;nbsp;: 358&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c4&quot;&gt;...&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c8 c7&quot;&gt;&lt;span class=&quot;c4&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c4&quot;&gt;# Above 512MiB (Request 2)&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c4&quot;&gt;Days &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;: 0&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c4&quot;&gt;Hours &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; : 0&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c4&quot;&gt;Minutes &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; : 0&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c4 c40&quot;&gt;Seconds &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; : 0&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c4 c40&quot;&gt;Milliseconds &amp;nbsp; &amp;nbsp; &amp;nbsp;: 1&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c4&quot;&gt;...&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c0&quot;&gt;The first access for below 512MiB takes around a second, this is because the request still needs to be made to the server and the server is written in .NET which can have a slow startup time for running new code. The second request takes significantly less that 1 second, the memory is now cached locally and so there doesn&amp;rsquo;t need to be any request.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;For the accesses above 512MiB the first request takes around 10 seconds, which correlates with the added delay. The second request takes less than a second because the page is now cached locally. This is exactly what we&amp;rsquo;d expect, and proves that we can at least delay for 10 seconds. In fact you can delay the request at least &lt;/span&gt;&lt;span&gt;60 seconds&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;before the connection is forcibly reset. This is based on the session timeout for the SMB client. You can query the SMB client timeout using the following command in PowerShell:&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;a id=&quot;t.db47a5709a9f9e94517cc875b722670219be55f2&quot;&gt;&lt;/a&gt;&lt;a id=&quot;t.11&quot;&gt;&lt;/a&gt;&lt;table class=&quot;c15&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;c13&quot;&gt;&lt;td class=&quot;c10&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c17 c25&quot;&gt;PS&amp;gt; (&lt;/span&gt;&lt;span class=&quot;c14&quot;&gt;Get-SmbClientConfiguration&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;).SessionTimeout&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c3&quot;&gt;60&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c11 c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c1&quot;&gt;A few things to note about the SMB client&amp;rsquo;s behavior which came out of testing. First the client or the Windows cache manager seem to be able to do some caching of the remote file. If you request a specific access when opening the file, such as GENERIC_READ | GENERIC_WRITE for the desired access then caching is enabled. This means the read requests do not go to the server if they&amp;rsquo;re previously been cached locally. However if you specify MAXIMUM_ALLOWED for the desired access the caching doesn&amp;rsquo;t seem to take place. Secondly, sometimes parts of the file will be pre-cached, such as the first and last 32KiB of the file. I&amp;rsquo;ve not worked out what is the cause, oddly it seems to happen more often with native code than .NET code, so perhaps it&amp;rsquo;s Windows Defender peeking at memory or perhaps Superfetch. In general as long as you keep your memory accesses somewhere in the middle of a large file you should be safe.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c0&quot;&gt;If you&amp;rsquo;ve run the example code you might notice a problem, running the example server locally fails with the following error:&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c4&quot;&gt;System.Net.Sockets.SocketException (10013): An attempt was made to access a socket in a way forbidden by its access permissions.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c0&quot;&gt;By default Windows 10 has the SMB server enabled. This takes over the TCP ports and makes them exclusive so it&amp;rsquo;s not possible to bind to them from a normal user. It is possible to disable the local SMB server, but that would require administrator privileges. Still, it was worth verifying whether the SMB server approach will work even if we have to communicate with a remote server.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;I did do some investigation into tricks I could use to get the built-in SMB server to work for our purposes. For example I tried to use the fact that you can set an Opportunistic Lock which will trap file reads. I used this trick to exploit a &lt;/span&gt;&lt;span class=&quot;c27&quot;&gt;&lt;a class=&quot;c201&quot; href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=1774&quot;&gt;TOCTOU vulnerability&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;in the LUAFV driver. Unfortunately the SMB server detects the file is already in a lock and waits for the OpLock break to occur before allowing access to the file. This made it a non-starter.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;For testing you can disable the &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;LanmanServer&lt;/span&gt;&lt;span&gt;&amp;nbsp;service and its corresponding drivers. If you wanted to use this on an arbitrary system you&amp;#39;d almost certainly need to connect to a remote server. I&amp;rsquo;ve released the example server code &lt;/span&gt;&lt;span class=&quot;c27&quot;&gt;&lt;a class=&quot;c201&quot; href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=2142&quot;&gt;here&lt;/a&gt;&lt;/span&gt;&lt;span&gt;, which can be repurposed, although it is only a demonstrator. It allows for read granularity of the native page size, which is assumed to be 4KiB. The server code should work on Linux but as of version 1.4.3 of SMBLibrary on NuGet there&amp;rsquo;s a bug which causes the server to fail when starting. There is a fix in the &lt;/span&gt;&lt;span class=&quot;c27&quot;&gt;&lt;a class=&quot;c201&quot; href=&quot;https://github.com/TalAloni/SMBLibrary/commit/e1d06e72daa91a4f0021707c525bcd20c805d7fc&quot;&gt;github repository&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;but at the time of writing there&amp;rsquo;s no updated package.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c0&quot;&gt;How well does abusing the SMB client meet with our criteria from earlier? I&amp;rsquo;ve crossed out all the ones we&amp;rsquo;ve met.&lt;/span&gt;&lt;/p&gt;&lt;ul style=&#39;padding: 0;&#39; class=&quot;c19 lst-kix_fmvhww8n3gvt-0&quot;&gt;&lt;li style=&#39;margin-left: 46pt;&#39; class=&quot;c5 c33 li-bullet-0&quot;&gt;&lt;span class=&quot;c37&quot;&gt;Works on a default installation of Windows 10 20H2.&lt;/span&gt;&lt;/li&gt;&lt;li style=&#39;margin-left: 46pt;&#39; class=&quot;c5 c33 li-bullet-0&quot;&gt;&lt;span class=&quot;c37&quot;&gt;Gives a clear signal when memory is read or written.&lt;/span&gt;&lt;/li&gt;&lt;li style=&#39;margin-left: 46pt;&#39; class=&quot;c5 c33 li-bullet-0&quot;&gt;&lt;span class=&quot;c37&quot;&gt;Works when memory is accessed from both user and kernel mode.&lt;/span&gt;&lt;/li&gt;&lt;li style=&#39;margin-left: 46pt;&#39; class=&quot;c5 c33 li-bullet-0&quot;&gt;&lt;span class=&quot;c37&quot;&gt;Allows for delaying memory access indefinitely.&lt;/span&gt;&lt;/li&gt;&lt;li style=&#39;margin-left: 46pt;&#39; class=&quot;c5 c33 li-bullet-0&quot;&gt;&lt;span class=&quot;c37&quot;&gt;The data in the memory accessed is arbitrary.&lt;/span&gt;&lt;/li&gt;&lt;li style=&#39;margin-left: 46pt;&#39; class=&quot;c5 c33 li-bullet-0&quot;&gt;&lt;span class=&quot;c0&quot;&gt;The primitive can be set up from a range of privilege levels.&lt;/span&gt;&lt;/li&gt;&lt;li style=&#39;margin-left: 46pt;&#39; class=&quot;c5 c33 li-bullet-0&quot;&gt;&lt;span class=&quot;c0&quot;&gt;Can trap multiple times during the same exploit.&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c0&quot;&gt;Using the SMB client does meet the majority of our criteria. I verified that it doesn&amp;rsquo;t matter whether kernel or user mode code accesses the memory it will still trap. The biggest problem is it&amp;rsquo;s hard to use this from a sandboxed application where it would perhaps be most useful. This is because MUP restricts access to remote file systems by default from restricted and low IL processes and AppContainer sandboxes need specific capabilities which are unlikely to be granted to the majority of applications. That&amp;rsquo;s not to say it&amp;rsquo;s completely impossible but it&amp;rsquo;d be hard to do.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c0&quot;&gt;While our trick doesn&amp;rsquo;t really delay the memory read indefinitely, for our purposes the limit of 60 seconds based on the SMB session timeout is going to be enough for most vulnerabilities. Also once the trap has been activated you can&amp;rsquo;t force the memory manager to request the same page from the server. I tried playing with memory caching flags and direct IO but at least for files over SMB nothing seemed to work. However, you can specify your own base address when mapping a file so you could map different offsets in the file to the same virtual address by unmapping the original and mapping in a new copy. This would allow you to use the same address multiple times.&lt;/span&gt;&lt;/p&gt;&lt;h3 class=&quot;c47&quot; id=&quot;h.evvlbxcvrcux&quot;&gt;&lt;span&gt;WebDAV&lt;/span&gt;&lt;/h3&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;As SMB can&amp;rsquo;t be easily used locally, what about WebDAV? By default TCP port 80 is unused on Windows 10 so we can start our own web server to communicate with. Also unlike on Linux there&amp;rsquo;s no requirement for having administrator privileges to bind to TCP ports under 1024. Even if either of these were not the case the WebDAV client supports a syntax to specify the TCP port of the server. For example if you use the path &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;\\localhost@8080\share&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;then the WebDAV HTTP connection will be made over port 8080.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;However, does the WebDAV client expose the right read and write primitives to allow us to trap on memory access? I wrote a simple WebDAV server using the &lt;/span&gt;&lt;span class=&quot;c27&quot;&gt;&lt;a class=&quot;c201&quot; href=&quot;https://github.com/ramondeklein/nwebdav&quot;&gt;NWebDav&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;library to serve local files. Running the script but specifying the WebDAV server on port 8080 to open the 1GiB file I&amp;rsquo;m immediately faced with a problem:&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c4&quot;&gt;Get-NtFile : (0xC0000904) - The file size exceeds the limit allowed and cannot be saved.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;Just opening the file fails with the error code &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;STATUS_FILE_TOO_LARGE&lt;/span&gt;&lt;span&gt;. The reason for that can be found in one of many Microsoft Knowledge Base articles such as &lt;/span&gt;&lt;span class=&quot;c27&quot;&gt;&lt;a class=&quot;c201&quot; href=&quot;https://support.microsoft.com/en-us/help/900900/folder-copy-error-message-when-downloading-a-file-that-is-larger-than&quot;&gt;this one&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;. There&amp;rsquo;s a default limit of 50MB (that&amp;rsquo;s decimal megabytes) for any file accessed on a WebDAV share because it used to be possible to cause a denial of service by tricking a Windows system into downloading an arbitrarily large file.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c0&quot;&gt;The reason this size limiting behavior is in place is why WebDAV isn&amp;rsquo;t suitable for this attack. If you resize the file to below 50MB you&amp;rsquo;ll find the WebDAV client pulls the file in its entirety to the local disk before returning from the file open call. That file is then mapped into memory as a local file. The WebDAV server never receives a GET or PUT request for reads/writes to the memory mapping synchronously so there&amp;rsquo;s no mechanism to detect or trap specific memory requests.&lt;/span&gt;&lt;/p&gt;&lt;h2 class=&quot;c44&quot; id=&quot;h.59ueolz2y462&quot;&gt;&lt;span class=&quot;c31&quot;&gt;File System Overlay APIs&lt;/span&gt;&lt;/h2&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;Abusing the SMB client does work, but it can&amp;rsquo;t be used locally on a default installation. I decided I need to look for another approach. As I was looking at Windows Filter Drivers (see &lt;/span&gt;&lt;span class=&quot;c27&quot;&gt;&lt;a class=&quot;c201&quot; href=&quot;https://googleprojectzero.blogspot.com/2021/01/hunting-for-bugs-in-windows-mini-filter.html&quot;&gt;last blog post&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;) I noticed a few of the drivers provided a mechanism to overlay another file system on top of an existing one. I trawled through MSDN to find the API documentation to see if anything would be suitable. The three I looked at are shown in the table below.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;a id=&quot;t.07db48b5a4fefea0a123d782488fba47f782125d&quot;&gt;&lt;/a&gt;&lt;a id=&quot;t.12&quot;&gt;&lt;/a&gt;&lt;table class=&quot;c15&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;c13&quot;&gt;&lt;td class=&quot;c2 c42&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c26&quot;&gt;File system&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c34 c42&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c26&quot;&gt;Supported Version&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c23 c42&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c26&quot;&gt;Default?&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;c13&quot;&gt;&lt;td class=&quot;c2&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c27&quot;&gt;&lt;a class=&quot;c201&quot; href=&quot;https://docs.microsoft.com/en-us/windows/win32/projfs/projected-file-system&quot;&gt;Projected File System&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c34&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c0&quot;&gt;Windows 10 1809&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c23&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c0&quot;&gt;No&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;c13&quot;&gt;&lt;td class=&quot;c2&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c27&quot;&gt;&lt;a class=&quot;c201&quot; href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/wofapi/&quot;&gt;Windows Overlay (WOF)&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c34&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c0&quot;&gt;Everything&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c23&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c0&quot;&gt;Yes&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;c13&quot;&gt;&lt;td class=&quot;c2&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c27&quot;&gt;&lt;a class=&quot;c201&quot; href=&quot;https://docs.microsoft.com/en-us/windows/win32/cfapi/cloud-files-api-portal&quot;&gt;Cloud Files API&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c34&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c0&quot;&gt;Windows 10 1709 &lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td class=&quot;c23&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p class=&quot;c8&quot;&gt;&lt;span class=&quot;c0&quot;&gt;Yes (except non-Desktop Server SKUs)&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;By far the most interesting one is the Projected File System. This was developed by Microsoft to provide a virtual file system for GIT. It allows placeholder files to be &amp;ldquo;projected&amp;rdquo; into a directory on disk and the contents of those files are only &amp;ldquo;rehydrated&amp;rdquo; to a full file on demand. In theory this sounds ideal, as long as it would populate the file&amp;rsquo;s contents piecemeal we could add the delays when receiving the &lt;/span&gt;&lt;span class=&quot;c27&quot;&gt;&lt;a class=&quot;c201&quot; href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/projectedfslib/nc-projectedfslib-prj_get_file_data_cb&quot;&gt;PRJ_GET_FILE_DATA_CB callback&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;. &lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;However a basic implementation based on Microsoft&amp;rsquo;s &lt;/span&gt;&lt;span class=&quot;c27&quot;&gt;&lt;a class=&quot;c201&quot; href=&quot;https://github.com/Microsoft/Windows-classic-samples/tree/master/Samples/ProjectedFileSystem&quot;&gt;ProjectedFileSystem&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;sample code would always rehydrate the entire file during file open, similar to WebDAV. Perhaps there&amp;rsquo;s an option I missed to stream the contents rather than populate it in one go but I couldn&amp;rsquo;t find it immediately. In any case the Projected File System is not installed by default making it less useful. &lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c0&quot;&gt;WOF doesn&amp;rsquo;t really allow you to implement your own file system semantics. Instead it allows you to overlay files from either a secondary Windows Image File (WIM) or compressed on the same volume. This really doesn&amp;rsquo;t give us the control we&amp;rsquo;re looking for, you might be able to finagle something to work but it seems a lot of effort.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;That leaves us with the Cloud Files API. This is used by OneDrive to provide the local online filesystem but is documented and can be used to implement any file system overlay you like. It works very similar to the Projected File System, with placeholders for files and the concept of hydrating the file on demand. The contents of the files do not need to come from any online service such as OneDrive, it can all be sourced locally. Crucially after some basic testing it supports streaming the contents of the file based on what was being read and you could delay the file data requests and the reading thread would block until the read has been satisfied. This can be enabled by specifying the &lt;/span&gt;&lt;span class=&quot;c27&quot;&gt;&lt;a class=&quot;c201&quot; href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/cfapi/ne-cfapi-cf_hydration_policy_primary&quot;&gt;CF_HYDRATION_POLICY_PRIMARY&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;hydration policy with the value &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;CF_HYDRATION_POLICY_PARTIAL&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;when configuring the base sync root. This allows the Cloud File API to only hydrate the file&amp;#39;s parts which were accessed.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;This seemed perfect, until I tested with the PowerShell file mapping script where it didn&amp;rsquo;t work, my cloud file provider would always be requested to provide the entire file. Checking the Cloud Filter driver, when a request is received for mapping a placeholder file, the &lt;/span&gt;&lt;span class=&quot;c27&quot;&gt;&lt;a class=&quot;c201&quot; href=&quot;https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/flt-parameters-for-irp-mj-acquire-for-section-synchronization&quot;&gt;IRP_MJ_ACQUIRE_FOR_SECTION_SYNCHRONIZATION&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;handler always fully rehydrates the file before completing. If the file is not hydrated fully then the call to &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;NtCreateSection &lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;never returns which prevents the file being mapped into memory.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c0&quot;&gt;I was going to go back to doing my filter research until I realized I might be able to combine the SMB client loopback with the Cloud Filter API. I already knew that the SMB client doesn&amp;rsquo;t really map a file, even locally, instead it would read it on-demand via the SMB protocol. And I also knew that the Cloud Filter API would allow streaming of parts of the file on-demand as long as the file wasn&amp;rsquo;t being mapped into memory. The final setup is shown in the following diagram:&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;c5&quot;&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c11 c1&quot;&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjGkP3_uIEhVJAeStBpiac4S8GPSCbCjycwyktOKhnL2KPrIe4jzwApXnWoFT0dkoPw_Ty6f5VqJTCXSBLylo6c8-jGg5v_X9dpG5J9605DHHmkH10WABAhOx5bi8U1S1uoJ6pv_DsuFfYTay7fnKc9kAyXSMDg6D_TjVn4fHviwjc34LFKo-I-crOO/s653/image2%20%281%29.png&quot; style=&quot;display: block; padding: 1em 0; text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjGkP3_uIEhVJAeStBpiac4S8GPSCbCjycwyktOKhnL2KPrIe4jzwApXnWoFT0dkoPw_Ty6f5VqJTCXSBLylo6c8-jGg5v_X9dpG5J9605DHHmkH10WABAhOx5bi8U1S1uoJ6pv_DsuFfYTay7fnKc9kAyXSMDg6D_TjVn4fHviwjc34LFKo-I-crOO/s653/image2%20%281%29.png&quot; border=&quot;0&quot; alt=&quot;Overview of the operation of the exploitation trick. Memory is read by the application from a mapped file, which causes a page fault. That then requests the contents of the file to be pulled over SMB which goes to the local Cloud Filter Driver and back to the original application where the read is handled.&quot; style=&quot;max-height: 750; max-width: 600px;&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c11 c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;To use the primitive we first setup our own cloud provider by registering the sync root directory using the &lt;/span&gt;&lt;span class=&quot;c27&quot;&gt;&lt;a class=&quot;c201&quot; href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/cfapi/nf-cfapi-cfregistersyncroot&quot;&gt;CfRegisterSyncRoot&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;API configuring it with the partial hydration policy. Then a 1GiB placeholder can be created in the directory using &lt;/span&gt;&lt;span class=&quot;c27&quot;&gt;&lt;a class=&quot;c201&quot; href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/cfapi/nf-cfapi-cfcreateplaceholders&quot;&gt;CfCreatePlaceholders&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;. At this point the file does not have any contents on disk. If we now open and map the placeholder file via the SMB loopback client the file will not be rehydrated immediately. &lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;Any memory access into the mapping will cause the SMB client to make a request for a 32KiB block, which will be passed to our user-mode cloud provider, which we can detect and delay as necessary. It goes without saying that the contents of the file can also be arbitrary. Based on testing it doesn&amp;rsquo;t seem like you can force the read granularity down to the native page size like when implementing a custom SMB server, however you can still make requests at native page size boundaries within the large page size constraint. It might be possible to modify the file size to trick the SMB server into doing short reads but this behavior has not been tested. A sample implementation of the cloud provider is available &lt;/span&gt;&lt;span class=&quot;c27&quot;&gt;&lt;a class=&quot;c201&quot; href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=2142&quot;&gt;here&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;.&lt;/span&gt;&lt;/p&gt;&lt;h2 class=&quot;c44&quot; id=&quot;h.k8bhtxxabi3p&quot;&gt;&lt;span class=&quot;c31&quot;&gt;Usage Examples&lt;/span&gt;&lt;/h2&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;We now have an exploitation trick which allows us to trap and delay virtual memory reads and writes. The big question is, does this improve the exploitation of vulnerabilities such as double fetches? The answer depends on the actual vulnerability. A quick note,&lt;/span&gt;&lt;span&gt;&amp;nbsp;when I use the word &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;page&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;I&amp;rsquo;m meaning the unit of memory which will cause a request to the SMB server, e.g. 32KiB not the native page size such as 4KiB.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;Let&amp;rsquo;s take the example given at the start of this blog post. This vulnerability reads the value from the same memory address, &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;lpInputPtr,&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;twice. First for the comparison, then for the size to copy. &amp;nbsp;The problem for exploitation is one of the limitations of the technique is the memory trap is one shot. Once the trap has fired to read the size for the comparison you can delay it indefinitely. However, once you provide the requested memory page and the faulting thread is resumed it won&amp;rsquo;t fire on the second read, it&amp;rsquo;ll just be read from memory as if it was always there. &lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c0&quot;&gt;You might wonder if you could remap the memory page when you detect the first read? Unfortunately this doesn&amp;rsquo;t work. When the thread is resumed it restarts at the faulting instruction and will perform the read again, therefore what would happen is the following:&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;c5&quot;&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c11 c1&quot;&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgYLz9Rs5Nf4_nkG0konLO859y15CdLEukMfskpP9rNnDXdEdFcqym2P5Q3P0rVDkZTIH_lDkdCdjn8lc0NbhvDAxM5ESwGL7cif3dTQuWWUYmYF7fXFd1Llj4GemlXYbJRG3gjWmp_U3sWESxPqMUsbCWcPBYlKOQsAHW9LD34vQWaS-MteQgVBCSJ/s428/image3%20%281%29.png&quot; style=&quot;display: block; padding: 1em 0; text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgYLz9Rs5Nf4_nkG0konLO859y15CdLEukMfskpP9rNnDXdEdFcqym2P5Q3P0rVDkZTIH_lDkdCdjn8lc0NbhvDAxM5ESwGL7cif3dTQuWWUYmYF7fXFd1Llj4GemlXYbJRG3gjWmp_U3sWESxPqMUsbCWcPBYlKOQsAHW9LD34vQWaS-MteQgVBCSJ/s428/image3%20%281%29.png&quot; border=&quot;0&quot; alt=&quot;Directory graph showing states of the double fetch. &amp;#9312; Read Size from Pointer -&amp;gt; &amp;#9313; Page Fault -&amp;gt; &amp;#9314; Remap Page -&amp;gt; &amp;#9315; Resume Thread -&amp;gt; Back to &amp;#9312;&quot; style=&quot;max-height: 750; max-width: 600px;&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c0&quot;&gt;As you can tell from the diagram you end up trapped in an infinite loop, as you remap a fresh page which just triggers another page fault ad infinitum. If you don&amp;rsquo;t perform step &amp;#9314; then the operation will complete and there is a time window between resuming the thread, reading the now valid memory for the size comparison and the second read. However, in this example the time window is likely to be the order of a couple of instructions so using our exploitation trick isn&amp;rsquo;t better than the existing probabilistic approaches. That said one advantage is you do know when the read occurs which allows you to target the brute force window more accurately.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c0&quot;&gt;This example is the worst case, what if there was more time between the reads? Another example from a the Bochspwn paper is shown below:&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;a id=&quot;t.18538680f312442cf44e640ab533aa4ece63f8fb&quot;&gt;&lt;/a&gt;&lt;a id=&quot;t.13&quot;&gt;&lt;/a&gt;&lt;table class=&quot;c15&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;c13&quot;&gt;&lt;td class=&quot;c10&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c9&quot;&gt;PDWORD&lt;/span&gt;&lt;span class=&quot;c17&quot;&gt;&amp;nbsp;BufferSize&lt;/span&gt;&lt;span class=&quot;c21&quot;&gt;&amp;nbsp;=&lt;/span&gt;&lt;span class=&quot;c17&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c17 c30 c45&quot;&gt;// controlled user-mode address&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c9&quot;&gt;PUCHAR&lt;/span&gt;&lt;span class=&quot;c17&quot;&gt;&amp;nbsp;BufferPtr &amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c21&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;c17&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c17 c30&quot;&gt;// controlled user-mode address&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c9&quot;&gt;PUCHAR&lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;&amp;nbsp;LocalBuffer;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c4&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c17&quot;&gt;LocalBuffer = ExAllocatePool&lt;/span&gt;&lt;span class=&quot;c21&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;c17&quot;&gt;PagedPool, &lt;/span&gt;&lt;span class=&quot;c21 c24&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;c17 c24&quot;&gt;BufferSize&lt;/span&gt;&lt;span class=&quot;c21&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;;&amp;#9312;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c17&quot;&gt;if &lt;/span&gt;&lt;span class=&quot;c21&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;c17&quot;&gt;LocalBuffer &lt;/span&gt;&lt;span class=&quot;c21&quot;&gt;!=&lt;/span&gt;&lt;span class=&quot;c17&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;c21&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;&amp;nbsp;{&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c17&quot;&gt;&amp;nbsp; RtlCopyMemory&lt;/span&gt;&lt;span class=&quot;c21&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;c17&quot;&gt;LocalBuffer, BufferPtr, &lt;/span&gt;&lt;span class=&quot;c21 c24&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;c17 c24&quot;&gt;BufferSize&lt;/span&gt;&lt;span class=&quot;c21&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;;&amp;#9313;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c4&quot;&gt;} else {&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c17&quot;&gt;&amp;nbsp; &lt;/span&gt;&lt;span class=&quot;c17 c30&quot;&gt;// bail out&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c17&quot;&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;The same double fetch behavior is present, however what&amp;rsquo;s different is the value is passed to another function, in this case &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;ExAllocatePool&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;which allocates kernel memory. Depending of the current memory configuration or how large the allocation requested there might be a significant time delay between &amp;#9312; and &amp;#9313;. Is there any way we can win the race?&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c0&quot;&gt;Well not that I know of, at least not deterministically. But we can exploit one behavior to try to synchronize the reading and writing threads a little. Recall that in order to write to an unresolved page the contents of the page must first be read from the server. Therefore, to maintain consistency any thread writes to the unresolved page must generate a page fault and wait on the same lock as another thread which is just reading from the page, as shown in the following diagram:&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;/p&gt;


&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEj3kzk1NiN3s-rvAZ1q0zdhrCXH4tQ7WcwrokqY3-9CoxMPj9jBpqfHY63ZysC9-sbJAkoQwrVqGp44gh5uz-AAHxu7veir75BPTZIBW-DeOT-6QC9rPAqQ_iux4W6hKa9sYXtvacjXJxlVLnxt9dWYGCHSgANgtlRhMteztGeQ-luZ1RbO9WFU2htH/s546/image7%281%29.png&quot; style=&quot;display: block; padding: 1em 0; text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEj3kzk1NiN3s-rvAZ1q0zdhrCXH4tQ7WcwrokqY3-9CoxMPj9jBpqfHY63ZysC9-sbJAkoQwrVqGp44gh5uz-AAHxu7veir75BPTZIBW-DeOT-6QC9rPAqQ_iux4W6hKa9sYXtvacjXJxlVLnxt9dWYGCHSgANgtlRhMteztGeQ-luZ1RbO9WFU2htH/s546/image7%281%29.png&quot; border=&quot;0&quot; alt=&quot;Diagram showing separate read and write threads accessing the same pointer, one for read and one for write. When the page fault occurs both threads enter the same lock and they are both resumed once the lock is released.&quot; style=&quot;max-height: 750; max-width: 600px;&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;By synchronizing the reading and writing threads you&amp;rsquo;re giving yourself a reasonable chance of causing a write to happen during the time window for exploitation. This is still a probabilistic approach, it depends on the scheduler. For example, it&amp;rsquo;s possible that the write thread is woken before the read thread which will cause the pointer to always take the final value. Or the read thread could run to completion before the write thread is ever scheduled to run making the value never change. It&amp;rsquo;s possible there&amp;rsquo;s some scheduler magic such as using multiple reader or writer threads or by selecting appropriate priorities which you could exploit to guarantee read and write ordering. I&amp;rsquo;d be surprised if something is reliable across multiple Windows 10 systems. &lt;/span&gt;&lt;span&gt;I&amp;rsquo;d be very interested in anyone who&amp;rsquo;s got better ideas on how to improve the reliability of this.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c0&quot;&gt;One approach you might be wondering about is unaligned access, say splitting the value across two separate pages. From a microarchitecture perspective it&amp;rsquo;s likely that the read will be split up into two parts, first touching one page then another. However, remember how the page fault works, it generates an exception which causes a handler to execute in the kernel. At this point any work the instruction has already done will have been retired while the kernel deals with the page fault. When the thread is resumed it will restart the faulting instruction, which will reissue the appropriate micro operations to read from the unaligned address. Unless the compiler generated two loads for the unaligned access (which might happen on some architectures) then there is no way I know of to restart the memory access instruction part of the way through. &lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c0&quot;&gt;This all seems slightly downbeat on the usefulness of the exploitation trick. Thing is, there&amp;rsquo;s as many different types of vulnerability as there are fish in the sea (if you&amp;rsquo;re reading this in 2100, I apologize for the acidification of the seas which killed all marine life, choose your own apocalypse-appropriate proverb instead). For example if we modify the original example as follows:&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;a id=&quot;t.3f9f9537af555b4c0a2cb97c4aeb7b99d22a5aa1&quot;&gt;&lt;/a&gt;&lt;a id=&quot;t.14&quot;&gt;&lt;/a&gt;&lt;table class=&quot;c15&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;c13&quot;&gt;&lt;td class=&quot;c10&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c9&quot;&gt;PDWORD&lt;/span&gt;&lt;span class=&quot;c17&quot;&gt;&amp;nbsp;lpInputPtr&lt;/span&gt;&lt;span class=&quot;c21&quot;&gt;&amp;nbsp;=&lt;/span&gt;&lt;span class=&quot;c17&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c17 c30&quot;&gt;// controlled user-mode address&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c9&quot;&gt;UCHAR&lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;&amp;nbsp; LocalBuffer[256];&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c4&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c17&quot;&gt;if &lt;/span&gt;&lt;span class=&quot;c21&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;c17 c24&quot;&gt;lpInputPtr&lt;/span&gt;&lt;span class=&quot;c21 c24&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;c17 c24&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;c21 c24&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;c17&quot;&gt;&amp;nbsp;&amp;gt; &lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;c21&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;c17&quot;&gt;LocalBuffer&lt;/span&gt;&lt;span class=&quot;c21&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;c17&quot;&gt;&amp;nbsp;|| lpInputPtr&lt;/span&gt;&lt;span class=&quot;c21&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;c17&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;c21&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;c17&quot;&gt;&amp;nbsp;!= 2&lt;/span&gt;&lt;span class=&quot;c21&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;&amp;nbsp;{&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c17&quot;&gt;&amp;nbsp; &lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;&amp;nbsp;STATUS_INVALID_PARAMETER;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c4&quot;&gt;}&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c17&quot;&gt;RtlCopyMemory&lt;/span&gt;&lt;span class=&quot;c21&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;c17&quot;&gt;LocalBuffer, lpInputPtr, &lt;/span&gt;&lt;span class=&quot;c21 c24&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;c17 c24&quot;&gt;lpInputPtr&lt;/span&gt;&lt;span class=&quot;c21&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;The check now ensures the buffer is large enough and a second DWORD in the buffer is not set to 2. The second field might represent the buffer type, and type 2 isn&amp;rsquo;t valid for this request. If you check the compiler output for this code, such as on &lt;/span&gt;&lt;span class=&quot;c27&quot;&gt;&lt;a class=&quot;c20&quot; href=&quot;https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAM1QDsCBlZAQwBtMQBGAFlICsupVs1qhkAUgBMAISnTSAZ0ztkBPHUqZa6AMKpWAVwC2tEJNJb0AGTy1MAOWMAjTMS4AOUgAdUCwuto9QxMzb19/Ohs7RyMXN05PJRU1OgYCZmICIONTcyTMVQC0jIIoh2dXD0V0zOyQvJrS23LYyoSASkVUA2JkDgByAgBPL0wsKgBqA1o/YDt0CdsCCYARAHUAeQAlFfEAZlkABgBBYdHxiYA3fWY1divUPHQAKgmABQA1DYBJXYPxE5nMaYSbTWbzCbIBAZCYAVR0AAljlt9kdTiNgZNrsI7phVpsdq83uttn80QDjtcnhMtgRWHovEMALKYIwkIYQT4/FarTAKAikd5fX4TBjdXqYQUknaivAAL0w7VRFK0xgm9gAKgwNccNbCGBNxAB2NETUU6vUMAD633sH2OVl%2BVreyOOTOwGuwW0Nex5hwAHjpDsGQ9gKcayeGTprtbr9atuk52AAxTAEKGc6U81heb60LwGAhvAjEdqGk0Us3wpHeiZWVAsVjSAxUKiucQAVmkkg7ADZO5GToah4tJhBnjm8wWiyWfdgJn4FagqBB643m63XO0y8bTWaJsQ0z1aOa49bbfbHStna73Z6Uf8RxHKzS6Qzmaz2auG2wN22yBMk75oWxYAROubATOpbKicEb9J0rAgP0Hb9KQpj9IcqGoEhOhyHIC7in0hqSHsnCoQQSGYZ0EBIGgWC4IQJDkJQND0EwbAcDw/ChMIogoHhMiKMoBQpKYECWHUuQWNoZQxHEVQ%2BH4omSaEikRLQskVPEiTCYUqSNCpeS6aJxSZJprTadUJSGVZZnNHJbTuJ0CiEQMQIXGCeBzGMiz0PipIwei5wgg8OJ4PcVIvEK3KBe5IWed5CxQjC1bIrFGIXNitzhXiWZElmgUUpFr70qgjIsmyxAclyIorHyArRSKYo9H0UoEjyDDyoqgWqkY6paha8a7i%2BsaWjadoOk6LpbG6Hpej6fqBiGobhkag7HBSMaDQaKyJimaYZsS7WARB06gTuFYjqltZrr%2BLb/p23Z9gOgXDscZp4GOQFnSWj2HAOc4Ll1y7fuu91buWuFGjoJ1TiBv1dpwANgGA%2Bw8pIF17mah4EMep5jRek3XtNs33q95a7COtKleVn5VaDd2bgB33w2BLNQUqj4bWt8FCEhKFoZRWE4QJ0gES1eJSHskjkUL26kAA1iAex7AAdCrGua1rvZ8/03CoehmGkNh/SoQoICHKQFEYbzcCwLRqBGF4OVkBQEBoE7LsgJcyBeF4VqXJwACcVqSO4Vr%2Br2vBUOFBCuObEBOELpBOLYGRDEhZGkB7RhaAQGy0KwGc26QWBGCIwDsMn%2BCHoUlx8snmD%2BgUhYDFnSzKMnrB4E4xDp3oWCZ%2BRxB4EYQ%2BdKxjCNpxvACJwQgV/xMhyEIPfm5AnRlaJ5v9AA9AA4gwAC0Ey7xsMtCckASaNoKnz5Y5nyfPanKfoOSCC/ASP20l8iUUBlvxCPPfIelaCmSaNELSgh%2BTWUAaYYBjRv7xGcq5LgCF%2BYG2TibSO3AJhGAUD7K4wdVZhwmBABiRBiDEVIoKPQnt2BUKlpwMsuFl4yFljbeWSsVbqy1nwlWOtEJ60wSXE2ZsLZWzlqQO2iAUCO2dgw5i7t5Fex9n7AOwdQ7hxwaQGOrA47EATknEuqdaDpyHtnR2ud6AFyLtXVkFcq4lxrn/euO8jZNxbnHCxHchFG27r3fuGA27D1HuPXRdAp4cS4LPHii8JBsPkAE9eEBN5eG3khA%2Bx9T7nzNsZa%2B4lb5wMEA/eyUDn7hFfsEeBYQlJfzKRZaB%2BT9KwOqU0q%2BLS7KQMaQg1p79eldJaE/FBEszDoOQiIo22Co54IIcgIhQcSHuDIRQkg1DzATDoQo1w6yWGiw4VRTo3C1b8P4brfWgtRFIXEZba2hzdYX0NsLU2kjOGdHroY6%2B3AgA%3D&quot;&gt;Godbolt&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;, the difference in native code is 2 or 3 instructions. This would seem to not materially improve the odds of winning the TOCTOU race when using a na&amp;iuml;ve probabilistic approach. But with our exploitation trick we can now build a deterministic exploit.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;/p&gt;


&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhJ2TixWgccB73eu57EZz9CfSr8HucoBWi5aoUF7R-rTGzVCdFhiPw-0S4vstm79gqhhFVHIF_IeBb8x3EjRCYAHCmcDIoVcpIFjPiWuC-JvuRQ38pYRh5fJeZumI4LRCWovyxUKti4JJuxta1aGnnmwkDd-DaTkYPymwenXjXXVSJi4Yq8jVtse3A5/s864/image8%281%29.png&quot; style=&quot;display: block; padding: 1em 0; text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhJ2TixWgccB73eu57EZz9CfSr8HucoBWi5aoUF7R-rTGzVCdFhiPw-0S4vstm79gqhhFVHIF_IeBb8x3EjRCYAHCmcDIoVcpIFjPiWuC-JvuRQ38pYRh5fJeZumI4LRCWovyxUKti4JJuxta1aGnnmwkDd-DaTkYPymwenXjXXVSJi4Yq8jVtse3A5/s864/image8%281%29.png&quot; border=&quot;0&quot; alt=&quot;Diagram showing access memory for the two reads which can generate a page fault which can allow us to modify the original size value. The central part of the diagram shows a previous page which only contains the Size field and the next page which contains the Type field and the rest of the structure.&quot; style=&quot;max-height: 750; max-width: 600px;&quot; /&gt;&lt;/a&gt; &lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;The diagram above shows how we can achieve this deterministic exploit. We can place the &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;Size&lt;/span&gt;&lt;span&gt;&amp;nbsp;field on a different page to the rest of the input buffer, although the buffer is still contiguous in virtual memory. The first page (N-1) should already be faulted into memory and contain the &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;Size&lt;/span&gt;&lt;span&gt;&amp;nbsp;field which is smaller than the &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;LocalBuffer&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;size. We can let the read for the size &amp;#9312; complete normally.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;Next the code will read the &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;Type &lt;/span&gt;&lt;span&gt;field which is on page N &amp;#9313;. This page isn&amp;rsquo;t currently in memory and so when it&amp;rsquo;s accessed a page fault will occur &amp;#9314;. This requires the kernel to read the contents from the file, which we can detect and delay. When the read is detected we have as long as we need to modify the &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;Size&lt;/span&gt;&lt;span&gt;&amp;nbsp;field to contain a value larger than the &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;LocalBuffer &lt;/span&gt;&lt;span&gt;size &amp;#9315;. Finally we complete the read, which will restart the thread back at the &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;Type&lt;/span&gt;&lt;span&gt;&amp;nbsp;field read instruction &amp;#9316;. The code can continue and will now read the overly large &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;Size &lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;field and cause memory corruption.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c0&quot;&gt;The key takeaway is that if between the double fetch points the code touches any user mode memory under your control which is not the one being double fetched it should be possible to convert that into a deterministic exploit. It doesn&amp;rsquo;t matter if the target system only has a single CPU, what the scheduling algorithm is in the kernel, how many instructions are between the double fetch points or what day of the week it is etc, it should &amp;ldquo;just work&amp;rdquo;.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;The followup &lt;/span&gt;&lt;span class=&quot;c27&quot;&gt;&lt;a class=&quot;c201&quot; href=&quot;https://j00ru.vexillium.org/2013/06/kernel-double-fetch-race-condition-exploitation-on-x86-further-thoughts/&quot;&gt;blog post&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;on double-fetch exploitation gives some figures for exploitability. The examples shown up to now, when the right timing window is chosen the chance of success can hit 100% after some number of seconds. However, as shown here we can get 100% reliability on some classes of the same bug, but in the best case this isn&amp;rsquo;t an improvement other than it being deterministic. &lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;All examples up to now only demonste the exploitation of what the blog post refers to as &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;arithmetic races&lt;/span&gt;&lt;span&gt;. The blog also mentions a second class of bug, &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;binary races&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;, which are harder to exploit and never reach 100% success. Let&amp;rsquo;s look at the example in the blog and see if our exploitation trick would do better.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;a id=&quot;t.7db195a360fcabcc929be150b8a3200c34da46fc&quot;&gt;&lt;/a&gt;&lt;a id=&quot;t.15&quot;&gt;&lt;/a&gt;&lt;table class=&quot;c15&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;c13&quot;&gt;&lt;td class=&quot;c10&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c9&quot;&gt;PVOID*&lt;/span&gt;&lt;span class=&quot;c17&quot;&gt;&amp;nbsp;UserPointer &lt;/span&gt;&lt;span class=&quot;c21&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;c17&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c17 c30&quot;&gt;// controlled user-mode address&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c4&quot;&gt;__try {&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c17&quot;&gt;&amp;nbsp; &amp;nbsp;ProbeForWrite&lt;/span&gt;&lt;span class=&quot;c21&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;c21 c24&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;c17 c24&quot;&gt;UserPointer&lt;/span&gt;&lt;span class=&quot;c17&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;c17&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;c21&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;c17&quot;&gt;STRUCTURE&lt;/span&gt;&lt;span class=&quot;c21&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;c17&quot;&gt;, 1&lt;/span&gt;&lt;span class=&quot;c21&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;;&amp;#9312;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c17&quot;&gt;&amp;nbsp; &amp;nbsp;RtlCopyMemory&lt;/span&gt;&lt;span class=&quot;c21&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;c21 c24&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;c17 c24&quot;&gt;UserPointer&lt;/span&gt;&lt;span class=&quot;c17&quot;&gt;, &lt;/span&gt;&lt;span class=&quot;c17&quot;&gt;LocalPointer, &lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;c21&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;c17&quot;&gt;STRUCTURE&lt;/span&gt;&lt;span class=&quot;c21&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;;&amp;#9313;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c4&quot;&gt;} __except {&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&amp;nbsp; &amp;nbsp;return&lt;/span&gt;&lt;span class=&quot;c17&quot;&gt;&amp;nbsp;GetExceptionCode&lt;/span&gt;&lt;span class=&quot;c21&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c17&quot;&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;On the face of it this doesn&amp;rsquo;t look massively different to previous examples, however in this case the destination pointer is being changed rather than the size. The &lt;/span&gt;&lt;span class=&quot;c27&quot;&gt;&lt;a class=&quot;c201&quot; href=&quot;https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-probeforwrite&quot;&gt;ProbeForWrite&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;kernel API which checks the pointer is both at a user-mode address and the memory is writable. This is a commonly used idiom to verify a user supplied pointer is not pointing into kernel memory. &lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c0&quot;&gt;If the pointer value is changed between &amp;#9312; and &amp;#9313; from a user mode address to a kernel mode address the example would overwrite kernel memory. The behavior is harder to exploit with a probabilistic exploit as there are only two valid values of the pointer, either a user-mode address or a kernel mode address. If you&amp;rsquo;re brute forcing the pointer value then it&amp;rsquo;s possible to end up where both fetches read a user-mode pointer even though it might change to a kernel pointer in between the fetches.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;Fortunately, due to the call to &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;ProbeForWrite &lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;this is trivial to exploit if you can trap on user memory access as shown in the following diagram:&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;/p&gt;

&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c11 c1&quot;&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjPVBImqO-RzAUdh-aNJLYZmCQCk5mFaMOxx_F3iAyGKkYnJGCHnIrC4jdqbuOde5H5XgsHM3EcPTvEIL-XDSaP1QSg2qKn798hmz8BiZOH1NeHhJ1eyT0oV1J0RNPlgQr0-r-sfxBrl53LXN9SbPUBC0E_r1feOxbscMmtNet2gzmi2QtPAeMyGUFV/s875/image4%20%281%29.png&quot; style=&quot;display: block; padding: 1em 0; text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjPVBImqO-RzAUdh-aNJLYZmCQCk5mFaMOxx_F3iAyGKkYnJGCHnIrC4jdqbuOde5H5XgsHM3EcPTvEIL-XDSaP1QSg2qKn798hmz8BiZOH1NeHhJ1eyT0oV1J0RNPlgQr0-r-sfxBrl53LXN9SbPUBC0E_r1feOxbscMmtNet2gzmi2QtPAeMyGUFV/s875/image4%20%281%29.png&quot; border=&quot;0&quot; alt=&quot;Diagram showing access to the UserPointer which is then passed to ProbeForWrite. We can generate a page fault when probing the buffer which can allow us to modify the original pointer.&quot; style=&quot;max-height: 750; max-width: 600px;&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c11 c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;From the diagram the first read from &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;UserPointer&lt;/span&gt;&lt;span&gt;&amp;nbsp;is made &amp;#9312; and the resulting pointer value passed to &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;ProbeForWrite&lt;/span&gt;&lt;span&gt;. &lt;/span&gt;&lt;span&gt;The &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;ProbeForWrite &lt;/span&gt;&lt;span&gt;API first checks if the pointer is in the user-mode address space, then probes each page of memory up to the size of the length parameter &amp;#9313;.&lt;/span&gt;&lt;span&gt;&amp;nbsp;If the page is invalid or is not writable then an exception will be generated and caught by the example&amp;#39;s &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;__except&lt;/span&gt;&lt;span&gt;&amp;nbsp;block. This gives us our exploit opportunity, we can use the exploitation trick on the one of the user-mode pages which is being probed which will cause &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;ProbeForWrite &lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;to generate a page fault we can trap &amp;#9314;. However as the address being probed is not the same as the one storing the pointer we can modify it to contain a kernel mode address while the request is trapped &amp;#9315;. The result is we can deterministically win the race.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;Of course I&amp;rsquo;ve been focussing on kernel double fetches as it&amp;rsquo;s what originally drew me to look for this behavior. There are many scenarios where this can be used to aid exploitation of user-mode applications. The most obvious one is where a service is sharing memory with a lower privileged application. An example of this sort of issue was a &lt;/span&gt;&lt;span class=&quot;c27&quot;&gt;&lt;a class=&quot;c201&quot; href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=1648&quot;&gt;double-fetch in the DfMarshal COM marshaler&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;. The COM marshaler shared a memory section between processes so it was possible to provide a section which exploited our trick. In the end this trick wasn&amp;rsquo;t necessary as the logic of the vulnerable code allowed me to create an infinite loop to extend the double fetch window. However if that didn&amp;#39;t exist we could use this trick to detect and delay when the code was at the point where the handle could be switched.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;Another more subtle use is where a privileged process reads memory from a less privileged process. This might be explicit use of APIs such as &lt;/span&gt;&lt;span class=&quot;c27&quot;&gt;&lt;a class=&quot;c201&quot; href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-readprocessmemory&quot;&gt;ReadProcessMemory&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;or it could be indirect, for example querying for the process&amp;rsquo; command line using &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;NtQueryInformationProcess &lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;will read out memory locations under our control.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;The thing to remember with this exploitation trick is it can be used to open up the window to win a timing race. In this case it&amp;rsquo;s similar to my previous work on oplocks, but instead for memory access. In fact the access to memory might be incidental to the vulnerable code, it doesn&amp;rsquo;t have to be a memory double fetch or necessarily even a TOCTOU vulnerability. &lt;/span&gt;&lt;span&gt;For example you might be trying to win a race between two file paths with symbolic links. As long as the vulnerable code can be made to probe a user mode address we control then you can use it as a timing signal and to widen the exploitation window.&lt;/span&gt;&lt;/p&gt;&lt;h2 class=&quot;c44&quot; id=&quot;h.ahyvz49oskx5&quot;&gt;&lt;span class=&quot;c31&quot;&gt;Conclusions&lt;/span&gt;&lt;/h2&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span&gt;I&amp;rsquo;ve described an exploitation trick by combining SMB and the Cloud File API which can &lt;/span&gt;&lt;span&gt;aid in demonstrati&lt;/span&gt;&lt;span&gt;ng exploitation of certain types of the application and kernel vulnerabilities. It&amp;rsquo;s possible that there are other ways of achieving a similar result with APIs I haven&amp;rsquo;t looked at, but for now this is the best approach I&amp;rsquo;ve come up with. It allows you to trap on reads from user-mode memory, detect when the access occurs and delay the read for at least 60 seconds. Examples of code to implement the SMB and Cloud File API tricks are available &lt;/span&gt;&lt;span class=&quot;c27&quot;&gt;&lt;a class=&quot;c201&quot; href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=2142&quot;&gt;here&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c0&quot;&gt;It&amp;rsquo;s worth just reiterating some more of the limitations of this exploitation trick before we conclude.&lt;/span&gt;&lt;/p&gt;&lt;ul style=&#39;padding: 0;&#39; class=&quot;c19 lst-kix_2duiues326zm-0 start&quot;&gt;&lt;li style=&#39;margin-left: 46pt;&#39; class=&quot;c5 c33 li-bullet-0&quot;&gt;&lt;span class=&quot;c0&quot;&gt;Can&amp;rsquo;t be used in a sandbox, only from a normal user privilege.&lt;/span&gt;&lt;/li&gt;&lt;li style=&#39;margin-left: 46pt;&#39; class=&quot;c5 c33 li-bullet-0&quot;&gt;&lt;span class=&quot;c0&quot;&gt;Only allows a one shot for any page mapped from the file. If something else (such as AV) tries to read that page or from the file then the trap may fire early.&lt;/span&gt;&lt;/li&gt;&lt;li style=&#39;margin-left: 46pt;&#39; class=&quot;c5 c33 li-bullet-0&quot;&gt;&lt;span&gt;Can&amp;rsquo;t detect the exact location of a read, &lt;/span&gt;&lt;span&gt;limited to a granularity of 4KiB&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;. For local access via the Cloud File API this will always populate the next 7 pages as well as part of the 32KiB read. If accessing a custom SMB server the read size can be reduced to 4KiB. Would prevent exploitation of certain bugs which require precise trapping only on a small area within a larger structure.&lt;/span&gt;&lt;/li&gt;&lt;li style=&#39;margin-left: 46pt;&#39; class=&quot;c5 c33 li-bullet-0&quot;&gt;&lt;span class=&quot;c0&quot;&gt;Can only detect writes indirectly, can&amp;rsquo;t specifically trap on a write.&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c0&quot;&gt;From a practical perspective the trick presented here doesn&amp;rsquo;t significantly improve the win rates for traditional kernel double fetches outlined in the Bochspwn paper. Realistically for most of those classes of vulnerability you&amp;rsquo;d probably want to use a probabilistic approach, if anything due to its simplicity of implementation. However the trick is applicable to other bug classes where the memory trap is used as a deterministic timing signal adjunct to the vulnerability.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5 c7&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c0&quot;&gt;The one shot nature of the trick also makes it of no real benefit to exploiting simple double fetch code paths. Also more complex code which might read and write to a memory address more than once before you get to the vulnerable code which might make managing traps more difficult.&lt;/span&gt;&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='https://googleprojectzero.blogspot.com/feeds/7843265571440320887/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='https://googleprojectzero.blogspot.com/2021/01/windows-exploitation-tricks-trapping.html#comment-form' title='0 Comments'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/4838136820032157985/posts/default/7843265571440320887'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/4838136820032157985/posts/default/7843265571440320887'/><link rel='alternate' type='text/html' href='https://googleprojectzero.blogspot.com/2021/01/windows-exploitation-tricks-trapping.html' title='Windows Exploitation Tricks: Trapping Virtual Memory Access'/><author><name>Anonymous</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/blank.gif'/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEguHIRfKCvq_K5S5w5-xaLcOS5TyeCoO3ERoRIFDUEWb5lh98mijADeGnRHfs6hy4Nto06n9Lyb1u41F7KfVMKWQWGmkeCdHJRGl4c_kvt9ricS0NMSETy7De1IPEqLV7wb6pte6KK4PRjFanlQBM6jsmbmakm5lvxSldvMqeieEPvD4XFnMadrbVUB/s72-c/image6%281%29.png" height="72" width="72"/><thr:total>0</thr:total></entry>