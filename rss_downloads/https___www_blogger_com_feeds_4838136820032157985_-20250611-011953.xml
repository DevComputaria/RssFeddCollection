<?xml version='1.0' encoding='UTF-8'?><?xml-stylesheet href="http://www.blogger.com/styles/atom.css" type="text/css"?><entry xmlns='http://www.w3.org/2005/Atom' xmlns:blogger='http://schemas.google.com/blogger/2008' xmlns:georss='http://www.georss.org/georss' xmlns:gd='http://schemas.google.com/g/2005' xmlns:thr='http://purl.org/syndication/thread/1.0'><id>tag:blogger.com,1999:blog-4838136820032157985.post-2892029424446991022</id><published>2022-03-24T13:51:00.005-07:00</published><updated>2022-08-24T12:08:43.176-07:00</updated><title type='text'>Racing against the clock -- hitting a tiny kernel race window</title><content type='html'>&lt;style type=&quot;text/css&quot;&gt;.lst-kix_oh8g77k3z2ge-8&gt;li:before{content:&quot;\0025a0  &quot;}ol.lst-kix_94mysn7p9quk-2.start{counter-reset:lst-ctn-kix_94mysn7p9quk-2 0}.lst-kix_94mysn7p9quk-5&gt;li{counter-increment:lst-ctn-kix_94mysn7p9quk-5}.lst-kix_oh8g77k3z2ge-6&gt;li:before{content:&quot;\0025cf  &quot;}ol.lst-kix_94mysn7p9quk-7{list-style-type:none}ol.lst-kix_94mysn7p9quk-6{list-style-type:none}.lst-kix_oh8g77k3z2ge-7&gt;li:before{content:&quot;\0025cb  &quot;}ol.lst-kix_94mysn7p9quk-8{list-style-type:none}.lst-kix_oh8g77k3z2ge-4&gt;li:before{content:&quot;\0025cb  &quot;}ol.lst-kix_94mysn7p9quk-3{list-style-type:none}ol.lst-kix_94mysn7p9quk-2{list-style-type:none}ol.lst-kix_94mysn7p9quk-5{list-style-type:none}ol.lst-kix_94mysn7p9quk-4{list-style-type:none}.lst-kix_oh8g77k3z2ge-5&gt;li:before{content:&quot;\0025a0  &quot;}ol.lst-kix_94mysn7p9quk-1{list-style-type:none}ol.lst-kix_94mysn7p9quk-0{list-style-type:none}.lst-kix_oh8g77k3z2ge-0&gt;li:before{content:&quot;\0025cf  &quot;}.lst-kix_94mysn7p9quk-0&gt;li{counter-increment:lst-ctn-kix_94mysn7p9quk-0}.lst-kix_oh8g77k3z2ge-2&gt;li:before{content:&quot;\0025a0  &quot;}.lst-kix_oh8g77k3z2ge-3&gt;li:before{content:&quot;\0025cf  &quot;}ol.lst-kix_94mysn7p9quk-5.start{counter-reset:lst-ctn-kix_94mysn7p9quk-5 0}.lst-kix_94mysn7p9quk-4&gt;li{counter-increment:lst-ctn-kix_94mysn7p9quk-4}.lst-kix_oh8g77k3z2ge-1&gt;li:before{content:&quot;\0025cb  &quot;}ol.lst-kix_94mysn7p9quk-8.start{counter-reset:lst-ctn-kix_94mysn7p9quk-8 0}.lst-kix_u4yb8nbjtsh3-5&gt;li:before{content:&quot;\0025a0  &quot;}.lst-kix_u4yb8nbjtsh3-6&gt;li:before{content:&quot;\0025cf  &quot;}ol.lst-kix_94mysn7p9quk-1.start{counter-reset:lst-ctn-kix_94mysn7p9quk-1 0}.lst-kix_u4yb8nbjtsh3-4&gt;li:before{content:&quot;\0025cb  &quot;}.lst-kix_u4yb8nbjtsh3-8&gt;li:before{content:&quot;\0025a0  &quot;}.lst-kix_94mysn7p9quk-0&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_94mysn7p9quk-0,decimal) &quot;. &quot;}.lst-kix_u4yb8nbjtsh3-7&gt;li:before{content:&quot;\0025cb  &quot;}.lst-kix_94mysn7p9quk-3&gt;li{counter-increment:lst-ctn-kix_94mysn7p9quk-3}.lst-kix_94mysn7p9quk-6&gt;li{counter-increment:lst-ctn-kix_94mysn7p9quk-6}ol.lst-kix_94mysn7p9quk-4.start{counter-reset:lst-ctn-kix_94mysn7p9quk-4 0}.lst-kix_94mysn7p9quk-2&gt;li{counter-increment:lst-ctn-kix_94mysn7p9quk-2}ol.lst-kix_94mysn7p9quk-7.start{counter-reset:lst-ctn-kix_94mysn7p9quk-7 0}.lst-kix_94mysn7p9quk-6&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_94mysn7p9quk-6,decimal) &quot;. &quot;}.lst-kix_94mysn7p9quk-8&gt;li{counter-increment:lst-ctn-kix_94mysn7p9quk-8}ul.lst-kix_oh8g77k3z2ge-7{list-style-type:none}ul.lst-kix_oh8g77k3z2ge-8{list-style-type:none}.lst-kix_94mysn7p9quk-5&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_94mysn7p9quk-5,lower-roman) &quot;. &quot;}ul.lst-kix_oh8g77k3z2ge-3{list-style-type:none}ul.lst-kix_oh8g77k3z2ge-4{list-style-type:none}.lst-kix_u4yb8nbjtsh3-0&gt;li:before{content:&quot;\0025cf  &quot;}ul.lst-kix_oh8g77k3z2ge-5{list-style-type:none}ul.lst-kix_oh8g77k3z2ge-6{list-style-type:none}.lst-kix_94mysn7p9quk-4&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_94mysn7p9quk-4,lower-latin) &quot;. &quot;}ul.lst-kix_oh8g77k3z2ge-0{list-style-type:none}.lst-kix_u4yb8nbjtsh3-1&gt;li:before{content:&quot;\0025cb  &quot;}.lst-kix_u4yb8nbjtsh3-2&gt;li:before{content:&quot;\0025a0  &quot;}ul.lst-kix_oh8g77k3z2ge-1{list-style-type:none}.lst-kix_94mysn7p9quk-1&gt;li{counter-increment:lst-ctn-kix_94mysn7p9quk-1}ul.lst-kix_oh8g77k3z2ge-2{list-style-type:none}ol.lst-kix_94mysn7p9quk-0.start{counter-reset:lst-ctn-kix_94mysn7p9quk-0 0}.lst-kix_94mysn7p9quk-1&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_94mysn7p9quk-1,lower-latin) &quot;. &quot;}.lst-kix_94mysn7p9quk-3&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_94mysn7p9quk-3,decimal) &quot;. &quot;}.lst-kix_94mysn7p9quk-7&gt;li{counter-increment:lst-ctn-kix_94mysn7p9quk-7}.lst-kix_u4yb8nbjtsh3-3&gt;li:before{content:&quot;\0025cf  &quot;}.lst-kix_94mysn7p9quk-2&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_94mysn7p9quk-2,lower-roman) &quot;. &quot;}ul.lst-kix_u4yb8nbjtsh3-6{list-style-type:none}ul.lst-kix_u4yb8nbjtsh3-5{list-style-type:none}ul.lst-kix_u4yb8nbjtsh3-8{list-style-type:none}ul.lst-kix_u4yb8nbjtsh3-7{list-style-type:none}ul.lst-kix_u4yb8nbjtsh3-2{list-style-type:none}ul.lst-kix_u4yb8nbjtsh3-1{list-style-type:none}ol.lst-kix_94mysn7p9quk-3.start{counter-reset:lst-ctn-kix_94mysn7p9quk-3 0}ul.lst-kix_u4yb8nbjtsh3-4{list-style-type:none}ul.lst-kix_u4yb8nbjtsh3-3{list-style-type:none}li.li-bullet-0:before{margin-left:-18pt;white-space:nowrap;display:inline-block;min-width:18pt}ol.lst-kix_94mysn7p9quk-6.start{counter-reset:lst-ctn-kix_94mysn7p9quk-6 0}.lst-kix_94mysn7p9quk-7&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_94mysn7p9quk-7,lower-latin) &quot;. &quot;}.lst-kix_94mysn7p9quk-8&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_94mysn7p9quk-8,lower-roman) &quot;. &quot;}ul.lst-kix_u4yb8nbjtsh3-0{list-style-type:none}ol{margin:0;padding:0}table td,table th{padding:0}.c15{padding-top:20pt;padding-bottom:6pt;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c0{padding-top:0pt;padding-bottom:0pt;line-height:1.5;orphans:2;widows:2;text-align:left;height:11pt}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:&quot;Arial&quot;;font-style:normal}.c8{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:20pt;font-family:&quot;Arial&quot;;font-style:normal}.c5{color:#cc0000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:&quot;Courier New&quot;;font-style:normal}.c26{padding-top:18pt;padding-bottom:6pt;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c13{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:&quot;Arial&quot;;font-style:italic}.c2{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:&quot;Courier New&quot;;font-style:normal}.c3{padding-top:0pt;padding-bottom:0pt;line-height:1.5;orphans:2;widows:2;text-align:left}.c10{color:#000000;text-decoration:none;vertical-align:baseline;font-size:10pt;font-style:normal}.c7{color:#000000;text-decoration:none;vertical-align:baseline;font-size:11pt;font-style:normal}.c11{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline}.c22{color:#000000;text-decoration:none;vertical-align:baseline;font-style:normal}.c23{font-weight:400;font-size:16pt;font-family:&quot;Arial&quot;}.c19{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c4{font-weight:400;font-family:&quot;Courier New&quot;}.c20{padding:0;margin:0}.c12{color:inherit;text-decoration:inherit}.c17{margin-left:108pt;padding-left:0pt}.c14{margin-left:36pt;padding-left:0pt}.c21{margin-left:72pt;padding-left:0pt}.c16{font-style:italic}.c25{background-color:#f4cccc}.c6{font-weight:700}.c18{font-family:&quot;Courier New&quot;}.c9{font-size:9pt}.c24{font-size:10pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:&quot;Arial&quot;}p{margin:0;color:#000000;font-size:11pt;font-family:&quot;Arial&quot;}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}&lt;/style&gt;&lt;/head&gt;&lt;body class=&quot;c19&quot;&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c6&quot;&gt;TL;DR:&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;How to make a tiny kernel race window really large even on kernels without &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;CONFIG_PREEMPT&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;:&lt;/span&gt;&lt;/p&gt;&lt;ul style=&quot;padding: 0;&quot; class=&quot;c20 lst-kix_u4yb8nbjtsh3-0 start&quot;&gt;&lt;li style=&quot;margin-left: 46pt;&quot; class=&quot;c3 c14 li-bullet-0&quot;&gt;&lt;span&gt;use&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&amp;nbsp;a cache miss to widen the race window a little bit&lt;/span&gt;&lt;/li&gt;&lt;li style=&quot;margin-left: 46pt;&quot; class=&quot;c3 c14 li-bullet-0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;make a timerfd expire in that window (which will run in an interrupt handler - in other words, in hardirq context)&lt;/span&gt;&lt;/li&gt;&lt;li style=&quot;margin-left: 46pt;&quot; class=&quot;c3 c14 li-bullet-0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;make sure that the wakeup triggered by the timerfd has to churn through 50000 waitqueue items created by epoll&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c1&quot;&gt;Racing one thread against a timer also avoids accumulating timing variations from two threads in each race attempt - hence the title. On the other hand, it also means you now have to deal with how hardware timers actually work, which introduces its own flavors of weird timing variations.&lt;/span&gt;&lt;/p&gt;&lt;h1 class=&quot;c15&quot; id=&quot;h.au2flcod0vb&quot;&gt;&lt;span class=&quot;c8&quot;&gt;Introduction&lt;/span&gt;&lt;/h1&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;I recently discovered a race condition (&lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;&lt;a class=&quot;c121&quot; href=&quot;https://crbug.com/project-zero/2247&quot;&gt;https://crbug.com/project-zero/2247&lt;/a&gt;&lt;/span&gt;&lt;span&gt;) in the Linux kernel.&lt;/span&gt;&lt;span&gt;&amp;nbsp;(While trying to explain to someone how &lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;&lt;a class=&quot;c121&quot; href=&quot;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=cbcf01128d0a92e131bd09f1688fe032480b65ca&quot;&gt;the fix for CVE-2021-0920&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;worked - I was explaining why the Unix GC is now safe, and then got confused because I couldn&amp;#39;t actually figure out why it&amp;#39;s safe after that fix, eventually realizing that it actually isn&amp;#39;t safe.) It&amp;#39;s a fairly narrow race window, so I was wondering whether it could be hit with a small number of attempts - especially on kernels that aren&amp;#39;t built with &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;CONFIG_PREEMPT&lt;/span&gt;&lt;span&gt;, which would make it possible to preempt a thread with another thread, &lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;&lt;a class=&quot;c121&quot; href=&quot;https://static.sched.com/hosted_files/lsseu2019/04/LSSEU2019%20-%20Exploiting%20race%20conditions%20on%20Linux.pdf#page=12&quot;&gt;as I described at LSSEU2019&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;This is a writeup of how I managed to hit the race on a normal Linux desktop kernel, with a hit rate somewhere around 30% if the proof of concept has been tuned for the specific machine. I didn&amp;#39;t do a full exploit though, I stopped at getting evidence of use-after-free (UAF) accesses (with the help of a very large file descriptor table and &lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;&lt;a class=&quot;c121&quot; href=&quot;https://lwn.net/Articles/819834/&quot;&gt;userfaultfd&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;, which might not be available to normal users depending on system configuration) because that&amp;#39;s the part I was curious about.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c6&quot;&gt;This also demonstrates that even very small race conditions can still be exploitable if someone sinks enough time into writing an exploit, so be careful if you dismiss very small race windows as unexploitable or don&amp;#39;t treat such issues as security bugs.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;The UAF reproducer is &lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;&lt;a class=&quot;c121&quot; href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=2247#c6&quot;&gt;in our bugtracker&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;.&lt;/span&gt;&lt;/p&gt;&lt;h1 class=&quot;c15&quot; id=&quot;h.qtcj62oowcyh&quot;&gt;&lt;span class=&quot;c8&quot;&gt;The bug&lt;/span&gt;&lt;/h1&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;In the UNIX domain socket garbage collection code (which is needed to deal with reference loops formed by UNIX&lt;/span&gt;&lt;span&gt;&amp;nbsp;domain sockets&lt;/span&gt;&lt;span&gt;&amp;nbsp;that use &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;SCM_RIGHTS&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&amp;nbsp;file descriptor passing), the kernel tries to figure out whether it can account for all references to some file by comparing the file&amp;#39;s refcount with the number of references from inflight SKBs (socket buffers). If they are equal, it assumes that the UNIX domain sockets subsystem effectively has exclusive access to the file because it owns all references.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;(The same pattern also appears for files as an optimization in &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;__fdget_pos()&lt;/span&gt;&lt;span&gt;, see &lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;&lt;a class=&quot;c121&quot; href=&quot;https://lore.kernel.org/lkml/CAG48ez1pnatAB095dnbrn9LbuQe4+ENwh-WEW36pM40ozhpruw@mail.gmail.com/&quot;&gt;this LKML thread&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;.)&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;The problem is that &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;struct file&lt;/span&gt;&lt;span&gt;&amp;nbsp;can also be referenced from an RCU read-side critical section (which you can&amp;#39;t detect by looking at the refcount), and such an RCU reference can be upgraded into a refcounted reference using &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;get_file_rcu()&lt;/span&gt;&lt;span&gt;&amp;nbsp;/ &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;get_file_rcu_many()&lt;/span&gt;&lt;span&gt;&amp;nbsp;by &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;__fget_files()&lt;/span&gt;&lt;span&gt;&amp;nbsp;as long as the refcount is non-zero. For example, when this happens in the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;dup()&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&amp;nbsp;syscall, the resulting reference will then be installed in the FD table and be available for subsequent syscalls.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;When the garbage collector (GC) believes that it has exclusive access to a file, it will perform operations on that file that violate the locking rules used in normal socket-related syscalls such as &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;recvmsg()&lt;/span&gt;&lt;span&gt;&amp;nbsp;- &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;unix_stream_read_generic()&lt;/span&gt;&lt;span&gt;&amp;nbsp;assumes that queued SKBs can only be removed under the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;-&amp;gt;iolock&lt;/span&gt;&lt;span&gt;&amp;nbsp;mutex, but the GC removes queued SKBs without using that mutex. (Thanks to Xingyu Jin for explaining that to me.)&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;One way of looking at this bug is that the GC is working correctly - here&amp;#39;s a state diagram showing some of the possible states of a &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;struct file&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;, with more specific states nested under less specific ones and with the state transition in the GC marked:&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;/p&gt;
  
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgKajtxfGAZhXanWS7kcvJozqQU2jozVQGIZdgex6_IRhp9jWHiJiL2KQddxH7Ma02d5sqhnXROh1PacqksZu3sA7-zjwh3ES8E8fQ7Jza8lu2claui1T9xYN3wrgv4J9yMFxbrUIAGiouvy4GGq-J69qROIjIITzvNpMQtJpljanHvTgd4xgrhZfRt/s641/image19.png&quot; style=&quot;display: block; padding: 1em 0;text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgKajtxfGAZhXanWS7kcvJozqQU2jozVQGIZdgex6_IRhp9jWHiJiL2KQddxH7Ma02d5sqhnXROh1PacqksZu3sA7-zjwh3ES8E8fQ7Jza8lu2claui1T9xYN3wrgv4J9yMFxbrUIAGiouvy4GGq-J69qROIjIITzvNpMQtJpljanHvTgd4xgrhZfRt/s641/image19.png&quot; border=&quot;0&quot; alt=&quot;All relevant states are RCU-accessible. An RCU-accessible object can have either a zero refcount or a positive refcount. Objects with a positive refcount can be either live or owned by the garbage collector. When the GC attempts to grab a file, it transitions from the state &amp;quot;live&amp;quot; to the state &amp;quot;owned by GC&amp;quot; by getting exclusive ownership of all references to the file.&quot; style=&quot;max-height: 750; max-width: 600px;&quot;title=&quot;All relevant states are RCU-accessible. An RCU-accessible object can have either a zero refcount or a positive refcount. Objects with a positive refcount can be either live or owned by the garbage collector. When the GC attempts to grab a file, it transitions from the state &amp;quot;live&amp;quot; to the state &amp;quot;owned by GC&amp;quot; by getting exclusive ownership of all references to the file.&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;While &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;__fget_files()&lt;/span&gt;&lt;span&gt;&amp;nbsp;is making an incorrect assumption about the state of the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;struct file&lt;/span&gt;&lt;span&gt;&amp;nbsp;while it is trying to narrow down its possible states - it checks whether &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;get_file_rcu()&lt;/span&gt;&lt;span&gt;&amp;nbsp;/ &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;get_file_rcu_many()&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&amp;nbsp;succeeds, which narrows the file&amp;#39;s state down a bit but not far enough:&lt;/span&gt;&lt;/p&gt;
  &lt;p class=&quot;c3&quot;&gt;&lt;/p&gt;
  
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgab4PkrLpvTF9E3D-nw5dSk35gvYRa--cQy0Oi60WjpbOjZbKE5zKNWa5ZEsuI-q7-UVZJrJD4Au-gTBF0p1VJSQ9gY75yIYL72zENk2Nt9RSQXBeJrIjtueSKK3xi3QN3a7dSAKXf-6JAL0RZXrnpCh3CdcC_QAyZK-hbbqXesvQQWlys0V-N3PE7/s638/image10%281%29.png&quot; style=&quot;display: block; padding: 1em 0;text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgab4PkrLpvTF9E3D-nw5dSk35gvYRa--cQy0Oi60WjpbOjZbKE5zKNWa5ZEsuI-q7-UVZJrJD4Au-gTBF0p1VJSQ9gY75yIYL72zENk2Nt9RSQXBeJrIjtueSKK3xi3QN3a7dSAKXf-6JAL0RZXrnpCh3CdcC_QAyZK-hbbqXesvQQWlys0V-N3PE7/s638/image10%281%29.png&quot; border=&quot;0&quot; alt=&quot;__fget_files() first uses get_file_rcu() to conditionally narrow the state of a file from &amp;quot;any RCU-accessible state&amp;quot; to &amp;quot;any refcounted state&amp;quot;. Then it has to narrow the state from &amp;quot;any refcounted state&amp;quot; to &amp;quot;live&amp;quot;, but instead it just assumes that they are equivalent.&quot; style=&quot;max-height: 750; max-width: 600px;&quot;title=&quot;__fget_files() first uses get_file_rcu() to conditionally narrow the state of a file from &amp;quot;any RCU-accessible state&amp;quot; to &amp;quot;any refcounted state&amp;quot;. Then it has to narrow the state from &amp;quot;any refcounted state&amp;quot; to &amp;quot;live&amp;quot;, but instead it just assumes that they are equivalent.&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;And this directly leads to how &lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;&lt;a class=&quot;c121&quot; href=&quot;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=054aa8d439b9185d4f5eb9a90282d1ce74772969&quot;&gt;the bug was fixed&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;(there&amp;#39;s &lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;&lt;a class=&quot;c121&quot; href=&quot;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=e386dfc56f837da66d00a078e5314bc8382fab83&quot;&gt;another follow-up patch&lt;/a&gt;&lt;/span&gt;&lt;span&gt;, but that one just tries to clarify the code and recoup some of the resulting performance loss) - the fix adds another check in &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;__fget_files()&lt;/span&gt;&lt;span&gt;&amp;nbsp;to properly narrow down the state of the file such that the file is guaranteed to be live&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;:&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEit6FDn3u3QdHshSHrZY09kFv_HtKUA7KlZZNKLc9t8Tx3uGJsC14qcx_IU691a14IUOH-OgfDjGpRLGh4Cwx4nlBfap1fCVOzT5PuOQXVv6e1-t79J46UO-uuUL_s6QzABu8JkrnEtyKV68GovV_o8Yem6E8Y9sl23usVNoXnoJ5xOhPZFVsconARG/s638/image16.png&quot; style=&quot;display: block; padding: 1em 0;text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEit6FDn3u3QdHshSHrZY09kFv_HtKUA7KlZZNKLc9t8Tx3uGJsC14qcx_IU691a14IUOH-OgfDjGpRLGh4Cwx4nlBfap1fCVOzT5PuOQXVv6e1-t79J46UO-uuUL_s6QzABu8JkrnEtyKV68GovV_o8Yem6E8Y9sl23usVNoXnoJ5xOhPZFVsconARG/s638/image16.png&quot; border=&quot;0&quot; alt=&quot;The fix is to properly narrow the state from &amp;quot;any refcounted state&amp;quot; to &amp;quot;live&amp;quot; by checking whether the file is still referenced by a file descriptor table entry.&quot; style=&quot;max-height: 750; max-width: 600px;&quot;title=&quot;The fix is to properly narrow the state from &amp;quot;any refcounted state&amp;quot; to &amp;quot;live&amp;quot; by checking whether the file is still referenced by a file descriptor table entry.&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c1&quot;&gt;The fix ensures that a live reference can only be derived from another live reference by comparing with an FD table entry, which is guaranteed to point to a live object.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c16&quot;&gt;[Sidenote: This scheme is similar to the one used for &lt;/span&gt;&lt;span class=&quot;c4 c16&quot;&gt;struct page&lt;/span&gt;&lt;span class=&quot;c16&quot;&gt;&amp;nbsp;- &lt;/span&gt;&lt;span class=&quot;c4 c16&quot;&gt;gup_pte_range()&lt;/span&gt;&lt;span class=&quot;c16&quot;&gt;&amp;nbsp;also uses the &amp;quot;grab pointer, increment refcount, recheck pointer&amp;quot; pattern for locklessly looking up a &lt;/span&gt;&lt;span class=&quot;c4 c16&quot;&gt;struct page&lt;/span&gt;&lt;span class=&quot;c16&quot;&gt;&amp;nbsp;from a page table entry while ensuring that new refcounted references can&amp;#39;t be created without holding an existing reference. This is really important for &lt;/span&gt;&lt;span class=&quot;c4 c16&quot;&gt;struct page&lt;/span&gt;&lt;span class=&quot;c16&quot;&gt;&amp;nbsp;because a page can be given back to the page allocator and reused while &lt;/span&gt;&lt;span class=&quot;c4 c16&quot;&gt;gup_pte_range()&lt;/span&gt;&lt;span class=&quot;c16&quot;&gt;&amp;nbsp;holds an uncounted reference to it - freed pages still have their &lt;/span&gt;&lt;span class=&quot;c4 c16&quot;&gt;struct page&lt;/span&gt;&lt;span class=&quot;c13&quot;&gt;, so there&amp;#39;s no need to delay freeing of the page - so if this went wrong, you&amp;#39;d get a page UAF.]&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;My initial suggestion was to instead fix the issue by changing how &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;unix_gc()&lt;/span&gt;&lt;span&gt;&amp;nbsp;ensures that it has exclusive access, letting it set the file&amp;#39;s refcount to zero to prevent turning RCU references into refcounted ones; this would have avoided adding any code in the hot &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;__fget_files()&lt;/span&gt;&lt;span&gt;&amp;nbsp;path, but it would have only fixed &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;unix_gc()&lt;/span&gt;&lt;span&gt;, not the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;__fdget_pos()&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&amp;nbsp;case I discovered later, so it&amp;#39;s probably a good thing this isn&amp;#39;t how it was fixed:&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;/p&gt;
  
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEj1Eob19v9RoctxBGUR4nmMSrJQJXvw-WjVihOxiudjG3ssu5WfL-YRXj_Gd99CifW1GplS3Yhwlc2WIc0-nPSOecYylZouk0zco24SgxUyyaFDps2wck4jVhWCcSbU7l3cFKB-hk4q3EOwwFJIgFKFSNnW9DgprGIMo5EKTMCt7SFnNdofQ9LnCjQu/s641/image5%283%29.png&quot; style=&quot;display: block; padding: 1em 0;text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEj1Eob19v9RoctxBGUR4nmMSrJQJXvw-WjVihOxiudjG3ssu5WfL-YRXj_Gd99CifW1GplS3Yhwlc2WIc0-nPSOecYylZouk0zco24SgxUyyaFDps2wck4jVhWCcSbU7l3cFKB-hk4q3EOwwFJIgFKFSNnW9DgprGIMo5EKTMCt7SFnNdofQ9LnCjQu/s641/image5%283%29.png&quot; border=&quot;0&quot; alt=&quot;&quot; style=&quot;max-height: 750; max-width: 600px;&quot;title=&quot;&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c16&quot;&gt;[Sidenote: In my original bug report I wrote that you&amp;#39;d have to wait an RCU grace period in the GC for this, but that wouldn&amp;#39;t be necessary as long as the GC ensures that a reaped socket&amp;#39;s refcount never becomes non-zero again.]&lt;/span&gt;&lt;/p&gt;&lt;h1 class=&quot;c15&quot; id=&quot;h.60irov9pzlh&quot;&gt;&lt;span class=&quot;c8&quot;&gt;The race&lt;/span&gt;&lt;/h1&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;There are multiple race conditions involved in exploiting this bug, but by far the trickiest to hit is that we have to race an operation into the tiny race window in the middle of &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;__fget_files()&lt;/span&gt;&lt;span&gt;&amp;nbsp;(which can e.g. be reached via &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;dup()&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;), between the file descriptor table lookup and the refcount increment:&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;static struct file *__fget_files(struct files_struct *files, unsigned int fd,&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;fmode_t mask, unsigned int refs)&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;{&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; struct file *file;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; rcu_read_lock();&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;loop:&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c4 c9&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; file = &lt;/span&gt;&lt;span class=&quot;c6 c18 c9&quot;&gt;files_lookup_fd_rcu(files, fd)&lt;/span&gt;&lt;span class=&quot;c4 c9&quot;&gt;; &lt;/span&gt;&lt;span class=&quot;c5&quot;&gt;// race window start&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if (file) {&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; /* File object ref couldn&amp;#39;t be taken.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;* dup2() atomicity guarantee is the reason&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;* we loop to catch the new file (or NULL pointer)&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;*/&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if (file-&amp;gt;f_mode &amp;amp; mask)&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; file = NULL;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c4 c9&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; else if (!&lt;/span&gt;&lt;span class=&quot;c6 c9 c18&quot;&gt;get_file_rcu_many(file, refs)&lt;/span&gt;&lt;span class=&quot;c4 c9&quot;&gt;) &lt;/span&gt;&lt;span class=&quot;c5&quot;&gt;// race window end&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; goto loop;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; rcu_read_unlock();&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return file;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;}&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;In this race window&lt;/span&gt;&lt;span&gt;, th&lt;/span&gt;&lt;span&gt;e file descriptor must be closed (to drop the FD&amp;#39;s reference to the file) and a &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;unix_gc()&lt;/span&gt;&lt;span&gt;&amp;nbsp;run must get past the point where it checks the file&amp;#39;s refcount (&amp;quot;&lt;/span&gt;&lt;span class=&quot;c4 c24&quot;&gt;total_refs = file_count(u-&amp;gt;sk.sk_socket-&amp;gt;file)&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&amp;quot;).&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c1&quot;&gt;In the Debian 5.10.0-9-amd64 kernel at version 5.10.70-1, that race window looks as follows:&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;lt;__fget_files+0x1e&amp;gt; cmp &amp;nbsp; &amp;nbsp;r10,rax&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;lt;__fget_files+0x21&amp;gt; sbb &amp;nbsp; &amp;nbsp;rax,rax&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;lt;__fget_files+0x24&amp;gt; mov &amp;nbsp; &amp;nbsp;rdx,QWORD PTR [r11+0x8]&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;lt;__fget_files+0x28&amp;gt; and &amp;nbsp; &amp;nbsp;eax,r8d&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;lt;__fget_files+0x2b&amp;gt; lea &amp;nbsp; &amp;nbsp;rax,[rdx+rax*8]&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c4 c9&quot;&gt;&amp;lt;__fget_files+0x2f&amp;gt; mov &amp;nbsp; &amp;nbsp;r12,QWORD PTR [rax] &lt;/span&gt;&lt;span class=&quot;c22 c6 c18 c9&quot;&gt;; RACE WINDOW START&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c22 c6 c18 c9&quot;&gt;; r12 now contains file*&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;lt;__fget_files+0x32&amp;gt; test &amp;nbsp; r12,r12&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;lt;__fget_files+0x35&amp;gt; je &amp;nbsp; &amp;nbsp; ffffffff812e3df7 &amp;lt;__fget_files+0x77&amp;gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;lt;__fget_files+0x37&amp;gt; mov &amp;nbsp; &amp;nbsp;eax,r9d&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c4 c9&quot;&gt;&amp;lt;__fget_files+0x3a&amp;gt; and &amp;nbsp; &amp;nbsp;eax,DWORD PTR [r12+0x44] &lt;/span&gt;&lt;span class=&quot;c6 c18 c9 c22&quot;&gt;; LOAD (for -&amp;gt;f_mode)&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;lt;__fget_files+0x3f&amp;gt; jne &amp;nbsp; &amp;nbsp;ffffffff812e3df7 &amp;lt;__fget_files+0x77&amp;gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c4 c9&quot;&gt;&amp;lt;__fget_files+0x41&amp;gt; mov &amp;nbsp; &amp;nbsp;rax,QWORD PTR [r12+0x38] &lt;/span&gt;&lt;span class=&quot;c22 c6 c18 c9&quot;&gt;; LOAD (for -&amp;gt;f_count)&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;lt;__fget_files+0x46&amp;gt; lea &amp;nbsp; &amp;nbsp;rdx,[r12+0x38]&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;lt;__fget_files+0x4b&amp;gt; test &amp;nbsp; rax,rax&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;lt;__fget_files+0x4e&amp;gt; je &amp;nbsp; &amp;nbsp; ffffffff812e3def &amp;lt;__fget_files+0x6f&amp;gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;lt;__fget_files+0x50&amp;gt; lea &amp;nbsp; &amp;nbsp;rcx,[rsi+rax*1]&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c4 c9&quot;&gt;&amp;lt;__fget_files+0x54&amp;gt; lock cmpxchg QWORD PTR [rdx],rcx &lt;/span&gt;&lt;span class=&quot;c6 c18 c9&quot;&gt;; RACE WINDOW END (on cmpxchg success)&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;As you can see, the race window is fairly small - around 12 instructions, assuming that the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;cmpxchg&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&amp;nbsp;succeeds.&lt;/span&gt;&lt;/p&gt;&lt;h1 class=&quot;c15&quot; id=&quot;h.dhdzjamcop53&quot;&gt;&lt;span class=&quot;c8&quot;&gt;Missing some cache&lt;/span&gt;&lt;/h1&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;Luckily for us, the race window contains the first few memory accesses to the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;struct file&lt;/span&gt;&lt;span&gt;; therefore, by making sure that the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;struct file&lt;/span&gt;&lt;span&gt;&amp;nbsp;is not present in the fastest CPU caches, we can widen the race window by as much time as the memory accesses take. The standard way to do this is to use &lt;/span&gt;&lt;span&gt;an eviction pattern&lt;/span&gt;&lt;span&gt;&amp;nbsp;/ &lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;&lt;a class=&quot;c121&quot; href=&quot;https://www.cs.columbia.edu/~simha/spyjs.ccs15.pdf&quot;&gt;eviction set&lt;/a&gt;&lt;/span&gt;&lt;span&gt;; but instead we can also make the cache line dirty on another core (see &lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;&lt;a class=&quot;c121&quot; href=&quot;https://dreamsofastone.blogspot.com/2016/02/row-hammer-java-script-and-mesi.html&quot;&gt;Anders Fogh&amp;#39;s blogpost&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;for more detail). (I&amp;#39;m not actually sure about the intricacies of how much latency this adds on different manufacturers&amp;#39; CPU cores, or on different CPU generations - I&amp;#39;ve only tested different versions of my proof-of-concept on Intel Skylake and Tiger Lake. Differences in cache &lt;/span&gt;&lt;span&gt;coherency&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&amp;nbsp;protocols or snooping might make a big difference.)&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;For the cache line containing the flags and refcount of a &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;struct file&lt;/span&gt;&lt;span&gt;, this can be done by, on another CPU, temporarily bumping its refcount up and then changing it back down, e.g. with &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;close(dup(fd))&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&amp;nbsp;(or just by accessing the FD in pretty much any way from a multithreaded process).&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;However, when we&amp;#39;re trying to hit the race in &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;__fget_files()&lt;/span&gt;&lt;span&gt;&amp;nbsp;via &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;dup()&lt;/span&gt;&lt;span&gt;, we don&amp;#39;t want any cache misses to occur before we hit the race window - that would slow us down and probably make us miss the race. To prevent that from happening, we can call &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;dup()&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&amp;nbsp;with a different FD number for a warm-up run shortly before attempting the race. Because we also want the relevant cache line in the FD table to be hot, we should choose the FD number for the warm-up run such that it uses the same cache line of the file descriptor table.&lt;/span&gt;&lt;/p&gt;&lt;h1 class=&quot;c15&quot; id=&quot;h.pfod85irgmms&quot;&gt;&lt;span class=&quot;c8&quot;&gt;An interruption&lt;/span&gt;&lt;/h1&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;Okay, a cache miss might be something like a few dozen or maybe hundred nanoseconds or so - that&amp;#39;s better, but it&amp;#39;s not &lt;/span&gt;&lt;span class=&quot;c16&quot;&gt;great&lt;/span&gt;&lt;span&gt;. What &lt;/span&gt;&lt;span&gt;else can we do to make this tiny&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&amp;nbsp;piece of code much slower to execute?&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;On Android, kernels normally set &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;CONFIG_PREEMPT&lt;/span&gt;&lt;span&gt;, which would&amp;#39;ve allowed abusing the scheduler to somehow interrupt the execution of this code. The way I&amp;#39;ve done this in the past was to give the victim thread a low scheduler priority and pin it to a specific CPU core together with another high-priority thread that is blocked on a &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;read()&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&amp;nbsp;syscall on an empty pipe (or eventfd); when data is written to the pipe from another CPU core, the pipe becomes readable, so the high-priority thread (which is registered on the pipe&amp;#39;s waitqueue) becomes schedulable, and an inter-processor interrupt (IPI) is sent to the victim&amp;#39;s CPU core to force it to enter the scheduler immediately.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;One problem with that approach, aside from its reliance on &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;CONFIG_PREEMPT&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;, is that any timing variability in the kernel code involved in sending the IPI makes it harder to actually preempt the victim thread in the right spot.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;(Thanks to the &lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;&lt;a class=&quot;c121&quot; href=&quot;https://xenproject.org/users/security/&quot;&gt;Xen security team&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&amp;nbsp;- I think the first time I heard the idea of using an interrupt to widen a race window might have been from them.)&lt;/span&gt;&lt;/p&gt;&lt;h1 class=&quot;c15&quot; id=&quot;h.u9iu9sq2l8r&quot;&gt;&lt;span&gt;Setting an alarm&lt;/span&gt;&lt;/h1&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;A better way to do this on an Android phone would be to trigger the scheduler not from an IPI, but from an expiring high-resolution timer on the same core&lt;/span&gt;&lt;span&gt;, although I didn&amp;#39;t get it to work (probably because my code was broken in unrelated ways)&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;High-resolution timers (hrtimers) are exposed through many userspace APIs. Even the timeout of &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;select()&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;pselect()&lt;/span&gt;&lt;span&gt;&amp;nbsp;uses an hrtimer, although this is an hrtimer that normally has some slack applied to it to allow batching it with timers that are scheduled to expire a bit later. An example of a non-hrtimer-based API is the timeout used for reading from a UNIX domain socket (and probably also other types of sockets?), which can be set via &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;SO_RCVTIMEO&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;The thing that makes hrtimers &amp;quot;high-resolution&amp;quot; is that they don&amp;#39;t just wait for the next periodic clock tick to arrive; instead, the expiration time of the next hrtimer on the CPU core is programmed into a hardware timer. So we could set an absolute hrtimer for some time in the future via something like &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;timer_settime()&lt;/span&gt;&lt;span&gt;&amp;nbsp;or &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;timerfd_settime()&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;, and then at exactly the programmed time, the hardware will raise an interrupt! We&amp;#39;ve made the timing behavior of the OS irrelevant for the second side of the race, the only thing that matters is the hardware! Or... well, almost...&lt;/span&gt;&lt;/p&gt;&lt;h1 class=&quot;c15&quot; id=&quot;h.v6rvu85hdhx3&quot;&gt;&lt;span class=&quot;c8&quot;&gt;[Sidenote] Absolute timers: Not quite absolute&lt;/span&gt;&lt;/h1&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;So we pick some absolute time at which we want to be interrupted, and tell the kernel using a syscall that accepts an absolute time, in nanoseconds. And then when that timer is the next one scheduled, the OS converts the absolute time to whatever clock base/scale the hardware timer is based on, and programs it into hardware. And the hardware usually supports programming timers with absolute time - e.g. on modern X86 (with &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;X86_FEATURE_TSC_DEADLINE_TIMER&lt;/span&gt;&lt;span&gt;), you can simply write an absolute Time Stamp Counter(TSC) deadline into &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;MSR_IA32_TSC_DEADLINE&lt;/span&gt;&lt;span&gt;, and when that deadline is reached, you get an interrupt. The situation on arm64 is similar, using the timer&amp;#39;s comparator register (&lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;CVAL&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;).&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;However, on both X86 and arm64, even though the clockevent subsystem is theoretically able to give absolute timestamps to clockevent drivers (via &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;-&amp;gt;set_next_ktime()&lt;/span&gt;&lt;span&gt;), the drivers instead only implement &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;-&amp;gt;set_next_event()&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;, which takes a relative time as argument. This means that the absolute timestamp has to be converted into a relative one, only to be converted back to absolute a short moment later. The delay between those two operations is essentially added to the timer&amp;#39;s expiration time.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;Luckily this didn&amp;#39;t really seem to be a problem for me; if it was, I would have tried to repeatedly call &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;timerfd_settime()&lt;/span&gt;&lt;span&gt;&amp;nbsp;shortly before the planned expiry time to ensure that the last time the hardware timer is programmed, the relevant code path is hot in the caches. (I did do some experimentation on arm64, where this seemed to &lt;/span&gt;&lt;span class=&quot;c16&quot;&gt;maybe&lt;/span&gt;&lt;span&gt;&amp;nbsp;help a tiny bit, but I didn&amp;#39;t really analyze it properly.)&lt;/span&gt;&lt;/p&gt;&lt;h1 class=&quot;c15&quot; id=&quot;h.dtkpi9hjsrrs&quot;&gt;&lt;span class=&quot;c8&quot;&gt;A really big list of things to do&lt;/span&gt;&lt;/h1&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;Okay, so all the stuff I said above would be helpful on an Android phone with &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;CONFIG_PREEMPT&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;, but what if we&amp;#39;re trying to target a normal desktop/server kernel that doesn&amp;#39;t have that turned on?&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c1&quot;&gt;Well, we can still trigger hrtimer interrupts the same way - we just can&amp;#39;t use them to immediately enter the scheduler and preempt the thread anymore. But instead of using the interrupt for preemption, we could just try to make the interrupt handler run for a really long time.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;Linux has the concept of a &amp;quot;timerfd&amp;quot;, which is a file descriptor that refers to a timer. You can e.g. call &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;read()&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&amp;nbsp;on a timerfd, and that operation will block until the timer has expired. Or you can monitor the timerfd using epoll, and it will show up as readable when the timer expires.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;When a timerfd becomes ready, all the timerfd&amp;#39;s waiters (including epoll watches), which are queued up in a linked list, are woken up via the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;wake_up()&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&amp;nbsp;path - just like when e.g. a pipe becomes readable. Therefore, if we can make the list of waiters really long, the interrupt handler will have to spend a lot of time iterating over that list.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;And for any waitqueue that is wired up to a file descriptor, it is fairly easy to add a ton of entries thanks to epoll. Epoll ties its watches to specific FD numbers, so if you duplicate an FD with hundreds of &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;dup()&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&amp;nbsp;calls, you can then use a single epoll instance to install hundreds of waiters on the file. Additionally, a single process can have lots of epoll instances. I used 500 epoll instances and 100 duplicate FDs, resulting in 50 000 waitqueue items.&lt;/span&gt;&lt;/p&gt;&lt;h1 class=&quot;c15&quot; id=&quot;h.gyrfobw0uoov&quot;&gt;&lt;span&gt;Measuring race outcomes&lt;/span&gt;&lt;/h1&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;A nice aspect of this race condition is that if you only hit the difficult race (&lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;close()&lt;/span&gt;&lt;span&gt;&amp;nbsp;the FD and run &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;unix_gc()&lt;/span&gt;&lt;span&gt;&amp;nbsp;while &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;dup()&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&amp;nbsp;is preempted between FD table lookup and refcount increment), no memory corruption happens yet, but you can observe that the GC has incorrectly removed a socket buffer (SKB) from the victim socket. Even better, if the race fails, you can also see in which direction it failed, as long as no FDs below the victim FD are unused:&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul style=&quot;padding: 0;&quot; class=&quot;c20 lst-kix_oh8g77k3z2ge-0 start&quot;&gt;&lt;li style=&quot;margin-left: 46pt;&quot; class=&quot;c3 c14 li-bullet-0&quot;&gt;&lt;span&gt;If &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;dup()&lt;/span&gt;&lt;span&gt;&amp;nbsp;returns -1, it was called too late / the interrupt happened too soon: The &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;file*&lt;/span&gt;&lt;span&gt;&amp;nbsp;was already gone from the FD table when &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;__fget_files()&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&amp;nbsp;tried to load it.&lt;/span&gt;&lt;/li&gt;&lt;li style=&quot;margin-left: 46pt;&quot; class=&quot;c3 c14 li-bullet-0&quot;&gt;&lt;span&gt;If &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;dup()&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&amp;nbsp;returns a file descriptor:&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul style=&quot;padding: 0;&quot; class=&quot;c20 lst-kix_oh8g77k3z2ge-1 start&quot;&gt;&lt;li style=&quot;margin-left: 46pt;&quot; class=&quot;c3 c21 li-bullet-0&quot;&gt;&lt;span&gt;If it returns an FD higher than the victim FD, this implies that the victim FD was only closed after &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;dup()&lt;/span&gt;&lt;span&gt;&amp;nbsp;had already elevated the refcount and allocated a new FD. This means &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;dup()&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&amp;nbsp;was called too soon / the interrupt happened too late.&lt;/span&gt;&lt;/li&gt;&lt;li style=&quot;margin-left: 46pt;&quot; class=&quot;c3 c21 li-bullet-0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;If it returns the old victim FD number:&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul style=&quot;padding: 0;&quot; class=&quot;c20 lst-kix_oh8g77k3z2ge-2 start&quot;&gt;&lt;li style=&quot;margin-left: 46pt;&quot; class=&quot;c3 c17 li-bullet-0&quot;&gt;&lt;span&gt;If &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;recvmsg()&lt;/span&gt;&lt;span&gt;&amp;nbsp;on the FD returned by &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;dup()&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&amp;nbsp;returns no data, it means the race succeeded: The GC wrongly removed the queued SKB.&lt;/span&gt;&lt;/li&gt;&lt;li style=&quot;margin-left: 46pt;&quot; class=&quot;c3 c17 li-bullet-0&quot;&gt;&lt;span&gt;If &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;recvmsg()&lt;/span&gt;&lt;span&gt;&amp;nbsp;returns data, the interrupt happened between the refcount increment and the allocation of a new FD. &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;dup()&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&amp;nbsp;was called a little bit too soon / the interrupt happened a little bit too late.&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c1&quot;&gt;Based on this, I repeatedly tested different timing offsets, using a spinloop with a variable number of iterations to skew the timing, and plotted what outcomes the race attempts had depending on the timing skew.&lt;/span&gt;&lt;/p&gt;&lt;h2 class=&quot;c26&quot; id=&quot;h.8e0qhvge46uf&quot;&gt;&lt;span class=&quot;c22 c23&quot;&gt;Results: Debian kernel, on Tiger Lake&lt;/span&gt;&lt;/h2&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c1&quot;&gt;I tested this on a Tiger Lake laptop, with the same kernel as shown in the disassembly. Note that &amp;quot;0&amp;quot; on the X axis is offset -300 ns relative to the timer&amp;#39;s programmed expiry.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;/p&gt;
  
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjxGtaXjmnSP7rJxi3RT9dLvnD5tGCVK-JFz8h3JVDjIDQ_2j-MpgyVqVJjh4zsldFBzadavB4_9nLx9KQ_fMSRHksfZM807yXykEgetDNCmeOzM21njTe8H9qH79Kz2MgqNL-5XWbxMy5fj9NamgjI15-5QZwJyn0NvHQwFuAw2z99_0lKwfrcWm4a/s580/image12.png&quot; style=&quot;display: block; padding: 1em 0;text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjxGtaXjmnSP7rJxi3RT9dLvnD5tGCVK-JFz8h3JVDjIDQ_2j-MpgyVqVJjh4zsldFBzadavB4_9nLx9KQ_fMSRHksfZM807yXykEgetDNCmeOzM21njTe8H9qH79Kz2MgqNL-5XWbxMy5fj9NamgjI15-5QZwJyn0NvHQwFuAw2z99_0lKwfrcWm4a/s580/image12.png&quot; border=&quot;0&quot; alt=&quot;This graph shows histograms of race attempt outcomes (too early, success, or too late), with the timing offset at which the outcome occurred on the X axis. The graph shows that depending on the timing offset, up to around 1/3 of race attempts succeeded.&quot; style=&quot;max-height: 750; max-width: 600px;&quot;title=&quot;This graph shows histograms of race attempt outcomes (too early, success, or too late), with the timing offset at which the outcome occurred on the X axis. The graph shows that depending on the timing offset, up to around 1/3 of race attempts succeeded.&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 class=&quot;c26&quot; id=&quot;h.9b7pdk4c8xov&quot;&gt;&lt;span&gt;Results: Other kernel, on Skylake&lt;/span&gt;&lt;/h2&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;/p&gt;
  
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjer2duEFeMBnPTJc3X7kT-FPCR1yx9UFEABwrTUxFKOs-gFkM_N-XnkWxPbhg31yka-2b5CFBBnOeAmrVAr41WfzKKPUBoF1dDBRpaX0tPGpu4w8p5aBZrxewYuGl1A_CDt0CojQqK44ue86r9PI8HnBtD2IR3NJDAI8O4TByvvx5fFe0sMdmHYZ6b/s652/image8%283%29.png&quot; style=&quot;display: block; padding: 1em 0;text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjer2duEFeMBnPTJc3X7kT-FPCR1yx9UFEABwrTUxFKOs-gFkM_N-XnkWxPbhg31yka-2b5CFBBnOeAmrVAr41WfzKKPUBoF1dDBRpaX0tPGpu4w8p5aBZrxewYuGl1A_CDt0CojQqK44ue86r9PI8HnBtD2IR3NJDAI8O4TByvvx5fFe0sMdmHYZ6b/s652/image8%283%29.png&quot; border=&quot;0&quot; alt=&quot;This graph shows similar histograms for a Skylake processor. The exact distribution is different, but again, depending on the timing offset, around 1/3 of race attempts succeeded.&quot; style=&quot;max-height: 750; max-width: 600px;&quot;title=&quot;This graph shows similar histograms for a Skylake processor. The exact distribution is different, but again, depending on the timing offset, around 1/3 of race attempts succeeded.&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;These measurements are from an older laptop with a Skylake CPU, running a different kernel. Here &amp;quot;0&amp;quot; on the X axis is offset -1 us relative to the timer. (T&lt;/span&gt;&lt;span&gt;hese timings are from a system that&amp;#39;s running a different kernel from &lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;the one shown above, but I don&amp;#39;t think that makes a difference.)&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c1&quot;&gt;The exact timings of course look different between CPUs, and they probably also change based on CPU frequency scaling? But still, if you know what the right timing is (or measure the machine&amp;#39;s timing before attempting to actually exploit the bug), you could hit this narrow race with a success rate of about 30%!&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;h1 class=&quot;c15&quot; id=&quot;h.5qhkbks84bg2&quot;&gt;&lt;span class=&quot;c8&quot;&gt;How important is the cache miss?&lt;/span&gt;&lt;/h1&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;The previous section showed that with the right timing, the race succeeds with a probability around 30% - but it doesn&amp;#39;t show whether the cache miss is actually important for that, or whether the race would still work fine without it. To verify that, I patched my test code to try to make the file&amp;#39;s &lt;/span&gt;&lt;span&gt;cache line hot (present in the cache) instead of cold (not present in the cache):&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c10 c4&quot;&gt;@@ -312,8 +312,10 @@&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c10 c4&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;}&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c10 c4&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c10 c4&quot;&gt;+#if 0&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c10 c4&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;// bounce socket&amp;#39;s file refcount over to other cpu&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c10 c4&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;pin_to(2);&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c10 c4&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;close(SYSCHK(dup(RESURRECT_FD+1-1)));&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c4 c10&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;pin_to(1);&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c10 c4&quot;&gt;+#endif&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c10 c4&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c4 c24&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;//printf(&amp;quot;setting timer\n&amp;quot;);&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c10 c4&quot;&gt;@@ -352,5 +354,5 @@&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c10 c4&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;close(loop_root);&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c10 c4&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;while (ts_is_in_future(spin_stop))&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c10 c4&quot;&gt;- &amp;nbsp; &amp;nbsp; &amp;nbsp;close(SYSCHK(dup(FAKE_RESURRECT_FD)));&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c10 c4&quot;&gt;+ &amp;nbsp; &amp;nbsp; &amp;nbsp;close(SYSCHK(dup(RESURRECT_FD)));&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c10 c4&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;while (ts_is_in_future(my_launch_ts)) /*spin*/;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c1&quot;&gt;With that patch, the race outcomes look like this on the Tiger Lake laptop:&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;/p&gt;
 
 
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEh7ABFgzZ7f8Mx5-JqYX4cjg23oXIbYr90vK32VO2evlWS2ADk3IM_Oh7AqguoJOEkF2A20aBhazVB5YqC7w5HgdmW73YqBhepK02B_EpBU0MSmbSIanUrFQwZizZAyF1cp2UNMMfG2xd_Z5byu2kqFejEuzWJ26piIR-0qY_uSGlfSfYmfq9SvLp9Z/s659/image2%284%29.png&quot; style=&quot;display: block; padding: 1em 0;text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEh7ABFgzZ7f8Mx5-JqYX4cjg23oXIbYr90vK32VO2evlWS2ADk3IM_Oh7AqguoJOEkF2A20aBhazVB5YqC7w5HgdmW73YqBhepK02B_EpBU0MSmbSIanUrFQwZizZAyF1cp2UNMMfG2xd_Z5byu2kqFejEuzWJ26piIR-0qY_uSGlfSfYmfq9SvLp9Z/s659/image2%284%29.png&quot; border=&quot;0&quot; alt=&quot;This graph is a histogram of race outcomes depending on timing offset; it looks similar to the previous graphs, except that almost no race attempts succeed anymore.&quot; style=&quot;max-height: 750; max-width: 600px;&quot;title=&quot;This graph is a histogram of race outcomes depending on timing offset; it looks similar to the previous graphs, except that almost no race attempts succeed anymore.&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;h1 class=&quot;c15&quot; id=&quot;h.7bhmtfdoxeqe&quot;&gt;&lt;span class=&quot;c8&quot;&gt;But wait, those graphs make no sense!&lt;/span&gt;&lt;/h1&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c1&quot;&gt;If you&amp;#39;ve been paying attention, you may have noticed that the timing graphs I&amp;#39;ve been showing are really weird. If we were deterministically hitting the race in exactly the same way every time, the timing graph should look like this (looking just at the &amp;quot;too-early&amp;quot; and &amp;quot;too-late&amp;quot; cases for simplicity):&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;/p&gt;
  
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi6T1QCwcnTS3XMWs-pRes47xC-6ruTCFYUU9ZxoO-OYZs3BX3Je5ZxXllb-obFMJsGo9ueKu6y5e5CorRtrVbIHf4YIWAGrLV7Gz3wRS-QzF1UG3AxK__fRQ-PC6MkCnxH3dlKDG5ueJR8bITiorTkicLIhYJg910YC3fY5_m4sf64GYWtOnIPbKDE/s359/image6%283%29.png&quot; style=&quot;display: block; padding: 1em 0;text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi6T1QCwcnTS3XMWs-pRes47xC-6ruTCFYUU9ZxoO-OYZs3BX3Je5ZxXllb-obFMJsGo9ueKu6y5e5CorRtrVbIHf4YIWAGrLV7Gz3wRS-QzF1UG3AxK__fRQ-PC6MkCnxH3dlKDG5ueJR8bITiorTkicLIhYJg910YC3fY5_m4sf64GYWtOnIPbKDE/s359/image6%283%29.png&quot; border=&quot;0&quot; alt=&quot;A sketch of a histogram of race outcomes where the &amp;quot;too early&amp;quot; outcome suddenly drops from 100% probability to 0% probability, and a bit afterwards, the &amp;quot;too late&amp;quot; outcome jumps from 0% probability to 100%&quot; style=&quot;max-height: 750; max-width: 600px;&quot;title=&quot;A sketch of a histogram of race outcomes where the &amp;quot;too early&amp;quot; outcome suddenly drops from 100% probability to 0% probability, and a bit afterwards, the &amp;quot;too late&amp;quot; outcome jumps from 0% probability to 100%&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c1&quot;&gt;Sure, maybe there is some microarchitectural state that is different between runs, causing timing variations - cache state, branch predictor state, frequency scaling, or something along those lines -, but a small number of discrete events that haven&amp;#39;t been accounted for should be adding steps to the graph. (If you&amp;#39;re mathematically inclined, you can model that as the result of a convolution of the ideal timing graph with the timing delay distributions of individual discrete events.) For two unaccounted events, that might look like this:&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;/p&gt;
  

 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEj2Y9DapfGb7NRtbz3j0aEQlA4SLZgk1ttbc7rS-0ZPbgerGJlqgk-N_Bna8AfcY8J2HBaHo2VJ0x-AR5n9lvivwdjmzKkITRIcypqYSBkOXB0DpavJ9dURyIfbA0u0D0KUOU1JD2pIH8KW2f8AQffaWluuQayXFq_8bleRLPfLZHmAkeLjFbJXxDVA/s359/image18.png&quot; style=&quot;display: block; padding: 1em 0;text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEj2Y9DapfGb7NRtbz3j0aEQlA4SLZgk1ttbc7rS-0ZPbgerGJlqgk-N_Bna8AfcY8J2HBaHo2VJ0x-AR5n9lvivwdjmzKkITRIcypqYSBkOXB0DpavJ9dURyIfbA0u0D0KUOU1JD2pIH8KW2f8AQffaWluuQayXFq_8bleRLPfLZHmAkeLjFbJXxDVA/s359/image18.png&quot; border=&quot;0&quot; alt=&quot;A sketch of a histogram of race outcomes where the &amp;quot;too early&amp;quot; outcome drops from 100% probability to 0% probability in multiple discrete steps, and overlapping that, the &amp;quot;too late&amp;quot; outcome goes up from 0% probability to 100% in multiple discrete steps&quot; style=&quot;max-height: 750; max-width: 600px;&quot;title=&quot;A sketch of a histogram of race outcomes where the &amp;quot;too early&amp;quot; outcome drops from 100% probability to 0% probability in multiple discrete steps, and overlapping that, the &amp;quot;too late&amp;quot; outcome goes up from 0% probability to 100% in multiple discrete steps&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c1&quot;&gt;But what the graphs are showing is more of a smooth, linear transition, like this:&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;/p&gt;
  
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjV2n4po9tRvp9j-aHeINv6S3q7YVcSdHocobXnfLZQnkg8kQqh2wx-Q8-gBX6MNFLgAibZwVoUQwOAX-HDCK3aGCRt8rroQtcmw4Kyl9JNoVJb_ldqhj5sVW7CtlA-HFMyI45HPDYfWJD-ck2NpU2ZFFh35gVzmekcAdtlUv3fGVZ8p_Muec3rMbDJ/s359/image13.png&quot; style=&quot;display: block; padding: 1em 0;text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjV2n4po9tRvp9j-aHeINv6S3q7YVcSdHocobXnfLZQnkg8kQqh2wx-Q8-gBX6MNFLgAibZwVoUQwOAX-HDCK3aGCRt8rroQtcmw4Kyl9JNoVJb_ldqhj5sVW7CtlA-HFMyI45HPDYfWJD-ck2NpU2ZFFh35gVzmekcAdtlUv3fGVZ8p_Muec3rMbDJ/s359/image13.png&quot; border=&quot;0&quot; alt=&quot;A sketch of a histogram of race outcomes where the &amp;quot;too early&amp;quot; outcome&amp;#39;s share linearly drops while the &amp;quot;too late&amp;quot; outcome&amp;#39;s share linearly rises&quot; style=&quot;max-height: 750; max-width: 600px;&quot;title=&quot;A sketch of a histogram of race outcomes where the &amp;quot;too early&amp;quot; outcome&amp;#39;s share linearly drops while the &amp;quot;too late&amp;quot; outcome&amp;#39;s share linearly rises&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c1&quot;&gt;And that seems to me like there&amp;#39;s still something fundamentally wrong. Sure, if there was a sufficiently large number of discrete events mixed together, the curve would eventually just look like a smooth smear - but it seems unlikely to me that there is such a large number of somewhat-evenly distributed random discrete events. And sure, we do get a small amount of timing inaccuracy from sampling the clock in a spinloop, but that should be bounded to the execution time of that spinloop, and the timing smear is far too big for that.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;So it looks like there is a source of randomness that isn&amp;#39;t a discrete event, but something that introduces a random amount of timing delay within some window. So I became suspicious of the hardware timer. The kernel is using &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;MSR_IA32_TSC_DEADLINE&lt;/span&gt;&lt;span&gt;, and the Intel SDM tells us that that thing is programmed with a TSC value, which makes it look as if the timer has very high granularity. But &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;MSR_IA32_TSC_DEADLINE&lt;/span&gt;&lt;span&gt;&amp;nbsp;is a newer mode of the LAPIC timer, and the older LAPIC timer modes were instead programmed in units of the APIC timer frequency. According to the &lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;&lt;a class=&quot;c121&quot; href=&quot;https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.pdf#page=378&quot;&gt;Intel SDM, Volume 3A&lt;/a&gt;&lt;/span&gt;&lt;span&gt;, section 10.5.4 &amp;quot;APIC Timer&amp;quot;, that is &amp;quot;&lt;/span&gt;&lt;span class=&quot;c16&quot;&gt;the processor&amp;rsquo;s bus clock or core crystal clock frequency (when TSC/core crystal clock ratio is enumerated in CPUID leaf 0x15) divided by the value specified in the divide configuration register&lt;/span&gt;&lt;span&gt;&amp;quot;. This frequency is significantly lower than the TSC frequency. So perhaps &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;MSR_IA32_TSC_DEADLINE&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&amp;nbsp;is actually just a front-end to the same old APIC timer?&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c1&quot;&gt;I tried to measure the difference between the programmed TSC value and when execution was actually interrupted (not when the interrupt handler starts running, but when the old execution context is interrupted - you can measure that if the interrupted execution context is just running RDTSC in a loop); that looks as follows:&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;/p&gt;
  
  
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhHjsv0uh_9jjLz2XaZ-i_TkybjySAwI8b6eQwNIwbayoTxJjdOu2hfPK9pBY4itBx_SY444RMWU9V2zf608IUUC8mO40y2hXVuK1EZwNRhWcntOwjHaHiel0ufzva2Ft9RGq86nDFohpKbamTnuz79vZ4WWJ1cMS0gbA8HUsygjshxfHmsXgIN_19y/s756/image11.png&quot; style=&quot;display: block; padding: 1em 0;text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhHjsv0uh_9jjLz2XaZ-i_TkybjySAwI8b6eQwNIwbayoTxJjdOu2hfPK9pBY4itBx_SY444RMWU9V2zf608IUUC8mO40y2hXVuK1EZwNRhWcntOwjHaHiel0ufzva2Ft9RGq86nDFohpKbamTnuz79vZ4WWJ1cMS0gbA8HUsygjshxfHmsXgIN_19y/s756/image11.png&quot; border=&quot;0&quot; alt=&quot;A graph showing noise. Delays from deadline TSC to last successful TSC read before interrupt look essentially random, in the range from around -130 to around 10.&quot; style=&quot;max-height: 750; max-width: 600px;&quot;title=&quot;A graph showing noise. Delays from deadline TSC to last successful TSC read before interrupt look essentially random, in the range from around -130 to around 10.&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;As you can see, the expiry of the hardware timer indeed adds a bunch of noise. The size of the timing difference is also very close to the crystal clock frequency - the TSC/core crystal clock ratio on this machine is 117. So I tried plotting the &lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;absolute&lt;/span&gt;&lt;span&gt;&amp;nbsp;TSC values at which execution was interrupted, &lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;modulo the TSC / core crystal clock ratio&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;, and got this:&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;/p&gt;
  
  
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjFD8Ox0LairxcMkyQuJrocYf7Cg33_jrE4AuhAPvbfMLm8jY8b_NFN9evyjlLXeLHhkfsji2bFNwE_--csZOKd_daBQJdJwKGbeKzLuRiXhGCze_zFELkzxl3dC69I7i4R9SQWgQG2Gv7QlLwdpAs7HRXNQJfCNB6nHh-_8LFvP03N71uMlw7nWoQB/s543/image9%282%29.png&quot; style=&quot;display: block; padding: 1em 0;text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjFD8Ox0LairxcMkyQuJrocYf7Cg33_jrE4AuhAPvbfMLm8jY8b_NFN9evyjlLXeLHhkfsji2bFNwE_--csZOKd_daBQJdJwKGbeKzLuRiXhGCze_zFELkzxl3dC69I7i4R9SQWgQG2Gv7QlLwdpAs7HRXNQJfCNB6nHh-_8LFvP03N71uMlw7nWoQB/s543/image9%282%29.png&quot; border=&quot;0&quot; alt=&quot;A graph showing a clear grouping around 0, roughly in the range -20 to 10, with some noise scattered over the rest of the graph.&quot; style=&quot;max-height: 750; max-width: 600px;&quot;title=&quot;A graph showing a clear grouping around 0, roughly in the range -20 to 10, with some noise scattered over the rest of the graph.&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;This confirms that &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;MSR_IA32_TSC_DEADLINE&lt;/span&gt;&lt;span&gt;&amp;nbsp;is (apparently) an interface that &lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;internally converts the specified TSC value into less granular bus clock / core crystal clock time&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;, at least on some Intel CPUs.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;But there&amp;#39;s still something really weird here: The TSC values at which execution seems to be interrupted were at &lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;negative&lt;/span&gt;&lt;span&gt;&amp;nbsp;offsets relative to the programmed expiry time, as if the timeouts were rounded &lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;down&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&amp;nbsp;to the less granular clock, or something along those lines. To get a better idea of how timer interrupts work, I measured on yet another system (an old Haswell CPU) with a patched kernel when execution is interrupted and when the interrupt handler starts executing relative to the programmed expiry time (and also plotted the difference between the two):&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;/p&gt;
  
  
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgxdpX4IgQCQuV9hIXWbVTSfVhyZ1LaNDfV6NUW0HRri_uI-OrUf0wuUK-SPm1gGO0NsqGPxN5WewnPIJ0FBaF7NSPfL0Nh7MQoGXk3YGgVPP2LwuTUz05Yy7DwKgUkxbQ0vJ5nWB0mlS2rPonc1p3wq11SKtzcpYzP_tnnWb65qW5Q4EGtrhz_7mwC/s928/image17.png&quot; style=&quot;display: block; padding: 1em 0;text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgxdpX4IgQCQuV9hIXWbVTSfVhyZ1LaNDfV6NUW0HRri_uI-OrUf0wuUK-SPm1gGO0NsqGPxN5WewnPIJ0FBaF7NSPfL0Nh7MQoGXk3YGgVPP2LwuTUz05Yy7DwKgUkxbQ0vJ5nWB0mlS2rPonc1p3wq11SKtzcpYzP_tnnWb65qW5Q4EGtrhz_7mwC/s928/image17.png&quot; border=&quot;0&quot; alt=&quot;A graph showing that the skid from programmed interrupt time to execution interruption is around -100 to -30 cycles, the skid to interrupt entry is around 360 to 420 cycles, and the time from execution interruption to interrupt entry has much less timing variance and is at around 440 cycles.&quot; style=&quot;max-height: 750px; max-width: 600px;&quot;title=&quot;A graph showing that the skid from programmed interrupt time to execution interruption is around -100 to -30 cycles, the skid to interrupt entry is around 360 to 420 cycles, and the time from execution interruption to interrupt entry has much less timing variance and is at around 440 cycles.&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c1&quot;&gt;So it looks like the CPU starts handling timer interrupts a little bit before the programmed expiry time, but interrupt handler entry takes so long (~450 TSC clock cycles?) that by the time the CPU starts executing the interrupt handler, the timer expiry time has long passed.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;Anyway, the important bit for us is that when the CPU interrupts execution due to timer expiry, it&amp;#39;s always at a LAPIC timer edge; and LAPIC timer edges happen when the TSC value is a multiple of the TSC/LAPIC clock ratio. An exploit that doesn&amp;#39;t take that into account and wrongly assumes that &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;MSR_IA32_TSC_DEADLINE&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&amp;nbsp;has TSC granularity will have its timing smeared by one LAPIC clock period, which can be something like 40ns.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c1&quot;&gt;The ~30% accuracy we could achieve with the existing PoC with the right timing is already not terrible; but if we control for the timer&amp;#39;s weirdness, can we do better?&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;The problem is that we are effectively launching the race with two timers that behave differently: One timer based on calling &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;clock_gettime()&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&amp;nbsp;in a loop (which uses the high-resolution TSC to compute a time), the other a hardware timer based on the lower-resolution LAPIC clock. I see two options to fix this:&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;c20 lst-kix_94mysn7p9quk-0 start&quot; start=&quot;1&quot;&gt;&lt;li style=&quot;margin-left: 46pt;&quot; class=&quot;c3 c14 li-bullet-0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;Try to ensure that the second timer is set at the start of a LAPIC clock period - that way, the second timer should hopefully behave exactly like the first (or have an additional fixed offset, but we can compensate for that).&lt;/span&gt;&lt;/li&gt;&lt;li style=&quot;margin-left: 46pt;&quot; class=&quot;c3 c14 li-bullet-0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;Shift the first timer&amp;#39;s expiry time down according to the distance from the second timer to the previous LAPIC clock period.&lt;/span&gt;&lt;/li&gt;&lt;/ol&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;(One annoyance with this is that while we can grab information on how wall/monotonic time is calculated from TSC from the vvar mapping used by the vDSO, the clock is subject to minuscule additional corrections at every clock tick, which occur every 4ms on standard distro kernels (with &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;CONFIG_HZ=250&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;) as long as any core is running.)&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c1&quot;&gt;I tried to see whether the timing graph would look nicer if I accounted for this LAPIC clock rounding and also used a custom kernel to cheat and control for possible skid introduced by the absolute-to-relative-and-back conversion of the expiry time (see further up), but that still didn&amp;#39;t help all that much.&lt;/span&gt;&lt;/p&gt;&lt;h1 class=&quot;c15&quot; id=&quot;h.na1zwzioj0fl&quot;&gt;&lt;span class=&quot;c8&quot;&gt;(No) surprise: clock speed matters&lt;/span&gt;&lt;/h1&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c1&quot;&gt;Something I should&amp;#39;ve thought about way earlier is that of course, clock speed matters. On newer Intel CPUs with P-states, the CPU is normally in control of its own frequency, and dynamically adjusts it as it sees fit; the OS just provides some hints.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;Linux has an interface that claims to tell you the &amp;quot;current frequency&amp;quot; of each CPU core in &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;/sys/devices/system/cpu/cpufreq/policy&amp;lt;n&amp;gt;/scaling_cur_freq&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;, but when I tried using that, I got a different &amp;quot;frequency&amp;quot; every time I read that file, which seemed suspicious.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;Looking at the implementation, it turns out that the value shown there is calculated in &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;arch_freq_get_on_cpu()&lt;/span&gt;&lt;span&gt;&amp;nbsp;and &lt;/span&gt;&lt;span&gt;its&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;span&gt;callees&lt;/span&gt;&lt;span&gt;&amp;nbsp;- the value is calculated on demand when the file is read, with results cached for around 10 milliseconds. The value is determined as the ratio between the deltas of &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;MSR_IA32_APERF&lt;/span&gt;&lt;span&gt;&amp;nbsp;and &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;MSR_IA32_MPERF&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&amp;nbsp;between the last read and the current one. So if you have some tool that is polling these values every few seconds and wants to show average clock frequency over that time, it&amp;#39;s probably a good way of doing things; but if you actually want the current clock frequency, it&amp;#39;s not a good fit.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c1&quot;&gt;I hacked a helper into my kernel that samples both MSRs twice in quick succession, and that gives much cleaner results. When I measure the clock speeds and timing offsets at which the race succeeds, the result looks like this (showing just two clock speeds; the Y axis is the number of race successes at the clock offset specified on the X axis and the frequency scaling specified by the color):&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;/p&gt;
  
  
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgteZAepQr9rN7W0YShZIs3QBtqs-9FAJ9uW2wTTH9PSXSXxRMnCwOr9Ystgmi4EfD8ikHkCF0gHIV6s0A1rnnEAHEkl-7cBgLOgmTeDgep0PDO6ukZa6bzFqxCi48yQ46s5iZqSNvx2Dn05XCyVgYnLtqsuUvgyCeYxSRF_eOg4-xFDa7bWKzUD676/s666/image1%20%281%29%281%29.png&quot; style=&quot;display: block; padding: 1em 0;text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgteZAepQr9rN7W0YShZIs3QBtqs-9FAJ9uW2wTTH9PSXSXxRMnCwOr9Ystgmi4EfD8ikHkCF0gHIV6s0A1rnnEAHEkl-7cBgLOgmTeDgep0PDO6ukZa6bzFqxCi48yQ46s5iZqSNvx2Dn05XCyVgYnLtqsuUvgyCeYxSRF_eOg4-xFDa7bWKzUD676/s666/image1%20%281%29%281%29.png&quot; border=&quot;0&quot; alt=&quot;A graph showing that the timing of successful race attempts depends on the CPU&amp;#39;s performance setting - at 11/28 performance, most successful race attempts occur around clock offset -1200 (in TSC units), while at 14/28 performance, most successful race attempts occur around clock offset -1000.&quot; style=&quot;max-height: 750; max-width: 600px;&quot;title=&quot;A graph showing that the timing of successful race attempts depends on the CPU&amp;#39;s performance setting - at 11/28 performance, most successful race attempts occur around clock offset -1200 (in TSC units), while at 14/28 performance, most successful race attempts occur around clock offset -1000.&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c1&quot;&gt;So clearly, dynamic frequency scaling has a huge impact on the timing of the race - I guess that&amp;#39;s to be expected, really.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;But even accounting for all this, the graph still looks kind of smooth, so clearly there is still something more that I&amp;#39;m missing - oh well. I decided to stop experimenting with the race&amp;#39;s timing at this point, since I didn&amp;#39;t want to sink too much time into it. (Or perhaps I actually just stopped because I got distracted by newer and shinier things?)&lt;/span&gt;&lt;/p&gt;&lt;h1 class=&quot;c15&quot; id=&quot;h.ktiklcw2yj2x&quot;&gt;&lt;span&gt;Causing a UAF&lt;/span&gt;&lt;/h1&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;Anyway, I could probably spend much more time trying to investigate the timing variations (and probably mostly bang my head against a wall because details of execution timing are really difficult to understand in detail, and to understand it completely, it might be necessary to use something like &lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;&lt;a class=&quot;c121&quot; href=&quot;https://gamozolabs.github.io/metrology/2019/08/19/sushi_roll.html&quot;&gt;Gamozo Labs&amp;#39; &amp;quot;Sushi Roll&amp;quot;&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&amp;nbsp;and then go through every single instruction in detail and compare the observations to the internal architecture of the CPU). Let&amp;#39;s not do that, and get back to how to actually exploit this bug!&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;To turn this bug into memory corruption, we have to abuse that the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;recvmsg()&lt;/span&gt;&lt;span&gt;&amp;nbsp;path assumes that SKBs on the receive queue are protected from deletion by the socket mutex while the GC actually deletes SKBs from the receive queue without touching the socket mutex. For that purpose, while the unix GC is running, we have to start a &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;recvmsg()&lt;/span&gt;&lt;span&gt;&amp;nbsp;call that looks up the victim SKB, block until the unix GC has freed the SKB, and then let &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;recvmsg()&lt;/span&gt;&lt;span&gt;&amp;nbsp;continue operating on the freed SKB. This is fairly straightforward - while it is a race, we can easily slow down &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;unix_gc()&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&amp;nbsp;for multiple milliseconds by creating lots of sockets that are not directly referenced from the FD table and have many tiny SKBs queued up - here&amp;#39;s a graph showing the unix GC execution time on my laptop, depending on the number of queued SKBs that the GC has to scan through:&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;/p&gt;
  
  
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiBiMkb5gF1P8Epsw3zNsmjcesB53u-1TWswpWkW-YPl9vBXPF116eQG2v-wx7Kv7Wvb8fcUCoxU5O6VJ5854OdJWXKoSzPxBvBp0atr1HLiSyB1SqvqBTxba28bREm610sKCoFN7kA2ABwWNcq_vbmkPnH7oKGIwRV8gYcxHQ2JoWPf0eIYmO6y1Rq/s833/image15.png&quot; style=&quot;display: block; padding: 1em 0;text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiBiMkb5gF1P8Epsw3zNsmjcesB53u-1TWswpWkW-YPl9vBXPF116eQG2v-wx7Kv7Wvb8fcUCoxU5O6VJ5854OdJWXKoSzPxBvBp0atr1HLiSyB1SqvqBTxba28bREm610sKCoFN7kA2ABwWNcq_vbmkPnH7oKGIwRV8gYcxHQ2JoWPf0eIYmO6y1Rq/s833/image15.png&quot; border=&quot;0&quot; alt=&quot;A graph showing the time spent per GC run depending on the number of queued SKBs. The relationship is roughly linear.&quot; style=&quot;max-height: 750; max-width: 600px;&quot;title=&quot;A graph showing the time spent per GC run depending on the number of queued SKBs. The relationship is roughly linear.&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;To turn this into a UAF, it&amp;#39;s also necessary to get past the following check near the end of &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;unix_gc()&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;:&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;/* All candidates should have been detached by now. */&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; BUG_ON(!list_empty(&amp;amp;gc_candidates));&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c4&quot;&gt;gc_candidates&lt;/span&gt;&lt;span&gt;&amp;nbsp;is a list that previously contained all sockets that were deemed to be unreachable by the GC. Then, the GC attempted to free all those sockets by eliminating their mutual references. If we manage to keep a reference to one of the sockets that the GC thought was going away, the GC detects that with the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;BUG_ON()&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;But we don&amp;#39;t actually need the victim SKB to reference a socket that the GC thinks is going away; in &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;scan_inflight()&lt;/span&gt;&lt;span&gt;, the GC targets any SKB with a socket that is marked &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;UNIX_GC_CANDIDATE&lt;/span&gt;&lt;span&gt;, meaning it just had to be &lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;a candidate&lt;/span&gt;&lt;span&gt;&amp;nbsp;for being scanned by the GC. So by making the victim SKB hold a reference to a socket that is not directly referenced from a file descriptor table, but is indirectly referenced by a file descriptor table through another socket, we can ensure that the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;BUG_ON()&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&amp;nbsp;won&amp;#39;t trigger.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;I extended &lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;&lt;a class=&quot;c121&quot; href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=2247#c6&quot;&gt;my reproducer&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;with this trick and some userfaultfd trickery to make &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;recv()&lt;/span&gt;&lt;span&gt;&amp;nbsp;run with the right timing. Nowadays you don&amp;#39;t necessarily get full access to userfaultfd as a normal user, but since I&amp;#39;m just trying to show the concept, and there are alternatives to userfaultfd&lt;/span&gt;&lt;span&gt;&amp;nbsp;(using FUSE or just slow disk access&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&amp;nbsp;that&amp;#39;s good enough for this blogpost.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;When a normal distro kernel is running normally, the UAF reproducer&amp;#39;s UAF accesses won&amp;#39;t actually be noticeable; but if you add the kernel command line flag &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;slub_debug=FP&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&amp;nbsp;(to enable SLUB&amp;#39;s poisoning and sanity checks), the reproducer quickly crashes twice, first with a poison dereference and then a poison overwrite detection, showing that one byte of the poison was incremented:&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;general protection fault, probably for non-canonical address 0x6b6b6b6b6b6b6b6b: 0000 [#1] SMP NOPTI&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;CPU: 1 PID: 2655 Comm: hardirq_loop Not tainted 5.10.0-9-amd64 #1 Debian 5.10.70-1&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;[...]&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;RIP: 0010:unix_stream_read_generic+0x72b/0x870&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;Code: fe ff ff 31 ff e8 85 87 91 ff e9 a5 fe ff ff 45 01 77 44 8b 83 80 01 00 00 85 c0 0f 89 10 01 00 00 49 8b 47 38 48 85 c0 74 23 &amp;lt;0f&amp;gt; bf 00 66 85 c0 0f 85 20 01 00 00 4c 89 fe 48 8d 7c 24 58 44 89&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;RSP: 0018:ffffb789027f7cf0 EFLAGS: 00010202&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;RAX: 6b6b6b6b6b6b6b6b RBX: ffff982d1d897b40 RCX: 0000000000000000&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;RDX: 6a0fe1820359dce8 RSI: ffffffffa81f9ba0 RDI: 0000000000000246&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;RBP: ffff982d1d897ea8 R08: 0000000000000000 R09: 0000000000000000&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;R10: 0000000000000000 R11: ffff982d2645c900 R12: ffffb789027f7dd0&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;R13: ffff982d1d897c10 R14: 0000000000000001 R15: ffff982d3390e000&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;FS: &amp;nbsp;00007f547209d740(0000) GS:ffff98309fa40000(0000) knlGS:0000000000000000&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;CS: &amp;nbsp;0010 DS: 0000 ES: 0000 CR0: 0000000080050033&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;CR2: 00007f54722cd000 CR3: 00000001b61f4002 CR4: 0000000000770ee0&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;PKRU: 55555554&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;Call Trace:&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;[...]&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;unix_stream_recvmsg+0x53/0x70&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;[...]&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;__sys_recvfrom+0x166/0x180&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;[...]&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;__x64_sys_recvfrom+0x25/0x30&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;do_syscall_64+0x33/0x80&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;entry_SYSCALL_64_after_hwframe+0x44/0xa9&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;[...]&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;---[ end trace 39a81eb3a52e239c ]---&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;=============================================================================&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;BUG skbuff_head_cache (Tainted: G &amp;nbsp; &amp;nbsp; &amp;nbsp;D &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;): Poison overwritten&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;-----------------------------------------------------------------------------&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;INFO: 0x00000000d7142451-0x00000000d7142451 @offset=68. First byte 0x6c instead of 0x6b&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;INFO: Slab 0x000000002f95c13c objects=32 used=32 fp=0x0000000000000000 flags=0x17ffffc0010200&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;INFO: Object 0x00000000ef9c59c8 @offset=0 fp=0x00000000100a3918&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;Object &amp;nbsp; 00000000ef9c59c8: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b &amp;nbsp;kkkkkkkkkkkkkkkk&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;Object &amp;nbsp; 0000000097454be8: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b &amp;nbsp;kkkkkkkkkkkkkkkk&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;Object &amp;nbsp; 0000000035f1d791: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b &amp;nbsp;kkkkkkkkkkkkkkkk&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;Object &amp;nbsp; 00000000af71b907: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b &amp;nbsp;kkkkkkkkkkkkkkkk&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c4 c9&quot;&gt;Object &amp;nbsp; 000000000d2d371e: 6b 6b 6b 6b &lt;/span&gt;&lt;span class=&quot;c6 c18 c9 c25&quot;&gt;6c&lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b &amp;nbsp;kkkklkkkkkkkkkkk&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;Object &amp;nbsp; 0000000000744b35: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b &amp;nbsp;kkkkkkkkkkkkkkkk&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;Object &amp;nbsp; 00000000794f2935: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b &amp;nbsp;kkkkkkkkkkkkkkkk&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;Object &amp;nbsp; 000000006dc06746: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b &amp;nbsp;kkkkkkkkkkkkkkkk&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;Object &amp;nbsp; 000000005fb18682: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b &amp;nbsp;kkkkkkkkkkkkkkkk&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;Object &amp;nbsp; 0000000072eb8dd2: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b &amp;nbsp;kkkkkkkkkkkkkkkk&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;Object &amp;nbsp; 00000000b5b572a9: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b &amp;nbsp;kkkkkkkkkkkkkkkk&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;Object &amp;nbsp; 0000000085d6850b: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b &amp;nbsp;kkkkkkkkkkkkkkkk&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;Object &amp;nbsp; 000000006346150b: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b &amp;nbsp;kkkkkkkkkkkkkkkk&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;Object &amp;nbsp; 000000000ddd1ced: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b a5 &amp;nbsp;kkkkkkkkkkkkkkk.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;Padding &amp;nbsp;00000000e00889a7: 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a &amp;nbsp;ZZZZZZZZZZZZZZZZ&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;Padding &amp;nbsp;00000000d190015f: 5a 5a 5a 5a 5a 5a 5a 5a &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;ZZZZZZZZ&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;CPU: 7 PID: 1641 Comm: gnome-shell Tainted: G &amp;nbsp; &amp;nbsp;B D &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 5.10.0-9-amd64 #1 Debian 5.10.70-1&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;[...]&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;Call Trace:&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;dump_stack+0x6b/0x83&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;check_bytes_and_report.cold+0x79/0x9a&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;check_object+0x217/0x260&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;[...]&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;alloc_debug_processing+0xd5/0x130&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;___slab_alloc+0x511/0x570&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;[...]&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;__slab_alloc+0x1c/0x30&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;kmem_cache_alloc_node+0x1f3/0x210&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;__alloc_skb+0x46/0x1f0&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;alloc_skb_with_frags+0x4d/0x1b0&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;sock_alloc_send_pskb+0x1f3/0x220&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;[...]&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;unix_stream_sendmsg+0x268/0x4d0&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;sock_sendmsg+0x5e/0x60&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;____sys_sendmsg+0x22e/0x270&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;[...]&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;___sys_sendmsg+0x75/0xb0&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;[...]&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;__sys_sendmsg+0x59/0xa0&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;do_syscall_64+0x33/0x80&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;entry_SYSCALL_64_after_hwframe+0x44/0xa9&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;[...]&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;FIX skbuff_head_cache: Restoring 0x00000000d7142451-0x00000000d7142451=0x6b&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;FIX skbuff_head_cache: Marking all objects used&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;RIP: 0010:unix_stream_read_generic+0x72b/0x870&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;Code: fe ff ff 31 ff e8 85 87 91 ff e9 a5 fe ff ff 45 01 77 44 8b 83 80 01 00 00 85 c0 0f 89 10 01 00 00 49 8b 47 38 48 85 c0 74 23 &amp;lt;0f&amp;gt; bf 00 66 85 c0 0f 85 20 01 00 00 4c 89 fe 48 8d 7c 24 58 44 89&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;RSP: 0018:ffffb789027f7cf0 EFLAGS: 00010202&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;RAX: 6b6b6b6b6b6b6b6b RBX: ffff982d1d897b40 RCX: 0000000000000000&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;RDX: 6a0fe1820359dce8 RSI: ffffffffa81f9ba0 RDI: 0000000000000246&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;RBP: ffff982d1d897ea8 R08: 0000000000000000 R09: 0000000000000000&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;R10: 0000000000000000 R11: ffff982d2645c900 R12: ffffb789027f7dd0&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;R13: ffff982d1d897c10 R14: 0000000000000001 R15: ffff982d3390e000&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;FS: &amp;nbsp;00007f547209d740(0000) GS:ffff98309fa40000(0000) knlGS:0000000000000000&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;CS: &amp;nbsp;0010 DS: 0000 ES: 0000 CR0: 0000000080050033&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c2&quot;&gt;CR2: 00007f54722cd000 CR3: 00000001b61f4002 CR4: 0000000000770ee0&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c4 c9&quot;&gt;PKRU: 55555554&lt;/span&gt;&lt;/p&gt;&lt;h1 class=&quot;c15&quot; id=&quot;h.pjkt5u3x5bd1&quot;&gt;&lt;span&gt;Conclusion(s)&lt;/span&gt;&lt;/h1&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c1&quot;&gt;Hitting a race can become easier if, instead of racing two threads against each other, you race one thread against a hardware timer to create a gigantic timing window for the other thread. Hence the title! On the other hand, it introduces extra complexity because now you have to think about how timers actually work, and turns out, time is a complicated concept...&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;This shows how at least some really tight races can still be hit and &lt;/span&gt;&lt;span&gt;we should treat them&lt;/span&gt;&lt;span&gt;&amp;nbsp;as security bugs, even if it seems like they&amp;#39;d be very hard to hit at first glance.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c1&quot;&gt;Also, precisely timing races is hard, and the details of how long it actually takes the CPU to get from one point to another are mysterious. (As not only exploit writers know, but also anyone who&amp;#39;s ever wanted to benchmark a performance-relevant change...)&lt;/span&gt;&lt;/p&gt;&lt;h1 class=&quot;c15&quot; id=&quot;h.adfta2d6xkv8&quot;&gt;&lt;span&gt;Appendix: How impatient are interrupts?&lt;/span&gt;&lt;/h1&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c1&quot;&gt;I did also play around with this stuff on arm64 a bit, and I was wondering: At what points do interrupts actually get delivered? Does an incoming interrupt force the CPU to drop everything immediately, or do inflight operations finish first? This gets particularly interesting on phones that contain two or three different types of CPUs mixed together.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;On a Pixel 4 (which has 4 slow in-order cores, 3 fast cores, and 1 faster core), I tried firing an interval timer at 100Hz (using &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;timer_create()&lt;/span&gt;&lt;span&gt;), with a signal handler that logs the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;PC&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&amp;nbsp;register, while running this loop:&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; 400680:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;91000442 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;add&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x2, x2, #0x1&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; 400684:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;91000421 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;add&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x1, x1, #0x1&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; 400688:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;9ac20820 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;udiv&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x0, x1, x2&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; 40068c:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;91006800 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;add&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x0, x0, #0x1a&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; 400690:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;91000400 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;add&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x0, x0, #0x1&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; 400694:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;91000442 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;add&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x2, x2, #0x1&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; 400698:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;91000421 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;add&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x1, x1, #0x1&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; 40069c:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;91000442 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;add&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x2, x2, #0x1&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; 4006a0:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;91000421 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;add&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x1, x1, #0x1&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; 4006a4:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;9ac20820 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;udiv&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x0, x1, x2&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; 4006a8:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;91006800 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;add&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x0, x0, #0x1a&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; 4006ac:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;91000400 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;add&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x0, x0, #0x1&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; 4006b0:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;91000442 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;add&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x2, x2, #0x1&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; 4006b4:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;91000421 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;add&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x1, x1, #0x1&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; 4006b8:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;91000442 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;add&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x2, x2, #0x1&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; 4006bc:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;91000421 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;add&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x1, x1, #0x1&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; 4006c0:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;17fffff0 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;b&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;400680 &amp;lt;main+0xe0&amp;gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c1&quot;&gt;The logged interrupt PCs had the following distribution on a slow in-order core:&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;/p&gt;
  
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEh79bjjrDomCArX8YgAAX47nW6vfXNUUi0_WFbvS4ivPBjbOugqTtH7OZ5ZdRU9RYiHBfKiyUTEJRZCBn_mFN_MP9-v0krZKVaEoVq6mGyqkqNjx0H-2YULQe5ONPIyVrjJ7XBXY0y2UM7IkZfUHUJiVR0XYGYcZrLmDGeAecRkHStfXAmSzGmsT20D/s1252/image3%286%29.png&quot; style=&quot;display: block; padding: 1em 0;text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEh79bjjrDomCArX8YgAAX47nW6vfXNUUi0_WFbvS4ivPBjbOugqTtH7OZ5ZdRU9RYiHBfKiyUTEJRZCBn_mFN_MP9-v0krZKVaEoVq6mGyqkqNjx0H-2YULQe5ONPIyVrjJ7XBXY0y2UM7IkZfUHUJiVR0XYGYcZrLmDGeAecRkHStfXAmSzGmsT20D/s1252/image3%286%29.png&quot; border=&quot;0&quot; alt=&quot;A histogram of PC register values, where most instructions in the loop have roughly equal frequency, the instructions after udiv instructions have twice the frequency, and two other instructions have zero frequency.&quot; style=&quot;max-height: 750; max-width: 600px;&quot;title=&quot;A histogram of PC register values, where most instructions in the loop have roughly equal frequency, the instructions after udiv instructions have twice the frequency, and two other instructions have zero frequency.&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c1&quot;&gt;and this distribution on a fast out-of-order core:&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;/p&gt;

 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjD-BHvjdNFWdHXsha29a8w8Yo62kCoCH7QlHdXcQQHNECyyTM2BdG2Yxy2DL5UBT-XRMVSWeQbYaUBgpbKeBeQPU7AXTyS9J9twZ7eC5TyvBSNtU1p6J5ulb8yaWVAH359IfKzzsI9g8z1hgfcEwhiP3k1LFo_G-dsXpXFLF4A0cyiRTs7yrPpa8ac/s1252/image7%283%29.png&quot; style=&quot;display: block; padding: 1em 0;text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjD-BHvjdNFWdHXsha29a8w8Yo62kCoCH7QlHdXcQQHNECyyTM2BdG2Yxy2DL5UBT-XRMVSWeQbYaUBgpbKeBeQPU7AXTyS9J9twZ7eC5TyvBSNtU1p6J5ulb8yaWVAH359IfKzzsI9g8z1hgfcEwhiP3k1LFo_G-dsXpXFLF4A0cyiRTs7yrPpa8ac/s1252/image7%283%29.png&quot; border=&quot;0&quot; alt=&quot;A histogram of PC register values, where the first instruction of the loop has very high frequency, the following 4 instructions have near-zero frequency, and the following instructions have low frequencies&quot; style=&quot;max-height: 750; max-width: 600px;&quot;title=&quot;A histogram of PC register values, where the first instruction of the loop has very high frequency, the following 4 instructions have near-zero frequency, and the following instructions have low frequencies&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;As always, out-of-order (OOO) cores make everything weird, and the start of the loop seems to somehow &amp;quot;provide cover&amp;quot; for the following instructions; but on the in-order core, we can see that more interrupts arrive &lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;after&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&amp;nbsp;the slow udiv instructions. So apparently, when one of those is executing while an interrupt arrives, it continues executing and doesn&amp;#39;t get aborted somehow?&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;With the following loop, which has a &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;LDR&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&amp;nbsp;instruction mixed in that accesses a memory location that is constantly being modified by another thread:&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; 4006a0:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;91000442 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;add&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x2, x2, #0x1&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; 4006a4:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;91000421 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;add&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x1, x1, #0x1&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; 4006a8:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;9ac20820 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;udiv&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x0, x1, x2&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; 4006ac:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;91006800 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;add&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x0, x0, #0x1a&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; 4006b0:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;91000400 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;add&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x0, x0, #0x1&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; 4006b4:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;91000442 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;add&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x2, x2, #0x1&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; 4006b8:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;91000421 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;add&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x1, x1, #0x1&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; 4006bc:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;91000442 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;add&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x2, x2, #0x1&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; 4006c0:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;91000421 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;add&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x1, x1, #0x1&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; 4006c4:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;9ac20820 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;udiv&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x0, x1, x2&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; 4006c8:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;91006800 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;add&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x0, x0, #0x1a&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; 4006cc:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;91000400 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;add&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x0, x0, #0x1&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; 4006d0:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;91000442 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;add&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x2, x2, #0x1&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; 4006d4:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;f9400061 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ldr&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x1, [x3]&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; 4006d8:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;91000421 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;add&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x1, x1, #0x1&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; 4006dc:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;91000442 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;add&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x2, x2, #0x1&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c4 c7&quot;&gt;&amp;nbsp; 4006e0:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;91000421 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;add&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x1, x1, #0x1&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; 4006e4:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;17ffffef &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;b&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;4006a0 &amp;lt;main+0x100&amp;gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c1&quot;&gt;the cache-missing loads obviously have a large influence on the timing. On the in-order core:&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;/p&gt;
  
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhd2RdxeFWLW-EaNH0BmFh0bR7cTAxUQWltgd1v4192uhqNBPjlZOfcAjPF11Bh4bFpMN0Qu2iMTSiYwz8nzNwvAEPfopJDb9ZP4PG-3FMTULgznbXTsX9y5PMie65S3L4EGX1tQ_7Be53ettw-tmsP8lhP8G_sDGIeq5DwC9dqN8Y7oAc3SNBz6Hrn/s1252/image4%285%29.png&quot; style=&quot;display: block; padding: 1em 0;text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhd2RdxeFWLW-EaNH0BmFh0bR7cTAxUQWltgd1v4192uhqNBPjlZOfcAjPF11Bh4bFpMN0Qu2iMTSiYwz8nzNwvAEPfopJDb9ZP4PG-3FMTULgznbXTsX9y5PMie65S3L4EGX1tQ_7Be53ettw-tmsP8lhP8G_sDGIeq5DwC9dqN8Y7oAc3SNBz6Hrn/s1252/image4%285%29.png&quot; border=&quot;0&quot; alt=&quot;A histogram of interrupt instruction pointers, showing that most interrupts are delivered with PC pointing to the instruction after the high-latency load instruction.&quot; style=&quot;max-height: 750; max-width: 600px;&quot;title=&quot;A histogram of interrupt instruction pointers, showing that most interrupts are delivered with PC pointing to the instruction after the high-latency load instruction.&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c1&quot;&gt;On the OOO core:&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;/p&gt;
  
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEihTJNVw4C-vyBUdzEIFRX4tkgjk9rcnZMnn6JEAUQ3LP-NZexmmNFvL1T8LyHtIPmAbMso2arHvB4eBjB81HHxWZgO-wfQpN_Afs48fmZvEVzysO2ov7kawLQFfjq1dJvD4t8oi_5ZnYklJx5MP3jbaDrMrtXeaQlIW6tjsRoYcywfbHt_3o-pd8Yc/s1297/image20.png&quot; style=&quot;display: block; padding: 1em 0;text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEihTJNVw4C-vyBUdzEIFRX4tkgjk9rcnZMnn6JEAUQ3LP-NZexmmNFvL1T8LyHtIPmAbMso2arHvB4eBjB81HHxWZgO-wfQpN_Afs48fmZvEVzysO2ov7kawLQFfjq1dJvD4t8oi_5ZnYklJx5MP3jbaDrMrtXeaQlIW6tjsRoYcywfbHt_3o-pd8Yc/s1297/image20.png&quot; border=&quot;0&quot; alt=&quot;A similar histogram as the previous one, except that an even larger fraction of interrupt PCs are after the high-latency load instruction.&quot; style=&quot;max-height: 750; max-width: 600px;&quot;title=&quot;A similar histogram as the previous one, except that an even larger fraction of interrupt PCs are after the high-latency load instruction.&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;What is interesting to me here is that the timer interrupts seem to again arrive &lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;after&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;&amp;nbsp;the slow load - implying that if an interrupt arrives while a slow memory access is in progress, the interrupt handler may not get to execute until the memory access has finished? (Unless maybe on the OOO core the interrupt handler can start speculating already? I wouldn&amp;#39;t really expect that, but could imagine it.)&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c1&quot;&gt;On an X86 Skylake CPU, we can do a similar test:&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; &amp;nbsp; 11b8:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;48 83 c3 01 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;add &amp;nbsp; &amp;nbsp;$0x1,%rbx&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; &amp;nbsp; 11bc:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;48 83 c0 01 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;add &amp;nbsp; &amp;nbsp;$0x1,%rax&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; &amp;nbsp; 11c0:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;48 01 d8 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;add &amp;nbsp; &amp;nbsp;%rbx,%rax&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; &amp;nbsp; 11c3:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;48 83 c3 01 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;add &amp;nbsp; &amp;nbsp;$0x1,%rbx&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; &amp;nbsp; 11c7:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;48 83 c0 01 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;add &amp;nbsp; &amp;nbsp;$0x1,%rax&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; &amp;nbsp; 11cb:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;48 01 d8 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;add &amp;nbsp; &amp;nbsp;%rbx,%rax&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; &amp;nbsp; 11ce:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;48 03 02 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;add &amp;nbsp; &amp;nbsp;(%rdx),%rax&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; &amp;nbsp; 11d1:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;48 83 c0 01 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;add &amp;nbsp; &amp;nbsp;$0x1,%rax&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; &amp;nbsp; 11d5:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;48 83 c3 01 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;add &amp;nbsp; &amp;nbsp;$0x1,%rbx&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; &amp;nbsp; 11d9:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;48 01 d8 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;add &amp;nbsp; &amp;nbsp;%rbx,%rax&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; &amp;nbsp; 11dc:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;48 83 c3 01 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;add &amp;nbsp; &amp;nbsp;$0x1,%rbx&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; &amp;nbsp; 11e0:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;48 83 c0 01 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;add &amp;nbsp; &amp;nbsp;$0x1,%rax&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; &amp;nbsp; 11e4:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;48 01 d8 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;add &amp;nbsp; &amp;nbsp;%rbx,%rax&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c7 c4&quot;&gt;&amp;nbsp; &amp;nbsp; 11e7:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;eb cf &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;jmp &amp;nbsp; &amp;nbsp;11b8 &amp;lt;main+0xf8&amp;gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span class=&quot;c1&quot;&gt;with a similar result:&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;/p&gt;
  
  
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEifbDV2Uu_gXT_0s8hOyj3wImUB1O17c9SHpIEkkmAEES8GbgyHlSaPjbESG6SBIbdPPp3sTDao1A_SAcs4CfmgljAY3wa8KKeIQ4Lsg_L0nXFQY-qWL_-vDGyQnSN3vvt2YUmWf2-5WS81VqprDiz5YMq94_k9r1iVRuArhgWcfNBHBU-HtzJrWmX8/s540/image14.png&quot; style=&quot;display: block; padding: 1em 0;text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEifbDV2Uu_gXT_0s8hOyj3wImUB1O17c9SHpIEkkmAEES8GbgyHlSaPjbESG6SBIbdPPp3sTDao1A_SAcs4CfmgljAY3wa8KKeIQ4Lsg_L0nXFQY-qWL_-vDGyQnSN3vvt2YUmWf2-5WS81VqprDiz5YMq94_k9r1iVRuArhgWcfNBHBU-HtzJrWmX8/s540/image14.png&quot; border=&quot;0&quot; alt=&quot;A histogram of interrupt instruction pointers, showing that almost all interrupts were delivered with RIP pointing to the instruction after the high-latency load.&quot; style=&quot;max-height: 750; max-width: 600px;&quot;title=&quot;A histogram of interrupt instruction pointers, showing that almost all interrupts were delivered with RIP pointing to the instruction after the high-latency load.&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c3&quot;&gt;&lt;span&gt;This means that &lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;if&lt;/span&gt;&lt;span&gt;&amp;nbsp;the first access to the file terminated our race window (which is not the case), we probably wouldn&amp;#39;t be able to win the race by making the access to the file slow - instead we&amp;#39;d have to slow down one of the operations before that. (But note that I have only tested simple loads, not stores or read-modify-write operations here.)&lt;/span&gt;&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='https://googleprojectzero.blogspot.com/feeds/2892029424446991022/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='https://googleprojectzero.blogspot.com/2022/03/racing-against-clock-hitting-tiny.html#comment-form' title='0 Comments'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/4838136820032157985/posts/default/2892029424446991022'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/4838136820032157985/posts/default/2892029424446991022'/><link rel='alternate' type='text/html' href='https://googleprojectzero.blogspot.com/2022/03/racing-against-clock-hitting-tiny.html' title='Racing against the clock -- hitting a tiny kernel race window'/><author><name>Anonymous</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/blank.gif'/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgKajtxfGAZhXanWS7kcvJozqQU2jozVQGIZdgex6_IRhp9jWHiJiL2KQddxH7Ma02d5sqhnXROh1PacqksZu3sA7-zjwh3ES8E8fQ7Jza8lu2claui1T9xYN3wrgv4J9yMFxbrUIAGiouvy4GGq-J69qROIjIITzvNpMQtJpljanHvTgd4xgrhZfRt/s72-c/image19.png" height="72" width="72"/><thr:total>0</thr:total></entry>