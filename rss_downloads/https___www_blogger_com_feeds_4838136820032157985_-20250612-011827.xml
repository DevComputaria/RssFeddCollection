<?xml version='1.0' encoding='UTF-8'?><?xml-stylesheet href="http://www.blogger.com/styles/atom.css" type="text/css"?><entry xmlns='http://www.w3.org/2005/Atom' xmlns:blogger='http://schemas.google.com/blogger/2008' xmlns:georss='http://www.georss.org/georss' xmlns:gd='http://schemas.google.com/g/2005' xmlns:thr='http://purl.org/syndication/thread/1.0'><id>tag:blogger.com,1999:blog-4838136820032157985.post-6291003668138377503</id><published>2021-01-19T09:28:00.005-08:00</published><updated>2022-08-24T11:27:05.976-07:00</updated><title type='text'>The State of State Machines</title><content type='html'>&lt;style type=&quot;text/css&quot;&gt;ol{margin:0;padding:0}table td,table th{padding:0}.c0{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:&quot;Arial&quot;;font-style:normal}.c1{padding-top:0pt;padding-bottom:0pt;line-height:1.5;orphans:2;widows:2;text-align:left;height:11pt}.c9{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:20pt;font-family:&quot;Arial&quot;;font-style:normal}.c8{padding-top:20pt;padding-bottom:6pt;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c2{padding-top:0pt;padding-bottom:0pt;line-height:1.5;orphans:2;widows:2;text-align:left}.c7{color:#000000;text-decoration:none;vertical-align:baseline;font-size:11pt;font-style:normal}.c5{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:left}.c4{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline}.c12{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c6{color:inherit;text-decoration:inherit}.c3{font-weight:400;font-family:&quot;Courier New&quot;}.c10{border:1px solid black;margin:5px}.c11{font-size:11pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:&quot;Arial&quot;}p{margin:0;color:#000000;font-size:11pt;font-family:&quot;Arial&quot;}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}&lt;/style&gt;&lt;/head&gt;&lt;body class=&quot;c12&quot;&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c0&quot;&gt;Posted by Natalie Silvanovich, Project Zero&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span&gt;On January 29, 2019, a serious &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;&lt;a class=&quot;c61&quot; href=&quot;https://support.apple.com/en-us/HT209520&quot;&gt;vulnerability&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;was discovered in Group FaceTime which allowed an attacker to call a target and force the call to connect without user interaction from the target, allowing the attacker to listen to the target&amp;rsquo;s surroundings without their knowledge or consent. The bug was remarkable in both its impact and mechanism. The ability to force a target device to transmit audio to an attacker device without gaining code execution was an unusual and possibly unprecedented impact of a vulnerability. Moreover, the vulnerability was a logic bug in the FaceTime calling state machine that could be exercised using only the user interface of the device. While this bug was soon fixed, the fact that such a serious and easy to reach vulnerability had occurred due to a logic bug in a calling state machine -- an attack scenario I had never seen considered on any platform -- made me wonder whether other state machines had similar vulnerabilities as well. This post describes my investigation into calling state machines of a number of messaging platforms, including Signal, JioChat, Mocha, Google Duo, and Facebook Messenger.&lt;/span&gt;&lt;/p&gt;&lt;h1 class=&quot;c8&quot; id=&quot;h.3tmt47nphsxu&quot;&gt;&lt;span class=&quot;c9&quot;&gt;WebRTC and State Machines&lt;/span&gt;&lt;/h1&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span&gt;The majority of video conferencing applications are implemented using &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;&lt;a class=&quot;c61&quot; href=&quot;https://webrtc.org/&quot;&gt;WebRTC&lt;/a&gt;&lt;/span&gt;&lt;span&gt;, which I&amp;rsquo;ve discussed in several past &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;&lt;a class=&quot;c61&quot; href=&quot;https://googleprojectzero.blogspot.com/2018/12/adventures-in-video-conferencing-part-1.html&quot;&gt;blog&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;&lt;a class=&quot;c61&quot; href=&quot;https://googleprojectzero.blogspot.com/2020/08/exploiting-android-messengers-part-1.html&quot;&gt;posts&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;. &amp;nbsp;WebRTC connections are created by exchanging call set-up information in Session Description Protocol (SDP) between peers, a process which is called signalling. Signalling is not implemented by WebRTC, which allows peers to exchange SDP in whatever secure communication message is available to them, usually WebSockets for web applications, and secure messaging for messaging applications.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c0&quot;&gt;There are a few types of SDP that can be exchanged by WebRTC peers. In a typical connection, the caller starts off by sending an SDP offer, and then the callee responds with an SDP answer. These messages contain most information that is needed to transmit and receive media, including codec support, encryption keys and much more. After the offer/answer exchange, peers can send SDP candidates to other peers. Candidates are potential network paths that the two peers can use to connect to each other, and SDP candidates contain information such as IP addresses and TURN servers. Peers usually send more than one candidate to a peer, and candidates can be sent at any time during a connection.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c0&quot;&gt;WebRTC connections maintain an internal state related to whether an offer or answer has been received and processed, however, applications that use WebRTC usually have to maintain their own state machine to manage the user state of the application. How the user state maps to the WebRTC state is a design choice made by the WebRTC integrator, which has both security and performance consequences. For example, some applications do not exchange any SDP until the callee user has interacted with the application to answer the call, meanwhile others set up the peer-to-peer connection, and start sending audio and video from caller to callee before the callee is even notified of the call.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span&gt;Regardless of design, transmitting audio or video from an input device must be directly enabled by application code using WebRTC. This is usually done using a feature called tracks. Every input device is considered a &amp;lsquo;track&amp;rsquo;, and each specific track must be added to a specific peer connection by calling &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;addTrack&lt;/span&gt;&lt;span&gt;&amp;nbsp;(or language equivalent) before audio or video is transmitted. Tracks can also be disabled, which is useful for implementing mute and camera-off features. Each track also has an &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;RTPSender&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;property that can be used to fine-tune the properties of transmission, which can also be used to disable audio or video transmission.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c0&quot;&gt;Theoretically, ensuring callee consent before audio or video transmission should be a fairly simple matter of waiting until the user accepts the call before adding any tracks to the peer connection. However, when I looked at real applications they enabled transmission in many different ways. Most of these led to vulnerabilities that allowed calls to be connected without interaction from the callee.&lt;/span&gt;&lt;/p&gt;&lt;h1 class=&quot;c8&quot; id=&quot;h.6wmphw3nmrvb&quot;&gt;&lt;span class=&quot;c9&quot;&gt;Signal Messenger&lt;/span&gt;&lt;/h1&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span&gt;I looked at &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;&lt;a class=&quot;c61&quot; href=&quot;https://signal.org/en/&quot;&gt;Signal &lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;in September 2019, and at that time, the application had a calling setup that is very similar to what is recommended in WebRTC documentation.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;/p&gt;
  
  &lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgw4TaE50xYcijlvNo_xJQLYpyxxtwClGiBzz6gPMH5-p_-9SWRaZYDb1rjBM1o1Dobh1BVFEnpFLUgMjtVqX3-GFOXLWCrkXYnEa0Jap_d57F0IQ2Dk_A-sy7ohzgiBY6HlgLgbTA1UOBwKzQhBhjMpwEL_D-P5Y1pQoyjgrYTm_UmNbKPw20KCR1v/s936/image2.jpg&quot; style=&quot;display: block; padding: 1em 0; text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgw4TaE50xYcijlvNo_xJQLYpyxxtwClGiBzz6gPMH5-p_-9SWRaZYDb1rjBM1o1Dobh1BVFEnpFLUgMjtVqX3-GFOXLWCrkXYnEa0Jap_d57F0IQ2Dk_A-sy7ohzgiBY6HlgLgbTA1UOBwKzQhBhjMpwEL_D-P5Y1pQoyjgrYTm_UmNbKPw20KCR1v/s936/image2.jpg&quot; border=&quot;0&quot; alt=&quot;&quot; style=&quot;max-height: 750; max-width: 600px;&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c0&quot;&gt;A peer-to-peer connection is established, and then the callee&amp;#39;s audio track is added to the connection when the callee accepts the call by interacting with the user interface. Then a message is sent to the caller via the peer-to-peer connection, telling it to also move to the connected state and add the track.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c0&quot;&gt;Unfortunately, the application didn&amp;rsquo;t check that the device receiving the connect message was the caller device, so it was possible to send a connect message from the caller device to the callee. This caused the audio call to connect, allowing the caller to hear the callee&amp;rsquo;s surroundings. I tested this bug by changing Signal&amp;rsquo;s open-source code to send the message and recompiling the attacking client.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span&gt;This &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;&lt;a class=&quot;c61&quot; href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=1943&quot;&gt;vulnerability&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;was fixed in the client in September 2019, and since then, Signal&amp;rsquo;s signalling code has been replaced by the ringrtc project, which uses a more conservative state machine.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c0&quot;&gt;This bug was purely in Signal&amp;rsquo;s code, and was not due to a misunderstanding of WebRTC functionality. The state machine design was largely effective requiring user consent to transmit audio, but a specific check was not implemented.&lt;/span&gt;&lt;/p&gt;&lt;h1 class=&quot;c8&quot; id=&quot;h.3u2e2up84373&quot;&gt;&lt;span class=&quot;c9&quot;&gt;JioChat and Mocha&lt;/span&gt;&lt;/h1&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span&gt;I accidentally found two very similar vulnerabilities in &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;&lt;a class=&quot;c61&quot; href=&quot;https://www.jio.com/en-in/apps/jio-chat&quot;&gt;JioChat&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;and &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;&lt;a class=&quot;c61&quot; href=&quot;https://play.google.com/store/apps/details?id=com.viettel.mocha.app&amp;hl=en_US&amp;gl=US&quot;&gt;Mocha&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;messengers in July 2020 while &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;&lt;a class=&quot;c61&quot; href=&quot;https://googleprojectzero.blogspot.com/2020/08/exploiting-android-messengers-part-3.html&quot;&gt;testing&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;whether a WebRTC exploit would work on them. They both had a similar signalling design, which was server-mediated.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;/p&gt;
  
  &lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhALzk-nRfa9rA4S6vUKZE2RewsOt0laQ0DFswIxhY2HMvrino7kcRM58-z7tJ16j3UxtlKPVRWQB-6EUSBNO4NrkQQaPJcg1Hai4uwGPxOU90abdyqK7Jme3PuuomxpAacH5IEATVeEyoiH809F6o0QRxtyH1AnseC_O4l96uemvBg6KmXPrVUnOsR/s960/image8.png&quot; style=&quot;display: block; padding: 1em 0; text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhALzk-nRfa9rA4S6vUKZE2RewsOt0laQ0DFswIxhY2HMvrino7kcRM58-z7tJ16j3UxtlKPVRWQB-6EUSBNO4NrkQQaPJcg1Hai4uwGPxOU90abdyqK7Jme3PuuomxpAacH5IEATVeEyoiH809F6o0QRxtyH1AnseC_O4l96uemvBg6KmXPrVUnOsR/s960/image8.png&quot; border=&quot;0&quot; alt=&quot;&quot; style=&quot;max-height: 750; max-width: 600px;&quot; /&gt;&lt;/a&gt; &lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c0&quot;&gt;The offer and answer are exchanged via the server, and then both the caller and the callee send their candidates to the server. The server then stores them until the callee interacts with their device and accepts the call. Then the peer-to-peer connection is created, and when WebRTC enters into its internal connected state, the track is added, causing audio and video to be transmitted.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span&gt;This design has a fundamental problem, as candidates can be optionally included in an SDP offer or answer. In that case, the peer-to-peer connection will start immediately, as the only thing preventing the connection in this design is the lack of candidates, which will in turn lead to transmission from input devices. I tested this by using Frida to add candidates to the offers created by each of these applications. I was able to cause JioChat to &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;&lt;a class=&quot;c61&quot; href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=2059&amp;q=jiochat&amp;can=1&quot;&gt;send audio&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;without user consent, and Mocha to &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;&lt;a class=&quot;c61&quot; href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=2064&amp;q=mocha&amp;can=1&quot;&gt;send audio and video&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;. Both of these vulnerabilities were fixed soon after they were filed by filtering SDP on the server.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c0&quot;&gt;These issues were caused by a misunderstanding of how WebRTC works coupled with an attempt to improve WebRTC performance with an unusual signalling design. Normally, WebRTC integrators have to decide whether to wait until the callee has answered the call to set up the peer-to-peer connection. Setting the connection up early improves performance and prevents the user from having to wait when they answer a call, but also greatly increases the remote attack surface of WebRTC. These applications tried to improve performance without the security cost with this design, but didn&amp;rsquo;t consider all the ways that WebRTC can start a peer-to-peer connection.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c0&quot;&gt;It is generally not a good idea for integrators to gate audio or video transmission on any WebRTC feature that is not adding or enabling tracks. To start, many WebRTC features are complex, so it is easy to make a mistake that allows audio or video to be transmitted. Also, if the feature that is gated on is not commonly-used or not a security feature, it could be poorly tested or changed in the future.&lt;/span&gt;&lt;/p&gt;&lt;h1 class=&quot;c8&quot; id=&quot;h.8htob0rs10i7&quot;&gt;&lt;span class=&quot;c9&quot;&gt;Duo&lt;/span&gt;&lt;/h1&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span&gt;I looked at &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;&lt;a class=&quot;c61&quot; href=&quot;https://duo.google.com/about/&quot;&gt;Google Duo&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;in September 2020. Duo&amp;rsquo;s signalling methodology is somewhat different from a lot of messengers because it supports a feature that allows the callee to preview the caller&amp;rsquo;s video before answering. So a one-way video stream needs to be set up before the call is answered.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;/p&gt;
  
  &lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjlIqg9LSArMHnHq5Y6L5T-VDIhewKKz1qGq7hTpWC9RCy9EpQv3VgrGP2-FgT4eP0EyOUhk7-i6Ory2s04YM4GNBfq_AomGmu0H9TSBuf7YLn0tZW0fBIBmyPQNTwJKB4Tp5-vYkdwxp3mLTHbSpT2oatXAIE1cYN_T1fVA9uEWbi1ykWIhQekvf0V/s929/image5.png&quot; style=&quot;display: block; padding: 1em 0; text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjlIqg9LSArMHnHq5Y6L5T-VDIhewKKz1qGq7hTpWC9RCy9EpQv3VgrGP2-FgT4eP0EyOUhk7-i6Ory2s04YM4GNBfq_AomGmu0H9TSBuf7YLn0tZW0fBIBmyPQNTwJKB4Tp5-vYkdwxp3mLTHbSpT2oatXAIE1cYN_T1fVA9uEWbi1ykWIhQekvf0V/s929/image5.png&quot; border=&quot;0&quot; alt=&quot;&quot; style=&quot;max-height: 750; max-width: 600px;&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span&gt;The image above shows the setup of the one-way video stream. Dotted lines represent asynchronous calls made using Java executors. The lack of transmission from callee to caller is enforced by two methods. First, the SDP offer contains the property &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;a=sendonly&lt;/span&gt;&lt;span&gt;&amp;nbsp;for video, which causes video to only be transmitted in one direction. Also, when the callee receives the offer from the caller,&lt;/span&gt;&lt;span&gt;&amp;nbsp;it adds the video track&lt;/span&gt;&lt;span&gt;&amp;nbsp;to the peer connection, but then disables it using the &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;RTPSender&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;property of the track (the audio track is not added or enabled until the user accepts the call).&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span&gt;Neither of these methods effectively prevents video from being transmitted from callee to caller. The SDP property is easy to get around because the caller provides the SDP to the callee, so it can be easily altered. Disabling the video track as soon as the offer is processed should work, except for the asynchronous design. Normally, the &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;setLocalDescription&lt;/span&gt;&lt;span&gt;&amp;nbsp;method (which processes the SDP offer) calls the callback &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;onSetSuccess&lt;/span&gt;&lt;span&gt;, and then sets up the peer-to-peer connection after the callback has finished. However, if the callback makes another asynchronous call, the guarantee that &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;onSetSuccess&lt;/span&gt;&lt;span&gt;&amp;nbsp;finishes before the connection is set up no longer holds, because the &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;setLocalDescription&lt;/span&gt;&lt;span&gt;&amp;nbsp;method only waits for the &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;onSetSuccess&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;thread to finish. This creates a race between disabling the video and setting up the connection, so in some situations, the callee could transmit a few video frames to the caller before transmission is disabled.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c0&quot;&gt;I tested this by using Frida to alter the SDP sent by the callee, and then I tried many methods to win the race. It turned out to be fairly hard to win, and I spent roughly two weeks trying to figure out how to slow down the video disable call enough to give the connection time to set up. I ended up sending multiple offers and adding candidates to the offers, which decreased the connection time, as the network connection was already established. Then I sent many messages that take a long time to process through the data channel of the peer-to-peer connection to slow down the disabling of the video track. Data messages are processed on the same thread queue as disabling the video track in Duo, so sending data messages filled up the queue that was needed to disable video with many other entries, delaying the track being disabled.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span&gt;This &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;&lt;a class=&quot;c61&quot; href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=2085&amp;q=duo&amp;can=1&quot;&gt;bug&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;was fixed in December 2020 by removing the asynchronous call from &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;onSetSuccess&lt;/span&gt;&lt;span&gt;. While Duo generally designed signalling in a way that is effective in preventing video transmission from callee to caller, implementing the design asynchronously introduced problems. Asynchronous signalling implementations are becoming more common on mobile applications, as there are many unpredictable situations in which WebRTC needs to wait on the network or a peer, and separating function calls into different threads means a delay in one call won&amp;rsquo;t affect unrelated functionality. However, asynchronous calls make it more difficult to model how a state machine will behave in all situations, so it is important to be cautious about adding asynchronous calls to WebRTC signalling. In this case, the asynchronous call to disable the video track added nothing in terms of performance, as there is no reason any of the calls made to disable the track could block, and &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;onSetSuccess&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;already runs in its own thread and can yield to higher priority threads. It&amp;rsquo;s important to balance the risk and benefit of asynchronous calls and not indiscriminately include them in an application.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;h1 class=&quot;c8&quot; id=&quot;h.5vosihqq3qnz&quot;&gt;&lt;span class=&quot;c9&quot;&gt;Facebook Messenger&lt;/span&gt;&lt;/h1&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span&gt;I looked at Facebook Messenger in October 2020. It was a fairly challenging target because of the amount of reverse engineering required. &lt;/span&gt;&lt;span&gt;Stepping back&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;a bit, WebRTC has bindings in several programming languages which allow it to be integrated into applications using that language. Most Android applications that integrate WebRTC use the Java bindings. This makes investigating signalling state machines fairly straightforward, as important Java functions, such as setLocalDescription (which processes offers and answers), addRemoteIceCandidate (which processes candidates) and addTrack (which adds tracks to connections) can be hooked in Frida and logged for analysis. It is also reasonably straightforward to change the behavior of the attacker device using these calls.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span&gt;Facebook Messenger does not use Java bindings to integrate WebRTC, instead it uses C++ bindings. Moreover, it statically links WebRTC to a larger library (librtcR20.so, which is likely the rsys library mentioned in this &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;&lt;a class=&quot;c61&quot; href=&quot;https://engineering.fb.com/2020/12/21/video-engineering/rsys/&quot;&gt;article&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;), so the symbols for calls to bindings get stripped, making them difficult to hook. In addition, Facebook Messenger serializes SDP into another format before it is transmitted, so it is difficult to determine how signalling works by monitoring traffic.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span&gt;I eventually realized that the only reasonable way to figure out how Facebook Messenger signalling works was to figure out its network protocol. Thankfully, Facebook has publicly &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;&lt;a class=&quot;c61&quot; href=&quot;https://engineering.fb.com/2014/02/20/open-source/under-the-hood-building-and-open-sourcing-fbthrift/&quot;&gt;stated&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;that they use &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;&lt;a class=&quot;c61&quot; href=&quot;https://github.com/facebook/fbthrift&quot;&gt;fbthrift&lt;/a&gt;&lt;/span&gt;&lt;span&gt;, a branch of thrift. I loaded the librtcR20.so library into IDA to see if I could find where it called into the thrift library, but while there were a few calls, it looked like the code was mostly statically linked. I eventually figured out that this is because thrift generates serialization code for every protocol implemented, so most of the serialization and deserialization code ends up compiled with the protocol processing code. So I decided to compile fbthrift, make a sample serializer and look at it in IDA, so I could get an impression of what compiled fbthrift serializers look like. I noticed that during serialization, members of an object are serialized by calling a method called &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;writeFieldBegin&lt;/span&gt;&lt;span&gt;. I also noticed that when this method is called, the field name is required, even though it is usually not included in the serialized output. So I looked for a function in librtcR20 that was very frequently called with different string parameters that seemed reasonable for field names. Not very many functions fulfilled that criteria, so I was able to identify &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;writeFieldBegin&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;. &lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;/p&gt;
  
  &lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjrmKaFy1ymTzoi-bJiEGxt6L0L8-vOE8r0k4MHr4FFLEf2IGT3uC_0TjGkje14dHlWXtbWMFG5GLd56dtZl-J2BQ_Ozw9LIkWboS0pLmKTlHdF2_qsBULPeRBR7yHJ7qLW69y_Mhwb_1GfFHS9waWYXC5s4bted14ANUWT20J-IWv3ux3S9_UIW7b_/s616/image1%281%29.png&quot; style=&quot;display: block; padding: 1em 0; text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjrmKaFy1ymTzoi-bJiEGxt6L0L8-vOE8r0k4MHr4FFLEf2IGT3uC_0TjGkje14dHlWXtbWMFG5GLd56dtZl-J2BQ_Ozw9LIkWboS0pLmKTlHdF2_qsBULPeRBR7yHJ7qLW69y_Mhwb_1GfFHS9waWYXC5s4bted14ANUWT20J-IWv3ux3S9_UIW7b_/s616/image1%281%29.png&quot; border=&quot;0&quot; alt=&quot;&quot; style=&quot;max-height: 750; max-width: 600px;&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c0&quot;&gt;At this point, I could find many places where objects are serialized, and needed to identify which one was the message used to set up WebRTC calls.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span&gt;Earlier, I&amp;rsquo;d noticed a method in the library called &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;P2PCall::OnP2PMessageFromPeer &lt;/span&gt;&lt;span&gt;(note that the symbol for this method is stripped, but the method name is logged when it is called). This seemed a likely place that a deserialized message would be processed. Searching for the string &amp;ldquo;P2PMessage&amp;rdquo;, I found the serialization code for a type called &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;P2PMessageRequest&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;. I assumed that this was where call setup messages were created.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span&gt;Thrift serialization code is generated based on class definitions in a thrift definition file. Based on the field names and types passed to &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;writeFieldBegin&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;, I was able to slowly reverse engineer the complete thrift definition for this type. It was tedious work, because the definition was fairly long, and the code is obfuscated in a way that makes register use inconsistent, so I wasn&amp;rsquo;t confident that any automated approach would be accurate.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c0&quot;&gt;Below is a sample of the serialization code.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;/p&gt;
  
  &lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEimMI3CnLo4OqZKYconRNWmnvvoDGXm9ncq32pyuG9oEUdnvy_fpDdy8V3vw8S3JjC13lP3ZVgOOXR9mkghBwJJqlAwl5nBemd6-HF_NbKUhjydQ4hL81Mp3feHVeG6ga9WhdsVsFYtPBA3kubUKGoY_EpBJbOqLl5cjxB2IFi9au8TgfuWiY6Or3sd/s558/image6.png&quot; style=&quot;display: block; padding: 1em 0; text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEimMI3CnLo4OqZKYconRNWmnvvoDGXm9ncq32pyuG9oEUdnvy_fpDdy8V3vw8S3JjC13lP3ZVgOOXR9mkghBwJJqlAwl5nBemd6-HF_NbKUhjydQ4hL81Mp3feHVeG6ga9WhdsVsFYtPBA3kubUKGoY_EpBJbOqLl5cjxB2IFi9au8TgfuWiY6Or3sd/s558/image6.png&quot; border=&quot;0&quot; alt=&quot;&quot; style=&quot;max-height: 750; max-width: 600px;&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span&gt;Notice that it writes two fields from an object of type &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;Extmap&lt;/span&gt;&lt;span&gt;. The first, named &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;, is a mandatory field. The function that writes the code is as follows.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;/p&gt;

  &lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgCc7RNKJ_ccDGj_Br7w9CJ9xBEeA70XbCkRCWcn_E4FD7HcEsEdMFSOuJnIePz7cyainfWQbcsuDbrzthSG2WQVO7z9AckH0mV3U19xjJ5CZPxrbMOsOIarAq_bWSKa-EuxlGKLYJwOtbA0DNB-r9QvOWoa7OAbeMX2pLY-O00PsJttFxGQIrRZ4G9/s416/image3%281%29.png&quot; style=&quot;display: block; padding: 1em 0; text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgCc7RNKJ_ccDGj_Br7w9CJ9xBEeA70XbCkRCWcn_E4FD7HcEsEdMFSOuJnIePz7cyainfWQbcsuDbrzthSG2WQVO7z9AckH0mV3U19xjJ5CZPxrbMOsOIarAq_bWSKa-EuxlGKLYJwOtbA0DNB-r9QvOWoa7OAbeMX2pLY-O00PsJttFxGQIrRZ4G9/s416/image3%281%29.png&quot; border=&quot;0&quot; alt=&quot;&quot; style=&quot;max-height: 750; max-width: 600px;&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c0&quot;&gt;The field identifier written is 1, and the field type is 8, which translates to i32 (32-bit integer). The second field is an optional field, and the registers to write it are set in the following code.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;/p&gt;
  
  &lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgBMn3ZkEDTrcaIyoWgxZPjKykeH3e4Q59eot5ZzWWU_R5d15Z7cBjCNUceCldtCHHvfsk0KC3Lmj1AfdlFy5gOTav3dCv59gDcC-zvYyIz9QuuMciuPBav4AOCLqxxCGLvC4fqet4R3lclN7LK4wAyonMa3O8wLCRhEIw0xpnNpv2hqYAV089dM4Dm/s291/image4%281%29.png&quot; style=&quot;display: block; padding: 1em 0; text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgBMn3ZkEDTrcaIyoWgxZPjKykeH3e4Q59eot5ZzWWU_R5d15Z7cBjCNUceCldtCHHvfsk0KC3Lmj1AfdlFy5gOTav3dCv59gDcC-zvYyIz9QuuMciuPBav4AOCLqxxCGLvC4fqet4R3lclN7LK4wAyonMa3O8wLCRhEIw0xpnNpv2hqYAV089dM4Dm/s291/image4%281%29.png&quot; border=&quot;0&quot; alt=&quot;&quot; style=&quot;max-height: 750; max-width: 600px;&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span&gt;This sets the field name to &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;uri&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;, the field identifier to 2, and the field type to 8 (also i32). All together, this code can be represented by the following thrift definition.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c7 c3&quot;&gt;```&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c3 c7&quot;&gt;struct Extmap{&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c7 c3&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1: i32 id&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c7 c3&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2: optional i32 uri&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c7 c3&quot;&gt;}&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c7 c3&quot;&gt;```&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span&gt;After similarly reverse engineering every field of the &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;P2PMessageRequest&lt;/span&gt;&lt;span&gt;&amp;nbsp;type, I had a complete thrift definition, available &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;&lt;a class=&quot;c61&quot; href=&quot;https://bugs.chromium.org/p/project-zero/issues/attachment?aid=469962&amp;signed_aid=P6IhymiSYdrgPEkUId-4yA==&quot;&gt;here&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span&gt;I did two things with this thrift definition. &amp;nbsp;First, I used it to determine the layout of the &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;P2PMessageRequest&lt;/span&gt;&lt;span&gt;&amp;nbsp;type in C++. This was extremely valuable, as it allowed me to load the struct definition into IDA with every single field named correctly. This made it much easier to understand how incoming messages are handled in &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;P2PCall::OnP2PMessageFromPeer&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;. This ended up being a bit of a process. fbthrift can generate C++ header files directly from a thrift definition, but these are very long and contain a lot of unnecessary definitions, and can not be processed by IDA. So I ended up compiling the generated source and loading it into IDA, and then exporting the structure definitions and importing them into another IDA instance where librtcR20.so was already loaded. A few fields had different sizes in my compilation versus Facebook&amp;rsquo;s, but it was close enough that I could get it to work with a few modifications.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c0&quot;&gt;Below is an example of code decompiled in IDA with the thrift definition imported, to give an idea of how much easier it makes it to understand the processing of the message object.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;/p&gt;
  
  &lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi7ROyTv6yiRF_rtghbp9S__hQYc7JzOJLyQyG0Ql7R0GvLJ1BW7wKyF-nXd8xQrP4c0Zhz22dGSjZRiGtUoNVYfsXlHKfhxTPRZzFTFNl_cvyZDiS_HBWPFt3QDOBaDc-lZxPgIYu1jN7oUvVsJsYKbhOzkTVp8jrVOwufRBRi72C8MpuSuz_K-XFk/s830/image9.png&quot; style=&quot;display: block; padding: 1em 0; text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi7ROyTv6yiRF_rtghbp9S__hQYc7JzOJLyQyG0Ql7R0GvLJ1BW7wKyF-nXd8xQrP4c0Zhz22dGSjZRiGtUoNVYfsXlHKfhxTPRZzFTFNl_cvyZDiS_HBWPFt3QDOBaDc-lZxPgIYu1jN7oUvVsJsYKbhOzkTVp8jrVOwufRBRi72C8MpuSuz_K-XFk/s830/image9.png&quot; border=&quot;0&quot; alt=&quot;&quot; style=&quot;max-height: 750; max-width: 600px;&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c0&quot;&gt;I was also able to decode and generate messages sent over the network. To do this, I generated the serialization code from the thrift definition in Python, as thrift supports code generation in many languages. Then, I was able to import this code when using Frida Python to hook functions in Facebook Messenger.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span&gt;Then I needed to find the code that handled incoming &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;P2PMessageRequest&lt;/span&gt;&lt;span&gt;&amp;nbsp;messages. Since these messages are handled by native code, meanwhile most Facebook messages are handled by Java code, I looked for a native call with an appropriate name. I found &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;com.facebook.webrtc.WebrtcEngine.onThriftMessageFromPeer&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;. I hooked this method with Frida, and fed its byte array parameter in the generated deserializer, and it decoded incoming messages.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span&gt;I found a similar method used to send thrift messages, &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;sendThriftToPeer&lt;/span&gt;&lt;span&gt;&amp;nbsp;(this method&amp;rsquo;s class name is obfuscated and changes in every version of Facebook Messenger, but it can be found by grepping the application&amp;rsquo;s smali). I was also able to hook this method, and alter its byte array parameter, to change a &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;P2PMessageRequest&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;message sent by Facebook Messenger.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span&gt;Now, I was able to understand Facebook Messenger&amp;rsquo;s signalling state machine. There are two different ways that signalling can occur, depending on where the user is signed into Facebook Messenger. If the user is signed in on multiple devices or browsers, very little happens before the callee interacts with their device. &lt;/span&gt;&lt;span&gt;The offer, answer and candidates are exchanged, but they are stored by the callee device and not processed until the callee user answers the call.&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;This makes sense, because Facebook Messenger doesn&amp;rsquo;t know what device to connect to otherwise.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c0&quot;&gt;If the callee is only signed in on a single device, the state machine is more interesting.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;/p&gt;
  
  &lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEijU44kzUTNuEiZ3K65ALKdmcEcOdBXpO8ZKBzEylUWCvxRDYeJvcbXLnDV-FJRPE8xkpy78o5UglHsKwC-Hg1mPOq7ITRLICvc2OllaHgfIBME5mAg9A29We4ngDePgIeNxJ39MJKV09qu8KXt_icFfIyb3aGebgtbwan1k9VUmsQbVi9G_hIsEiBa/s934/image7.png&quot; style=&quot;display: block; padding: 1em 0; text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEijU44kzUTNuEiZ3K65ALKdmcEcOdBXpO8ZKBzEylUWCvxRDYeJvcbXLnDV-FJRPE8xkpy78o5UglHsKwC-Hg1mPOq7ITRLICvc2OllaHgfIBME5mAg9A29We4ngDePgIeNxJ39MJKV09qu8KXt_icFfIyb3aGebgtbwan1k9VUmsQbVi9G_hIsEiBa/s934/image7.png&quot; border=&quot;0&quot; alt=&quot;&quot; style=&quot;max-height: 750; max-width: 600px;&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c0&quot;&gt;In this case, Facebook Messenger enables the track as soon as an offer is received, but alters the offer so that all outgoing streams are inactive. It then replaces the offer with one where they are active when the user interacts with the device.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c0&quot;&gt;I was concerned that there might be a way to bypass the alteration of the offer, but I looked at how this was done, and while I generally don&amp;rsquo;t recommend using anything other than adding or disabling tracks to disable input device transmission, it was fairly robust. The offer is altered after the SDP is decoded into an internal WebRTC object, and the changes are made directly to this object, which eliminates the possibility of parsing errors.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span&gt;However, looking at how incoming messages are handled, I noticed that many message types other than offers, answers and candidates are processed before the call is answered. One type that stood out was called &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;SdpUpdate&lt;/span&gt;&lt;span&gt;. When an &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;SdpUpdate&lt;/span&gt;&lt;span&gt;&amp;nbsp;message is received, the local offer or answer is updated by calling &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;setLocalDescription&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span&gt;This message type didn&amp;rsquo;t do anything when sent to the state machine above, as it is already storing SDP and waiting to call &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;setLocalDescription&lt;/span&gt;&lt;span&gt;. But in the situation where the user is logged into two devices, it caused &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;setLocalDescription&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;to be called and started the audio connection.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span&gt;It is not clear what the &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;SdpUpdate&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;message type is used for in Facebook Messenger. I tried many scenarios on my test devices, including network switchover, and was not able to generate one in normal use. Regardless, it is clear that it was not intended for this message type to be received before the call is answered. It is similar to the Signal bug described above, in that it is not related to the application&amp;rsquo;s use of WebRTC, but due to a missing check when handling input that can cause state transitions.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span&gt;This &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;&lt;a class=&quot;c61&quot; href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=2098&amp;q=label%3AFinder-natashenka&amp;can=1&amp;start=200&quot;&gt;vulnerability&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;&amp;nbsp;was fixed in November 2020 with server changes that prevent this message type from being sent before a call is connected.&lt;/span&gt;&lt;/p&gt;&lt;h1 class=&quot;c8&quot; id=&quot;h.8r897r2revb3&quot;&gt;&lt;span class=&quot;c9&quot;&gt;Other Applications&lt;/span&gt;&lt;/h1&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c0&quot;&gt;There were a few other applications I looked at and did not find problems with their state machines. I looked at Telegram in August 2020, right after video conferencing was added to the application. I did not find any problems, largely because the application does not exchange the offer, answer or candidates until the callee has answered the call. I looked at Viber in November 2020, and did not find any problems with their state machine, though challenges reverse engineering the application made this analysis less rigorous than the other applications I looked at.&lt;/span&gt;&lt;/p&gt;&lt;h1 class=&quot;c8&quot; id=&quot;h.zc0ddbgboimw&quot;&gt;&lt;span class=&quot;c9&quot;&gt;Discussion &lt;/span&gt;&lt;/h1&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c0&quot;&gt;The majority of calling state machines I investigated had logic vulnerabilities that allowed audio or video content to be transmitted from the callee to the caller without the callee&amp;rsquo;s consent. This is clearly an area that is often overlooked when securing WebRTC applications.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c0&quot;&gt;The majority of the bugs did not appear to be due to developer misunderstanding of WebRTC features. Instead, they were due to errors in how the state machines are implemented. That said, a lack of awareness of these types of issues was likely a factor. It is rare to find WebRTC documentation or tutorials that explicitly discuss the need for user consent when streaming audio or video from a user&amp;rsquo;s device.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c0&quot;&gt;Many of these state machines had needless complexity in how they handled call set-up, which was also a factor. Unnecessary threading, reliance on obscure features and large numbers of states and input types increase the likelihood of this type of vulnerability occurring in a signalling state machine.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c0&quot;&gt;It is also concerning to note that I did not look at any group calling features of these applications, and all the vulnerabilities reported were found in peer-to-peer calls. This is an area for future work that could reveal additional problems.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;h1 class=&quot;c8&quot; id=&quot;h.vabt8649d9j7&quot;&gt;&lt;span class=&quot;c9&quot;&gt;Conclusion&lt;/span&gt;&lt;/h1&gt;&lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c11&quot;&gt;I investigated the &lt;/span&gt;&lt;span&gt;signalling&lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;&amp;nbsp;state machines of seven video conferencing &lt;/span&gt;&lt;span&gt;applications &lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;and found five vulnerabilities that could allow a caller &lt;/span&gt;&lt;span class=&quot;c0&quot;&gt;device to force a callee device to transmit audio or video data. All these vulnerabilities have since been fixed. It is not clear why this is such a common problem, but a lack of awareness of these types of bugs as well as unnecessary complexity in signalling state machines is likely a factor. Signalling state machines are a concerning and under-investigated attack surface of video conferencing applications, and it is likely that more problems will be found with further research.&lt;/span&gt;&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='https://googleprojectzero.blogspot.com/feeds/6291003668138377503/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='https://googleprojectzero.blogspot.com/2021/01/the-state-of-state-machines.html#comment-form' title='0 Comments'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/4838136820032157985/posts/default/6291003668138377503'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/4838136820032157985/posts/default/6291003668138377503'/><link rel='alternate' type='text/html' href='https://googleprojectzero.blogspot.com/2021/01/the-state-of-state-machines.html' title='The State of State Machines'/><author><name>Anonymous</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/blank.gif'/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgw4TaE50xYcijlvNo_xJQLYpyxxtwClGiBzz6gPMH5-p_-9SWRaZYDb1rjBM1o1Dobh1BVFEnpFLUgMjtVqX3-GFOXLWCrkXYnEa0Jap_d57F0IQ2Dk_A-sy7ohzgiBY6HlgLgbTA1UOBwKzQhBhjMpwEL_D-P5Y1pQoyjgrYTm_UmNbKPw20KCR1v/s72-c/image2.jpg" height="72" width="72"/><thr:total>0</thr:total></entry>