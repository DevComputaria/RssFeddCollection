<?xml version='1.0' encoding='UTF-8'?><?xml-stylesheet href="http://www.blogger.com/styles/atom.css" type="text/css"?><entry xmlns='http://www.w3.org/2005/Atom' xmlns:blogger='http://schemas.google.com/blogger/2008' xmlns:georss='http://www.georss.org/georss' xmlns:gd='http://schemas.google.com/g/2005' xmlns:thr='http://purl.org/syndication/thread/1.0'><id>tag:blogger.com,1999:blog-4838136820032157985.post-5634534606665421566</id><published>2021-10-20T09:38:00.001-07:00</published><updated>2022-08-23T12:22:51.164-07:00</updated><title type='text'>Windows Exploitation Tricks: Relaying DCOM Authentication</title><content type='html'>&lt;style type=&quot;text/css&quot;&gt;.lst-kix_21eii7u3d36d-6&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_21eii7u3d36d-6,decimal) &quot;. &quot;}.lst-kix_4h5ag0d3tyrp-4&gt;li{counter-increment:lst-ctn-kix_4h5ag0d3tyrp-4}ol.lst-kix_21eii7u3d36d-8{list-style-type:none}ol.lst-kix_21eii7u3d36d-7{list-style-type:none}ol.lst-kix_21eii7u3d36d-0.start{counter-reset:lst-ctn-kix_21eii7u3d36d-0 0}ol.lst-kix_21eii7u3d36d-6{list-style-type:none}ol.lst-kix_21eii7u3d36d-5{list-style-type:none}.lst-kix_21eii7u3d36d-3&gt;li:before{content:&quot;(&quot; counter(lst-ctn-kix_21eii7u3d36d-3,decimal) &quot;) &quot;}ol.lst-kix_21eii7u3d36d-4{list-style-type:none}.lst-kix_21eii7u3d36d-7&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_21eii7u3d36d-7,lower-latin) &quot;. &quot;}ol.lst-kix_21eii7u3d36d-3{list-style-type:none}ol.lst-kix_4h5ag0d3tyrp-6.start{counter-reset:lst-ctn-kix_4h5ag0d3tyrp-6 0}.lst-kix_21eii7u3d36d-2&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_21eii7u3d36d-2,lower-roman) &quot;) &quot;}ol.lst-kix_21eii7u3d36d-2{list-style-type:none}ol.lst-kix_21eii7u3d36d-1{list-style-type:none}ol.lst-kix_21eii7u3d36d-7.start{counter-reset:lst-ctn-kix_21eii7u3d36d-7 0}ol.lst-kix_21eii7u3d36d-0{list-style-type:none}.lst-kix_21eii7u3d36d-0&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_21eii7u3d36d-0,decimal) &quot;) &quot;}ol.lst-kix_21eii7u3d36d-3.start{counter-reset:lst-ctn-kix_21eii7u3d36d-3 0}.lst-kix_21eii7u3d36d-8&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_21eii7u3d36d-8,lower-roman) &quot;. &quot;}.lst-kix_21eii7u3d36d-1&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_21eii7u3d36d-1,lower-latin) &quot;) &quot;}.lst-kix_21eii7u3d36d-3&gt;li{counter-increment:lst-ctn-kix_21eii7u3d36d-3}.lst-kix_4h5ag0d3tyrp-5&gt;li{counter-increment:lst-ctn-kix_4h5ag0d3tyrp-5}ol.lst-kix_21eii7u3d36d-6.start{counter-reset:lst-ctn-kix_21eii7u3d36d-6 0}ol.lst-kix_4h5ag0d3tyrp-3.start{counter-reset:lst-ctn-kix_4h5ag0d3tyrp-3 0}ol.lst-kix_4h5ag0d3tyrp-7.start{counter-reset:lst-ctn-kix_4h5ag0d3tyrp-7 0}.lst-kix_21eii7u3d36d-2&gt;li{counter-increment:lst-ctn-kix_21eii7u3d36d-2}.lst-kix_21eii7u3d36d-5&gt;li{counter-increment:lst-ctn-kix_21eii7u3d36d-5}.lst-kix_21eii7u3d36d-8&gt;li{counter-increment:lst-ctn-kix_21eii7u3d36d-8}ol.lst-kix_4h5ag0d3tyrp-0.start{counter-reset:lst-ctn-kix_4h5ag0d3tyrp-0 0}ol.lst-kix_21eii7u3d36d-8.start{counter-reset:lst-ctn-kix_21eii7u3d36d-8 0}ol.lst-kix_4h5ag0d3tyrp-4.start{counter-reset:lst-ctn-kix_4h5ag0d3tyrp-4 0}ol.lst-kix_21eii7u3d36d-2.start{counter-reset:lst-ctn-kix_21eii7u3d36d-2 0}.lst-kix_4h5ag0d3tyrp-0&gt;li{counter-increment:lst-ctn-kix_4h5ag0d3tyrp-0}.lst-kix_21eii7u3d36d-4&gt;li:before{content:&quot;(&quot; counter(lst-ctn-kix_21eii7u3d36d-4,lower-latin) &quot;) &quot;}.lst-kix_4h5ag0d3tyrp-6&gt;li{counter-increment:lst-ctn-kix_4h5ag0d3tyrp-6}.lst-kix_21eii7u3d36d-5&gt;li:before{content:&quot;(&quot; counter(lst-ctn-kix_21eii7u3d36d-5,lower-roman) &quot;) &quot;}.lst-kix_4h5ag0d3tyrp-3&gt;li{counter-increment:lst-ctn-kix_4h5ag0d3tyrp-3}ol.lst-kix_4h5ag0d3tyrp-6{list-style-type:none}ol.lst-kix_4h5ag0d3tyrp-7{list-style-type:none}ol.lst-kix_21eii7u3d36d-5.start{counter-reset:lst-ctn-kix_21eii7u3d36d-5 0}ol.lst-kix_4h5ag0d3tyrp-4{list-style-type:none}ol.lst-kix_4h5ag0d3tyrp-1.start{counter-reset:lst-ctn-kix_4h5ag0d3tyrp-1 0}ol.lst-kix_4h5ag0d3tyrp-5{list-style-type:none}.lst-kix_4h5ag0d3tyrp-7&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_4h5ag0d3tyrp-7,lower-latin) &quot;. &quot;}.lst-kix_21eii7u3d36d-6&gt;li{counter-increment:lst-ctn-kix_21eii7u3d36d-6}ol.lst-kix_4h5ag0d3tyrp-8.start{counter-reset:lst-ctn-kix_4h5ag0d3tyrp-8 0}.lst-kix_4h5ag0d3tyrp-1&gt;li{counter-increment:lst-ctn-kix_4h5ag0d3tyrp-1}ol.lst-kix_4h5ag0d3tyrp-8{list-style-type:none}.lst-kix_4h5ag0d3tyrp-4&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_4h5ag0d3tyrp-4,lower-latin) &quot;. &quot;}.lst-kix_4h5ag0d3tyrp-8&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_4h5ag0d3tyrp-8,lower-roman) &quot;. &quot;}.lst-kix_21eii7u3d36d-0&gt;li{counter-increment:lst-ctn-kix_21eii7u3d36d-0}.lst-kix_4h5ag0d3tyrp-3&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_4h5ag0d3tyrp-3,decimal) &quot;. &quot;}ol.lst-kix_4h5ag0d3tyrp-2{list-style-type:none}ol.lst-kix_4h5ag0d3tyrp-3{list-style-type:none}ol.lst-kix_4h5ag0d3tyrp-0{list-style-type:none}ol.lst-kix_4h5ag0d3tyrp-1{list-style-type:none}.lst-kix_4h5ag0d3tyrp-2&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_4h5ag0d3tyrp-2,lower-roman) &quot;. &quot;}.lst-kix_4h5ag0d3tyrp-7&gt;li{counter-increment:lst-ctn-kix_4h5ag0d3tyrp-7}ol.lst-kix_21eii7u3d36d-1.start{counter-reset:lst-ctn-kix_21eii7u3d36d-1 0}.lst-kix_4h5ag0d3tyrp-5&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_4h5ag0d3tyrp-5,lower-roman) &quot;. &quot;}.lst-kix_4h5ag0d3tyrp-8&gt;li{counter-increment:lst-ctn-kix_4h5ag0d3tyrp-8}.lst-kix_4h5ag0d3tyrp-6&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_4h5ag0d3tyrp-6,decimal) &quot;. &quot;}ol.lst-kix_21eii7u3d36d-4.start{counter-reset:lst-ctn-kix_21eii7u3d36d-4 0}.lst-kix_4h5ag0d3tyrp-2&gt;li{counter-increment:lst-ctn-kix_4h5ag0d3tyrp-2}li.li-bullet-0:before{margin-left:-18pt;white-space:nowrap;display:inline-block;min-width:18pt}ol.lst-kix_4h5ag0d3tyrp-5.start{counter-reset:lst-ctn-kix_4h5ag0d3tyrp-5 0}.lst-kix_21eii7u3d36d-4&gt;li{counter-increment:lst-ctn-kix_21eii7u3d36d-4}.lst-kix_21eii7u3d36d-7&gt;li{counter-increment:lst-ctn-kix_21eii7u3d36d-7}.lst-kix_4h5ag0d3tyrp-1&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_4h5ag0d3tyrp-1,lower-latin) &quot;. &quot;}.lst-kix_21eii7u3d36d-1&gt;li{counter-increment:lst-ctn-kix_21eii7u3d36d-1}.lst-kix_4h5ag0d3tyrp-0&gt;li:before{content:&quot;&quot; counter(lst-ctn-kix_4h5ag0d3tyrp-0,decimal) &quot;. &quot;}ol.lst-kix_4h5ag0d3tyrp-2.start{counter-reset:lst-ctn-kix_4h5ag0d3tyrp-2 0}ol{margin:0;padding:0}table td,table th{padding:0}.c31{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:468pt;border-top-color:#000000;border-bottom-style:solid}.c9{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:&quot;Arial&quot;;font-style:normal}.c23{padding-top:18pt;padding-bottom:6pt;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c0{padding-top:0pt;padding-bottom:0pt;line-height:1.5;orphans:2;widows:2;text-align:left;height:11pt}.c6{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:&quot;Courier New&quot;;font-style:normal}.c5{padding-top:0pt;padding-bottom:0pt;line-height:1.5;orphans:2;widows:2;text-align:left}.c10{background-color:#ffffff;font-size:10pt;font-family:&quot;Courier New&quot;;color:#8000ff;font-weight:400}.c3{background-color:#ffffff;font-size:10pt;font-family:&quot;Courier New&quot;;color:#000080;font-weight:700}.c20{border-spacing:0;border-collapse:collapse;margin-right:auto}.c16{background-color:#ffffff;font-size:10pt;font-family:&quot;Courier New&quot;;font-weight:700}.c1{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:left}.c11{background-color:#ffffff;font-size:10pt;font-family:&quot;Courier New&quot;;font-weight:400}.c25{color:#000000;font-weight:400;font-size:16pt;font-family:&quot;Arial&quot;}.c22{color:#000000;font-weight:400;font-size:11pt;font-family:&quot;Courier New&quot;}.c2{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline}.c8{font-size:10pt;font-family:&quot;Courier New&quot;;color:#a82d00;font-weight:400}.c7{font-size:10pt;font-family:&quot;Courier New&quot;;color:#696969;font-weight:400}.c12{font-size:10pt;font-family:&quot;Courier New&quot;;font-weight:400}.c17{text-decoration:none;vertical-align:baseline;font-style:normal}.c29{padding:0;margin:0}.c34{margin-left:36pt;padding-left:0pt}.c35{max-width:468pt;padding:72pt 72pt 72pt 72pt}.c21{color:inherit;text-decoration:inherit}.c14{color:#8b0000}.c13{color:#0000ff}.c19{height:11pt}.c15{color:#800000}.c4{font-style:italic}.c18{color:#800080}.c24{color:#006161}.c33{background-color:#ffffff}.c32{color:#000080}.c27{color:#a31515}.c30{color:#00008b}.c26{height:0pt}.c28{color:#8a2be2}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:&quot;Arial&quot;}p{margin:0;color:#000000;font-size:11pt;font-family:&quot;Arial&quot;}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:&quot;Arial&quot;;line-height:1.5;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}&lt;/style&gt;&lt;/head&gt;&lt;body class=&quot;c33 c35&quot;&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c9&quot;&gt;Posted by James Forshaw, Project Zero&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span&gt;In my &lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&lt;a class=&quot;c211&quot; href=&quot;https://googleprojectzero.blogspot.com/2021/10/using-kerberos-for-authentication-relay.html&quot;&gt;previous blog post&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;I discussed the possibility of relaying Kerberos authentication from a DCOM connection. I was originally going to provide a more in-depth explanation of how that works, but as it&amp;#39;s quite involved I thought it was worthy of its own blog post. This is primarily a technique to get relay authentication from another user on the same machine and forward that to a network service such as LDAP. You could use this to escalate privileges on a host using a technique similar to a &lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&lt;a class=&quot;c211&quot; href=&quot;https://shenaniganslabs.io/2019/01/28/Wagging-the-Dog.html#case-study-2-windows-1020162019-lpe&quot;&gt;blog post&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;from Shenanigans Labs&lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;&amp;nbsp;but removing the requirement for the WebDAV service. Let&amp;#39;s get straight to it.&lt;/span&gt;&lt;/p&gt;&lt;h2 class=&quot;c23&quot; id=&quot;h.5xga9tje7jcd&quot;&gt;&lt;span class=&quot;c25 c17&quot;&gt;Background&lt;/span&gt;&lt;/h2&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span&gt;The technique to locally relay authentication for DCOM was something I originally reported back in 2015 (&lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&lt;a class=&quot;c211&quot; href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=325&quot;&gt;issue 325&lt;/a&gt;&lt;/span&gt;&lt;span&gt;). This issue was fixed as CVE-2015-2370, however the underlying authentication relay using DCOM remained. This was repurposed and expanded upon by various others for local and remote privilege escalation in the &lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&lt;a class=&quot;c211&quot; href=&quot;https://foxglovesecurity.com/2016/09/26/rotten-potato-privilege-escalation-from-service-accounts-to-system/&quot;&gt;RottenPotato&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;series of exploits, the latest in that line being &lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&lt;a class=&quot;c211&quot; href=&quot;https://github.com/antonioCoco/RemotePotato0&quot;&gt;RemotePotato&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;which is currently unpatched as of October 2021.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span&gt;The key feature that the exploit abused is standard COM marshaling. Specifically when a COM object is marshaled so that it can be used by a different process or host, the COM runtime generates an &lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&lt;a class=&quot;c211&quot; href=&quot;https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-dcom/fe6c5e46-adf8-4e34-a8de-3f756c875f31&quot;&gt;OBJREF structure&lt;/a&gt;&lt;/span&gt;&lt;span&gt;, most commonly the &lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&lt;a class=&quot;c211&quot; href=&quot;https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-dcom/51312511-36e1-4ab6-993c-523643b11a29&quot;&gt;OBJREF_STANDARD&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;&amp;nbsp;form. This structure contains all the information necessary to establish a connection between a COM client and the original object in the COM server.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c9&quot;&gt;Connecting to the original object from the OBJREF is a two part process:&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;c29 lst-kix_4h5ag0d3tyrp-0 start&quot; start=&quot;1&quot;&gt;&lt;li style=&quot;margin-left: 46pt;&quot; class=&quot;c5 c34 li-bullet-0&quot;&gt;&lt;span&gt;The client extracts the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Object Exporter ID (OXID)&lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;&amp;nbsp;from the structure and contacts the OXID resolver service specified by the RPC binding information in the OBJREF.&lt;/span&gt;&lt;/li&gt;&lt;li style=&quot;margin-left: 46pt;&quot; class=&quot;c5 c34 li-bullet-0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;The client uses the OXID resolver service to find the RPC binding information of the COM server which hosts the object and establishes a connection to the RPC endpoint to access the object&amp;#39;s interfaces.&lt;/span&gt;&lt;/li&gt;&lt;/ol&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c9&quot;&gt;Both of these steps require establishing an MSRPC connection to an endpoint. Commonly this is either locally over ALPC, or remotely via TCP. If a TCP connection is used then the client will also authenticate to the RPC server using NTLM or Kerberos based on the security bindings in the OBJREF.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span&gt;The first key insight I had for &lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&lt;a class=&quot;c211&quot; href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=325&quot;&gt;issue 325&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;&amp;nbsp;is that you can construct an OBJREF which will always establish a connection to the OXID resolver service over TCP, even if the service was on the local machine. To do this you specify the hostname as an IP address and an arbitrary TCP port for the client to connect to. This allows you to listen locally and when the RPC connection is made the authentication can be relayed or repurposed. &lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span&gt;This isn&amp;#39;t yet a privilege escalation, since you need to convince a privileged user to unmarshal the OBJREF. This was the second key insight: you could get a privileged service to unmarshal an arbitrary OBJREF easily using the &lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&lt;a class=&quot;c211&quot; href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/objbase/nf-objbase-cogetinstancefromistorage&quot;&gt;CoGetInstanceFromIStorage&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;&amp;nbsp;API and activating a privileged COM service. This marshals a COM object, creates the privileged COM server and then unmarshals the object in the server&amp;#39;s security context. This results in an RPC call to the fake OXID resolver authenticated using a privileged user&amp;#39;s credentials. From there the authentication could be relayed to the local system for privilege escalation.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;/p&gt;
  
 &lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c4&quot;&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEidf0_fh87eJd499r4V31gq2EoxkP1fptUl5KU9lwkDp87pFnA3qdmY3eGRB2HqY878TZp7JhPF7F_LpNcl0ax6g6bsSWgv9sSBUx-SFUXZGssDtAFvL_P_ROZPAZW9tdiUz_06DNaFgIUsqBit5HpztFCv67tZF8EILTkQmONHwZ9U7H5G0D5Dg079/s958/image2%20%285%29.png&quot; style=&quot;display: block; padding: 1em 0;text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEidf0_fh87eJd499r4V31gq2EoxkP1fptUl5KU9lwkDp87pFnA3qdmY3eGRB2HqY878TZp7JhPF7F_LpNcl0ax6g6bsSWgv9sSBUx-SFUXZGssDtAFvL_P_ROZPAZW9tdiUz_06DNaFgIUsqBit5HpztFCv67tZF8EILTkQmONHwZ9U7H5G0D5Dg079/s958/image2%20%285%29.png&quot; border=&quot;0&quot; alt=&quot;Diagram of an DCOM authentication relay attack from issue 325&quot; style=&quot;max-height: 750px; max-width: 600px;&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span&gt;Being able to redirect the OXID resolver RPC connection locally to a different TCP port was not by design and Microsoft eventually fixed this in Windows 10 1809/Server 2019. The underlying issue prior to Windows 10 1809 was the string containing the host returned as part of the OBJREF was directly concatenated into an &lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&lt;a class=&quot;c211&quot; href=&quot;https://docs.microsoft.com/en-us/windows/win32/rpc/string-binding&quot;&gt;RPC string binding&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;. Normally the RPC string binding should have been in the form of:&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;a id=&quot;t.e77594769c6122f6cc07295f638fefdcc6db828e&quot;&gt;&lt;/a&gt;&lt;a id=&quot;t.0&quot;&gt;&lt;/a&gt;&lt;table class=&quot;c20&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;c26&quot;&gt;&lt;td class=&quot;c31&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c6&quot;&gt;ncacn_ip_tcp:ADDRESS[135]&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span&gt;Where &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;ncacn_ip_tcp&lt;/span&gt;&lt;span&gt;&amp;nbsp;is the protocol sequence for RPC over TCP, &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;ADDRESS &lt;/span&gt;&lt;span&gt;is the target address which would come from the string binding, and &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;[135]&lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;&amp;nbsp;is the well-known TCP port for the OXID resolver appended by RPCSS. However, as the ADDRESS value is inserted manually into the binding then the OBJREF could specify its own port, resulting in the string binding:&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;a id=&quot;t.97aa81be1b3e01eee48e6be87e60b7c9ec811e04&quot;&gt;&lt;/a&gt;&lt;a id=&quot;t.1&quot;&gt;&lt;/a&gt;&lt;table class=&quot;c20&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;c26&quot;&gt;&lt;td class=&quot;c31&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c6&quot;&gt;ncacn_ip_tcp:ADDRESS[9999][135]&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span&gt;The RPC runtime would just pick the first port in the binding string to connect to, in this case 9999, and would ignore the second port 135. This behavior was fixed by calling the &lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&lt;a class=&quot;c211&quot; href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/rpcdce/nf-rpcdce-rpcstringbindingcomposew&quot;&gt;RpcStringBindingCompose&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;&amp;nbsp;API which will correctly escape the additional port number which ensures it&amp;#39;s ignored when making the RPC connection.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span&gt;This is where the &lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&lt;a class=&quot;c211&quot; href=&quot;https://www.sentinelone.com/labs/relaying-potatoes-another-unexpected-privilege-escalation-vulnerability-in-windows-rpc-protocol/&quot;&gt;RemotePotato exploit&lt;/a&gt;&lt;/span&gt;&lt;span&gt;, developed by &lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&lt;a class=&quot;c211&quot; href=&quot;https://twitter.com/splinter_code&quot;&gt;Antonio Cocomazzi&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;and &lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&lt;a class=&quot;c211&quot; href=&quot;https://twitter.com/decoder_it&quot;&gt;Andrea Pierini&lt;/a&gt;&lt;/span&gt;&lt;span&gt;, comes into the picture. While it was no longer possible to redirect the OXID resolving to a local TCP server, you could redirect the initial connection to an external server. A call is made to the &lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&lt;a class=&quot;c211&quot; href=&quot;https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-dcom/65292e10-ef0c-43ee-bce7-788e271cc794&quot;&gt;IObjectExporter::ResolveOxid2&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;&amp;nbsp;method which can return an arbitrary RPC binding string for a fake COM object. &lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c9&quot;&gt;Unlike the OXID resolver binding string, the one for the COM object is allowed to contain an arbitrary TCP port. By returning a binding string for the original host on an arbitrary TCP port, the second part of the connection process can be relayed rather than the first. The relayed authentication can then be sent to a domain server, such as LDAP or SMB, as long as they don&amp;#39;t enforce signing.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;/p&gt;
  
 &lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c4&quot;&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhyrByRoxwgw3esO67XtK4FiB9Ee14So3I32nGdQJ_ZY1hLVjCPANB7jeGeUHiyi4GZ8LcHjr8UizWip0KoOhWF7pyPIN5Wi_zRzZGWeHI4RgUeiALaZOgesnzd5LVFq_gnU-_hOMo6s6J3Nm9xAp_zWtibxbjq5uQwUDb0lFNde1mJw3GC3OdGc-nU/s1302/image5%20%282%29.png&quot; style=&quot;display: block; padding: 1em 0;text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhyrByRoxwgw3esO67XtK4FiB9Ee14So3I32nGdQJ_ZY1hLVjCPANB7jeGeUHiyi4GZ8LcHjr8UizWip0KoOhWF7pyPIN5Wi_zRzZGWeHI4RgUeiALaZOgesnzd5LVFq_gnU-_hOMo6s6J3Nm9xAp_zWtibxbjq5uQwUDb0lFNde1mJw3GC3OdGc-nU/s1200/image5%20%282%29.png&quot; border=&quot;0&quot; alt=&quot;Diagram of an DCOM authentication relay attack from Remote Potato&quot; style=&quot;max-height: 750px; max-width: 600px;&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c9&quot;&gt;This exploit has the clear disadvantage of requiring an external machine to act as the target of the initial OXID resolving. While investigating the Kerberos authentication relay attacks for DCOM, could I find a way to do everything on the same machine?&lt;/span&gt;&lt;/p&gt;&lt;h2 class=&quot;c23&quot; id=&quot;h.ifb7mhiinb48&quot;&gt;&lt;span class=&quot;c17 c25&quot;&gt;Remote &amp;#10140; Local Potato&lt;/span&gt;&lt;/h2&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c9&quot;&gt;If we&amp;#39;re relaying the authentication for the second RPC connection, could we get the local OXID resolver to do the work for us and resolve to a local COM server on a randomly selected port? One of my goals is to write the least amount of code, which is why we&amp;#39;ll do everything in C# and .NET.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;a id=&quot;t.78af739dc60f8ded5f3815bfc652d7621558437e&quot;&gt;&lt;/a&gt;&lt;a id=&quot;t.2&quot;&gt;&lt;/a&gt;&lt;table class=&quot;c20&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;c26&quot;&gt;&lt;td class=&quot;c31&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12 c13&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;[] ba = GetMarshalledObject(new object());&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12 c13&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;&amp;nbsp;std = COMObjRefStandard.FromArray(ba);&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12&quot;&gt;Console.WriteLine(&lt;/span&gt;&lt;span class=&quot;c12 c27&quot;&gt;&amp;quot;IPID: {0}&amp;quot;&lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;, std.Ipid);&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12&quot;&gt;Console.WriteLine(&lt;/span&gt;&lt;span class=&quot;c12 c27&quot;&gt;&amp;quot;OXID: {0:X08}&amp;quot;&lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;, std.Oxid);&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12&quot;&gt;Console.WriteLine(&lt;/span&gt;&lt;span class=&quot;c12 c27&quot;&gt;&amp;quot;OID : {0:X08}&amp;quot;&lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;, std.Oid);&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c6&quot;&gt;std.StringBindings.Clear();&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12&quot;&gt;std.StringBindings.Add(RpcTowerId.Tcp, &lt;/span&gt;&lt;span class=&quot;c12 c27&quot;&gt;&amp;quot;127.0.0.1&amp;quot;&lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;);&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12&quot;&gt;Console.WriteLine(&lt;/span&gt;&lt;span class=&quot;c12 c27&quot;&gt;$&amp;quot;objref:&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;{0}&lt;/span&gt;&lt;span class=&quot;c12 c27&quot;&gt;:&amp;quot;&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;, Convert.ToBase64String(std.ToArray());&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span&gt;This code creates a basic .NET object and COM marshals it to a standard OBJREF. I&amp;#39;ve left out the code for the marshalling and parsing of the OBJREF, but much of that is already present in the linked &lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&lt;a class=&quot;c211&quot; href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=325&quot;&gt;issue 325&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;. We then modify the list of string bindings to only include a TCP binding for 127.0.0.1, forcing the OXID resolver to use TCP. If you specify a computer&amp;#39;s hostname then the OXID resolver will use ALPC instead. Note that the string bindings in the OBJREF are only for binding to the OXID resolver, not the COM server itself.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span&gt;We can then convert the modified OBJREF into an &lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&lt;a class=&quot;c211&quot; href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/objbase/nf-objbase-createobjrefmoniker&quot;&gt;objref moniker&lt;/a&gt;&lt;/span&gt;&lt;span&gt;. This &lt;/span&gt;&lt;span&gt;format is useful as it allows us to trivially unmarshal the object in another process by calling the &lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&lt;a class=&quot;c211&quot; href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.marshal.bindtomoniker&quot;&gt;Marshal::BindToMoniker&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;&amp;nbsp;API in .NET and passing the moniker string. For example to bind to the COM object in PowerShell you can run the following command:&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;a id=&quot;t.aa280acd79392ba85d8386c23bd09616ceb0921a&quot;&gt;&lt;/a&gt;&lt;a id=&quot;t.3&quot;&gt;&lt;/a&gt;&lt;table class=&quot;c20&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;c26&quot;&gt;&lt;td class=&quot;c31&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c7&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;c12 c24&quot;&gt;Runtime.InteropServices.Marshal&lt;/span&gt;&lt;span class=&quot;c7&quot;&gt;]::&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;BindToMoniker(&lt;/span&gt;&lt;span class=&quot;c12 c14&quot;&gt;&amp;quot;objref:TUVP...:&amp;quot;&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;)&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c9&quot;&gt;Immediately after binding to the moniker a firewall dialog is likely to appear as shown:&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;/p&gt;
  
  
 &lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c4&quot;&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg5k-8HEb-Iw-6zAMqoicT-dV3S7M6SoG2KtLaksWCOLvt3PYRSsV0n3jLa4pjb9NgoJ0HuTOslYPUbVO0hi-Nnf5gIWEfp7Hqy8aa8YwGhnjUs-slWihaWlPPCMOSny-31V-6hyRNQwi78Ddh1Y-T2187oK3KWEvRdGXsLqsjaXFTRGZbNET_8-Dgi/s790/image4%20%283%29.png&quot; style=&quot;display: block; padding: 1em 0;text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg5k-8HEb-Iw-6zAMqoicT-dV3S7M6SoG2KtLaksWCOLvt3PYRSsV0n3jLa4pjb9NgoJ0HuTOslYPUbVO0hi-Nnf5gIWEfp7Hqy8aa8YwGhnjUs-slWihaWlPPCMOSny-31V-6hyRNQwi78Ddh1Y-T2187oK3KWEvRdGXsLqsjaXFTRGZbNET_8-Dgi/s790/image4%20%283%29.png&quot; border=&quot;0&quot; alt=&quot;Firewall dialog for the COM server when a TCP binding is created&quot; style=&quot;max-height: 750px; max-width: 600px;&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c9&quot;&gt;This is requesting the user to allow our COM server process access to listen on all network interfaces for incoming connections. This prompt only appears when the client tries to resolve the OXID as DCOM supports dynamic RPC endpoints. Initially when the COM server starts it only listens on ALPC, but the RPCSS service can ask the server to bind to additional endpoints.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span&gt;This request is made through an internal RPC interface that every COM server implements for use by the RPCSS service. One of the functions on this interface is &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;UseProtSeq&lt;/span&gt;&lt;span&gt;, which requests that the COM server enables a TCP endpoint. When the COM server receives the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;UseProtSeq &lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;call it tries to bind a TCP server to all interfaces, which subsequently triggers the Windows Defender Firewall to prompt the user for access. &lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c9&quot;&gt;Enabling the firewall permission requires administrator privileges. However, as we only need to listen for connections via localhost we shouldn&amp;#39;t need to modify the firewall so the dialog can be dismissed safely. However, going back to the COM client we&amp;#39;ll see an error reported.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;a id=&quot;t.f650b0d01b77aecef2325462507e753c659f0187&quot;&gt;&lt;/a&gt;&lt;a id=&quot;t.4&quot;&gt;&lt;/a&gt;&lt;table class=&quot;c20&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;c26&quot;&gt;&lt;td class=&quot;c31&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c6&quot;&gt;Exception calling &amp;quot;BindToMoniker&amp;quot; with &amp;quot;1&amp;quot; argument(s): &lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c6&quot;&gt;&amp;quot;The RPC server is unavailable. (Exception from HRESULT: 0x800706BA)&amp;quot;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c9&quot;&gt;If we allow our COM server executable through the firewall, the client is able to connect over TCP successfully. Clearly the firewall is affecting the behavior of the COM client in some way even though it shouldn&amp;#39;t. Tracing through the unmarshalling process in the COM client, the error is being returned from RPCSS when trying to resolve the OXID&amp;#39;s binding information. This would imply that no connection attempt is made, and RPCSS is detecting that the COM server wouldn&amp;#39;t be allowed through the firewall and refusing to return any binding information for TCP.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c9&quot;&gt;Further digging into RPCSS led me to the following function:&lt;/span&gt;&lt;/p&gt;&lt;a id=&quot;t.adfd20381e0d0a060d62f6d9e908c9386f1297f0&quot;&gt;&lt;/a&gt;&lt;a id=&quot;t.5&quot;&gt;&lt;/a&gt;&lt;table class=&quot;c20&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;c26&quot;&gt;&lt;td class=&quot;c31&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c11&quot;&gt;BOOL IsPortOpen&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;LPWSTR ImageFileName&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c10&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;&amp;nbsp;PortNumber&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c3 c17&quot;&gt;{&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c11&quot;&gt;&amp;nbsp; INetFwMgr&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;&amp;nbsp;mgr&lt;/span&gt;&lt;span class=&quot;c3 c17&quot;&gt;;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c6 c33&quot;&gt;&amp;nbsp; &lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c11&quot;&gt;&amp;nbsp; CoCreateInstance&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;CLSID_FwMgr&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c16 c13&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;&amp;nbsp;CLSCTX_INPROC_SERVER&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;c6 c33&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c11&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;IID_PPV_ARGS&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;(&amp;amp;&lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;mgr&lt;/span&gt;&lt;span class=&quot;c3 c17&quot;&gt;));&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c11&quot;&gt;&amp;nbsp; VARIANT Allowed&lt;/span&gt;&lt;span class=&quot;c3 c17&quot;&gt;;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c11&quot;&gt;&amp;nbsp; VARIANT Restricted&lt;/span&gt;&lt;span class=&quot;c3 c17&quot;&gt;;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c11&quot;&gt;&amp;nbsp; mgr&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;IsPortAllowed&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;ImageFileName&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;&amp;nbsp;NET_FW_IP_VERSION_ANY&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;c6 c33&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c11&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;PortNumber&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c16 c13&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;&amp;nbsp;NET_FW_IP_PROTOCOL_TCP&lt;/span&gt;&lt;span class=&quot;c3 c17&quot;&gt;,&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c11&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;Allowed&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;Restricted&lt;/span&gt;&lt;span class=&quot;c3 c17&quot;&gt;);&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c11&quot;&gt;&amp;nbsp; &lt;/span&gt;&lt;span class=&quot;c16 c13&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;VT_BOOL &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;!=&lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;&amp;nbsp;Allowed&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;vt&lt;/span&gt;&lt;span class=&quot;c3 c17&quot;&gt;)&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c11&quot;&gt;&amp;nbsp; &amp;nbsp; &lt;/span&gt;&lt;span class=&quot;c13 c16&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;&amp;nbsp;FALSE&lt;/span&gt;&lt;span class=&quot;c3 c17&quot;&gt;;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c19&quot;&gt;&lt;span class=&quot;c3 c17&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c11&quot;&gt;&amp;nbsp; &lt;/span&gt;&lt;span class=&quot;c16 c13&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;&amp;nbsp;Allowed&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;boolVal &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;&amp;nbsp;VARIANT_TRUE&lt;/span&gt;&lt;span class=&quot;c3 c17&quot;&gt;;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c3&quot;&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span&gt;This function uses the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;HNetCfg.FwMgr&lt;/span&gt;&lt;span&gt;&amp;nbsp;COM object, and calls &lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&lt;a class=&quot;c211&quot; href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/netfw/nf-netfw-inetfwmgr-isportallowed&quot;&gt;INetFwMgr::IsPortAllowed&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;&amp;nbsp;to determine if the process is allowed to listen on the specified TCP port. This function is called for every TCP binding when enumerating the COM server&amp;#39;s bindings to return to the client. RPCSS passes the full path to the COM server&amp;#39;s executable and the listening TCP port. If the function returns FALSE then RPCSS doesn&amp;#39;t consider it valid and won&amp;#39;t add it to the list of potential bindings. &lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span&gt;If the OXID resolving process doesn&amp;#39;t have any binding at the end of the lookup process it will return the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;RPC_S_SERVER_UNAVAILABLE&lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;&amp;nbsp;error and the COM client will fail to bind to the server. How can we get around this limitation without needing administrator privileges to allow our server through the firewall? We can convert this C++ code into a small PowerShell function to test the behavior of the function to see what would grant access.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;a id=&quot;t.8dadc02f2dd955da5d84ce378d816be40d1bf022&quot;&gt;&lt;/a&gt;&lt;a id=&quot;t.6&quot;&gt;&lt;/a&gt;&lt;table class=&quot;c20&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;c26&quot;&gt;&lt;td class=&quot;c31&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12 c30&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c12 c28&quot;&gt;Test-IsPortOpen&lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;&amp;nbsp;{&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp; &amp;nbsp; &lt;/span&gt;&lt;span class=&quot;c12 c30&quot;&gt;param&lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;(&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &lt;/span&gt;&lt;span class=&quot;c7&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;c12 c24&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;c7&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;$Name&lt;/span&gt;&lt;span class=&quot;c7 c17&quot;&gt;,&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &lt;/span&gt;&lt;span class=&quot;c7&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;c12 c24&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;c7&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;c8 c17&quot;&gt;$Port&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c6&quot;&gt;&amp;nbsp; &amp;nbsp; )&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c19&quot;&gt;&lt;span class=&quot;c6&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp; &amp;nbsp; &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;$mgr&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c7&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c12 c13&quot;&gt;New-Object&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c12 c32&quot;&gt;-ComObject&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c12 c17 c14&quot;&gt;&amp;quot;HNetCfg.FwMgr&amp;quot;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp; &amp;nbsp; &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;$allow&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c7&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c8 c17&quot;&gt;$null&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp; &amp;nbsp; &lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;$mgr&lt;/span&gt;&lt;span class=&quot;c7&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;IsPortAllowed(&lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;$Name&lt;/span&gt;&lt;span class=&quot;c7&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c12 c18&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;c7&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;$Port&lt;/span&gt;&lt;span class=&quot;c7&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c12 c14&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class=&quot;c7&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c12 c18&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;c7&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c7&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;c12 c24&quot;&gt;ref&lt;/span&gt;&lt;span class=&quot;c7&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;$allow&lt;/span&gt;&lt;span class=&quot;c7&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;$null&lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;)&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp; &amp;nbsp; &lt;/span&gt;&lt;span class=&quot;c8 c17&quot;&gt;$allow&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c6&quot;&gt;}&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c19&quot;&gt;&lt;span class=&quot;c6&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12 c30&quot;&gt;foreach&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;$f&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c12 c30&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp;$(&lt;/span&gt;&lt;span class=&quot;c12 c13&quot;&gt;ls&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c12 c14&quot;&gt;&amp;quot;$env:WINDIR\system32\*.exe&amp;quot;&lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;)) { &amp;nbsp; &amp;nbsp;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp; &amp;nbsp; &lt;/span&gt;&lt;span class=&quot;c12 c30&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp;(&lt;/span&gt;&lt;span class=&quot;c12 c13&quot;&gt;Test-IsPortOpen&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;$f&lt;/span&gt;&lt;span class=&quot;c7&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;FullName &lt;/span&gt;&lt;span class=&quot;c12 c18&quot;&gt;12345&lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;) {&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &lt;/span&gt;&lt;span class=&quot;c12 c13&quot;&gt;Write-Host&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c8&quot;&gt;$f&lt;/span&gt;&lt;span class=&quot;c7&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;Fullname&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c6&quot;&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12&quot;&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span&gt;This script enumerates all executable files in system32 and checks if they&amp;#39;d be allowed to connect to TCP port 12345. Normally the TCP port would be selected automatically, however the COM server can use the &lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&lt;a class=&quot;c211&quot; href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/rpcdce/nf-rpcdce-rpcserveruseprotseqep&quot;&gt;RpcServerUseProtseqEp&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;&amp;nbsp;API to pre-register a known TCP port for RPC communication, so we&amp;#39;ll just pick port 12345.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span&gt;The only executable in system32 that returns true from &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Test-IsPortOpen&lt;/span&gt;&lt;span&gt;&amp;nbsp;is &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;svchost.exe&lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;. That makes some sense, the default firewall rules usually permit a limited number of services to be accessible through the firewall, the majority of which are hosted in a shared service process.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span&gt;This check doesn&amp;#39;t guarantee a COM server will be allowed through the firewall, just that it&amp;#39;s potentially accessible in order to return a TCP binding string. As the connection will be via localhost we don&amp;#39;t need to be allowed through the firewall, only that &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;IsPortOpen &lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;thinks we could be open. How can we spoof the image filename?&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span&gt;The obvious trick would be to create a &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;svchost.exe&lt;/span&gt;&lt;span&gt;&amp;nbsp;process and inject our own code in there. However, that is harder to achieve through pure .NET code and also injecting into an &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;svchost &lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;executable is a bit of a red flag if something is monitoring for malicious code which might make the exploit unreliable. Instead, perhaps we can influence the image filename used by RPCSS?&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span&gt;Digging into the COM runtime, when a COM server registers itself with RPCSS it passes its own image filename as part of the registration information. The runtime gets the image filename through a call to &lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&lt;a class=&quot;c211&quot; href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulefilenamew&quot;&gt;GetModuleFileName&lt;/a&gt;&lt;/span&gt;&lt;span&gt;, which gets the value from the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;ImagePathName&lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;&amp;nbsp;field in the process parameters block referenced by the PEB. &lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c9&quot;&gt;We can modify this string in our own process to be anything we like, then when COM is initialized, that will be sent to RPCSS which will use it for the firewall check. Once the check passes, RPCSS will return the TCP string bindings for our COM server when unmarshalling the OBJREF and the client will be able to connect. This can all be done with only minor in-process modifications from .NET and no external servers required.&lt;/span&gt;&lt;/p&gt;&lt;h2 class=&quot;c23&quot; id=&quot;h.87n38litfqxj&quot;&gt;&lt;span class=&quot;c25 c17&quot;&gt;Capturing Authentication&lt;/span&gt;&lt;/h2&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c9&quot;&gt;At this point a new RPC connection will be made to our process to communicate with the marshaled COM object. During that process the COM client must authenticate, so we can capture and relay that authentication to another service locally or remotely. What&amp;#39;s the best way to capture that authentication traffic?&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span&gt;Before we do anything we need to select what authentication we want to receive, and this will be reflected in the OBJREF&amp;#39;s security bindings. As we&amp;#39;re doing everything using the existing COM runtime we can register what RPC authentication services to use when calling &lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&lt;a class=&quot;c211&quot; href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/combaseapi/nf-combaseapi-coinitializesecurity&quot;&gt;CoInitializeSecurity&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;in the COM server through the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;asAuthSvc&lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;&amp;nbsp;parameter.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;a id=&quot;t.5188af134394dbd4e93278caa48ce70cc2e7b4b8&quot;&gt;&lt;/a&gt;&lt;a id=&quot;t.7&quot;&gt;&lt;/a&gt;&lt;table class=&quot;c20&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;c26&quot;&gt;&lt;td class=&quot;c31&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12 c13&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp;svcs = &lt;/span&gt;&lt;span class=&quot;c12 c13&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;&amp;nbsp;SOLE_AUTHENTICATION_SERVICE[] { &lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12 c13&quot;&gt;&amp;nbsp; &amp;nbsp; new&lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;&amp;nbsp;SOLE_AUTHENTICATION_SERVICE() { &lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c6&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; dwAuthnSvc = RpcAuthenticationType.Kerberos,&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; pPrincipalName = &lt;/span&gt;&lt;span class=&quot;c12 c27&quot;&gt;&amp;quot;HOST/DC.domain.com&amp;quot;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c6&quot;&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c6&quot;&gt;};&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12 c13&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp;str = SetProcessModuleName(&lt;/span&gt;&lt;span class=&quot;c12 c27&quot;&gt;&amp;quot;System&amp;quot;&lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;);&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12 c17 c13&quot;&gt;try&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c6&quot;&gt;{&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c6&quot;&gt;&amp;nbsp; &amp;nbsp;CoInitializeSecurity(IntPtr.Zero, svcs.Length, svcs, &lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c6&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; IntPtr.Zero, AuthnLevel.RPC_C_AUTHN_LEVEL_DEFAULT,&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c6&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ImpLevel.RPC_C_IMP_LEVEL_IMPERSONATE, IntPtr.Zero,&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c6&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; EOLE_AUTHENTICATION_CAPABILITIES.EOAC_DYNAMIC_CLOAKING,&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c6&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; IntPtr.Zero);&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c6&quot;&gt;}&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12 c13 c17&quot;&gt;finally&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c6&quot;&gt;{&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c6&quot;&gt;&amp;nbsp; &amp;nbsp; SetProcessModuleName(str);&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12&quot;&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span&gt;In the above code, we register to only receive Kerberos authentication and we can also specify an arbitrary SPN as I described in the &lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&lt;a class=&quot;c211&quot; href=&quot;https://googleprojectzero.blogspot.com/2021/10/using-kerberos-for-authentication-relay.html&quot;&gt;previous blog post&lt;/a&gt;&lt;/span&gt;&lt;span&gt;. One thing to note is that the call to &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;CoInitializeSecurity&lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;&amp;nbsp;will establish the connection to RPCSS and pass the executable filename. Therefore we need to modify the filename before calling the API as we can&amp;#39;t change it after the connection has been established. &lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span&gt;For &lt;/span&gt;&lt;span&gt;swag&lt;/span&gt;&lt;span&gt;&amp;nbsp;points I specify the filename &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;System&lt;/span&gt;&lt;span&gt;&amp;nbsp;rather than build the full path to &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;svchost.exe&lt;/span&gt;&lt;span&gt;. This is the &lt;/span&gt;&lt;span&gt;name assigned to the kernel which is also granted access through the firewall. We restore the original filename after the call to &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;CoInitializeSecurity &lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;to reduce the risk of it breaking something unexpectedly.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c9&quot;&gt;That covers the selection of the authentication service to use, but doesn&amp;#39;t help us actually capture that authentication. My first thought to capture the authentication was to find the socket handle for the TCP server, close it and create a new socket in its place. Then I could directly process the RPC protocol and parse out the authentication. This felt somewhat risky as the RPC runtime would still think it has a valid TCP server socket and might fail in unexpected ways. Also it felt like a lot of work, when I have a perfectly good RPC protocol parser built into Windows.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span&gt;I then resigned myself to hooking the SSPI APIs, although ideally I&amp;#39;d prefer not to do so. However, once I started looking at the RPC runtime library there weren&amp;#39;t any imports for the SSPI APIs to hook into and I really didn&amp;#39;t want to patch the functions themselves. It turns out that the RPC runtime loads security packages dynamically, based on the authentication service requested and the configuration of the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;HKLM\SOFTWARE\Microsoft\Rpc\SecurityService&lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;&amp;nbsp;registry key.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;/p&gt;
  
 &lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c4&quot;&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiooNt9vGeuuGX-qWowAPJv7twW2ASFXiXwvwVb9QQimr6U2WnzYWPcRQKHXDdnn8mXuNaC0l0Fvs9fvHbYbh72r4G2_AnCLjaVC2HtnzoL2sgb8hOiw-EJyldnejADOu8ddBamYLMOP0d-Km3g1HX02MOhi033j7usXaJJ8MeSHKWJBK4C3gcY426H/s877/image1%20%286%29.png&quot; style=&quot;display: block; padding: 1em 0;text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiooNt9vGeuuGX-qWowAPJv7twW2ASFXiXwvwVb9QQimr6U2WnzYWPcRQKHXDdnn8mXuNaC0l0Fvs9fvHbYbh72r4G2_AnCLjaVC2HtnzoL2sgb8hOiw-EJyldnejADOu8ddBamYLMOP0d-Km3g1HX02MOhi033j7usXaJJ8MeSHKWJBK4C3gcY426H/s877/image1%20%286%29.png&quot; border=&quot;0&quot; alt=&quot;Screenshot of the Registry Editor showing HKLM\SOFTWARE\Microsoft\Rpc\SecurityService key&quot; style=&quot;max-height: 750px; max-width: 600px;&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span&gt;The key, shown in the above screenshot has a list of values. The value&amp;#39;s name is the number &lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&lt;a class=&quot;c211&quot; href=&quot;https://docs.microsoft.com/en-us/windows/win32/com/com-authentication-service-constants&quot;&gt;assigned&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;to the authentication service, for example 16 is &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;RPC_C_AUTHN_GSS_KERBEROS&lt;/span&gt;&lt;span&gt;. The value&amp;#39;s data is then the name of the DLL to load which provides the API, for Kerberos this is &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;sspicli.dll&lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span&gt;The RPC runtime then loads a table of security functions from the DLL by calling its exported &lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&lt;a class=&quot;c211&quot; href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/sspi/nf-sspi-initsecurityinterfacew&quot;&gt;InitSecurityInterface&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;method. At least for &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;sspicli&lt;/span&gt;&lt;span&gt;&amp;nbsp;the table is always the same and is a pre-initialized structure in the DLL&amp;#39;s data section. This is perfect, we can just call &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;InitSecurityInterface&lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;&amp;nbsp;before the RPC runtime is initialized to get a pointer to the table then modify its function pointers to point to our own implementation of the API. As an added bonus the table is in a writable section of the DLL so we don&amp;#39;t even need to modify the memory protection.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span&gt;Of course implementing the hooks is non-trivial. This is made more complex because RPC uses the &lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&lt;a class=&quot;c211&quot; href=&quot;https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-kile/190ab8de-dc42-49cf-bf1b-ea5705b7a087&quot;&gt;DCE style Kerberos authentication&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;&amp;nbsp;which requires two tokens from the client before the server considers the authentication complete. This requires maintaining more state to keep the RPC server and client implementations happy. I&amp;#39;ll leave this as an exercise for the reader.&lt;/span&gt;&lt;/p&gt;&lt;h2 class=&quot;c23&quot; id=&quot;h.dkczv6jimbo9&quot;&gt;&lt;span class=&quot;c25 c17&quot;&gt;Choosing a Relay Target Service&lt;/span&gt;&lt;/h2&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span&gt;The next step is to choose a suitable target service to relay the authentication to. For &lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&lt;a class=&quot;c211&quot; href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=325&quot;&gt;issue 325&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;&amp;nbsp;I relayed the authentication to the same machine&amp;#39;s DCOM activator RPC service and was able to achieve an arbitrary file write.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span&gt;I thought that maybe I could do so again, so I modified my &lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&lt;a class=&quot;c211&quot; href=&quot;https://googleprojectzero.blogspot.com/2019/12/calling-local-windows-rpc-servers-from.html&quot;&gt;.NET RPC client&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;&amp;nbsp;to handle the relayed authentication and tried accessing local RPC services. No matter what RPC server or function I called, I always got an access denied error. Even if I wrote my own RPC server which didn&amp;#39;t have any checks, it would fail.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c9&quot;&gt;Digging into the failure it turned out that at some point (I don&amp;#39;t know specifically when), Microsoft added a mitigation into the RPC runtime to make it very difficult to relay authentication back to the same system. &lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;a id=&quot;t.d16597b280dba3c3840bf804233cdcf3fbce3cb7&quot;&gt;&lt;/a&gt;&lt;a id=&quot;t.8&quot;&gt;&lt;/a&gt;&lt;table class=&quot;c20&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;c26&quot;&gt;&lt;td class=&quot;c31&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c10&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;&amp;nbsp;SSECURITY_CONTEXT&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;ValidateUpgradeCriteria&lt;/span&gt;&lt;span class=&quot;c3 c17&quot;&gt;() {&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c11&quot;&gt;&amp;nbsp; &lt;/span&gt;&lt;span class=&quot;c16 c13&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;c16 c13&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;AuthnLevel &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;&amp;nbsp;RPC_C_AUTHN_LEVEL_PKT_INTEGRITY&lt;/span&gt;&lt;span class=&quot;c3 c17&quot;&gt;) {&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c11&quot;&gt;&amp;nbsp; &amp;nbsp; &lt;/span&gt;&lt;span class=&quot;c16 c13&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;IsLoopback&lt;/span&gt;&lt;span class=&quot;c3 c17&quot;&gt;())&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c11&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &lt;/span&gt;&lt;span class=&quot;c16 c13&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;UnsafeLoopbackAuth &lt;/span&gt;&lt;span class=&quot;c3&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;c11&quot;&gt;&amp;nbsp;TRUE&lt;/span&gt;&lt;span class=&quot;c3 c17&quot;&gt;;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c11&quot;&gt;&amp;nbsp; &lt;/span&gt;&lt;span class=&quot;c3 c17&quot;&gt;}&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c3&quot;&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span&gt;The &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;SSECURITY_CONTEXT::ValidateUpgradeCriteria&lt;/span&gt;&lt;span&gt;&amp;nbsp;method is called when receiving RPC authentication packets. If the authentication level for the RPC connection is less than &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;RPC_C_AUTHN_LEVEL_PKT_INTEGRITY&lt;/span&gt;&lt;span&gt;&amp;nbsp;such as &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;RPC_C_AUTHN_LEVEL_PKT_CONNECT&lt;/span&gt;&lt;span&gt;&amp;nbsp;and the authentication was from the same system then a flag is set to true in the security context. The &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;IsLoopback &lt;/span&gt;&lt;span&gt;function calls the &lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&lt;a class=&quot;c211&quot; href=&quot;https://docs.microsoft.com/en-us/windows/win32/secauthn/querycontextattributes--general&quot;&gt;QueryContextAttributes&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;API for the undocumented &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;SECPKG_ATTR_IS_LOOPBACK&lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;&amp;nbsp;attribute value from the server security context. This attribute indicates if the authentication was from the local system.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span&gt;When an RPC call is made the server will check if the flag is true, if it is then the call will be immediately rejected before any code is called in the server including the RPC interface&amp;#39;s security callback. The only way to pass this check is either the authentication doesn&amp;#39;t come from the local system or the authentication level is &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;RPC_C_AUTHN_LEVEL_PKT_INTEGRITY&lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;&amp;nbsp;or above which then requires the client to know the session key for signing or encryption. The RPC client will also check for local authentication and will increase the authentication level if necessary. This is an effective way of preventing the relay of local authentication to elevate privileges.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c9&quot;&gt;Instead as I was focussing on Kerberos, I came to the conclusion that relaying the authentication to an enterprise network service was more useful. As the default settings for a domain controller&amp;#39;s LDAP service still do not enforce signing, it would seem a reasonable target. As we&amp;#39;ll see, this provides a limitation of the source of the authentication, as it must not enable Integrity otherwise the LDAP server will enforce signing.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span&gt;The problem with LDAP is I didn&amp;#39;t have any code which implemented the protocol. I&amp;#39;m sure there is some .NET code to do it somewhere, but the fewer dependencies I have the better. As I mentioned in the &lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&lt;a class=&quot;c211&quot; href=&quot;https://googleprojectzero.blogspot.com/2021/10/using-kerberos-for-authentication-relay.html&quot;&gt;previous blog post&lt;/a&gt;&lt;/span&gt;&lt;span&gt;, Windows has a builtin &lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&lt;a class=&quot;c211&quot; href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/_ldap/&quot;&gt;LDAP library&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;in &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;wldap32.dll&lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;. Could I repurpose its API but convert it into using relayed authentication?&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span&gt;Unsurprisingly the library doesn&amp;#39;t have a &amp;quot;Enable relayed authentication&amp;quot; mode, but after a few minutes in a disassembler, it was clear it was also delay-loading the SSPI interfaces through the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;InitSecurityInterface &lt;/span&gt;&lt;span&gt;method. I could repurpose my code for capturing the authentication for relaying the authentication. There was initially a minor issue, accidentally or on purpose there was a stray call to &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;QueryContextAttributes&lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span&gt;which was directly imported, so I needed to patch that through an &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;Import Address Table (IAT)&lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;&amp;nbsp;hook as distasteful as that was.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span&gt;There was still a problem however. When the client connects it always tries to enable LDAP signing, as we are relaying authentication with no access to the session key this causes the connection to fail. Setting the option value &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;LDAP_OPT_SIGN&lt;/span&gt;&lt;span&gt;&amp;nbsp;in the library to false didn&amp;#39;t change this behavior. I needed to set the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;LdapClientIntegrity &lt;/span&gt;&lt;span&gt;registry value to 0 in the LDAP service&amp;#39;s key before initializing the library. Unfortunately that key is only modifiable by administrators. I could have modified the library itself, but as it was checking the key during &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;DllMain &lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;it would be a complex dance to patch the DLL in the middle of loading.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span&gt;Instead I decided to override the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;HKEY_LOCAL_MACHINE&lt;/span&gt;&lt;span&gt;&amp;nbsp;key. This is possible for the Win32 APIs by using the &lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&lt;a class=&quot;c211&quot; href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regoverridepredefkey&quot;&gt;RegOverridePredefKey&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;API. The purpose of the API is to allow installers to redirect administrator-only modifications to the registry into a writable location, however for our purposes we can also use it to redirect the reading of the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;LdapClientIntegrity &lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;registry value.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;a id=&quot;t.701cb52d2a1d8adec608337c8e749b549cee1cf3&quot;&gt;&lt;/a&gt;&lt;a id=&quot;t.9&quot;&gt;&lt;/a&gt;&lt;table class=&quot;c20&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;c26&quot;&gt;&lt;td class=&quot;c31&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12&quot;&gt;[DllImport(&lt;/span&gt;&lt;span class=&quot;c12 c27&quot;&gt;&amp;quot;Advapi32.dll&amp;quot;&lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;)]&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12 c13&quot;&gt;static&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c12 c13&quot;&gt;extern&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c12 c13&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;&amp;nbsp;RegOverridePredefKey(&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c6&quot;&gt;&amp;nbsp; &amp;nbsp; IntPtr hKey,&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c6&quot;&gt;&amp;nbsp; &amp;nbsp; IntPtr hNewHKey&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c6&quot;&gt;);&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c19&quot;&gt;&lt;span class=&quot;c6&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12&quot;&gt;[DllImport(&lt;/span&gt;&lt;span class=&quot;c12 c27&quot;&gt;&amp;quot;kernel32.dll&amp;quot;&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;, CharSet = CharSet.Unicode, SetLastError = &lt;/span&gt;&lt;span class=&quot;c12 c13&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;)]&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12 c13&quot;&gt;static&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c12 c13&quot;&gt;extern&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp;IntPtr LoadLibrary(&lt;/span&gt;&lt;span class=&quot;c12 c13&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;&amp;nbsp;libname);&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c19&quot;&gt;&lt;span class=&quot;c6&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12 c13&quot;&gt;static&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c12 c13&quot;&gt;readonly&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp;IntPtr HKEY_LOCAL_MACHINE = &lt;/span&gt;&lt;span class=&quot;c12 c13&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;&amp;nbsp;IntPtr(-2147483646);&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c19&quot;&gt;&lt;span class=&quot;c6&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12 c13&quot;&gt;static&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c12 c13&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;&amp;nbsp;OverrideLocalMachine(RegistryKey key)&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c6&quot;&gt;{&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp; &amp;nbsp; &lt;/span&gt;&lt;span class=&quot;c12 c13&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;&amp;nbsp;res = RegOverridePredefKey(HKEY_LOCAL_MACHINE, &lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c6&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; key?.Handle.DangerousGetHandle() ?? IntPtr.Zero);&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp; &amp;nbsp; &lt;/span&gt;&lt;span class=&quot;c12 c13&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;&amp;nbsp;(res != 0)&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &lt;/span&gt;&lt;span class=&quot;c12 c13&quot;&gt;throw&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c12 c13&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;&amp;nbsp;Win32Exception(res);&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c6&quot;&gt;}&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c19&quot;&gt;&lt;span class=&quot;c6&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12 c13&quot;&gt;static&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c12 c13&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;&amp;nbsp;LoadLDAPLibrary()&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c6&quot;&gt;{&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp; &amp;nbsp; &lt;/span&gt;&lt;span class=&quot;c12 c13&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp;dummy = &lt;/span&gt;&lt;span class=&quot;c12 c15&quot;&gt;@&amp;quot;SOFTWARE\DUMMY&amp;quot;&lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp; &amp;nbsp; &lt;/span&gt;&lt;span class=&quot;c12 c13&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp;target = &lt;/span&gt;&lt;span class=&quot;c12 c15&quot;&gt;@&amp;quot;System\CurrentControlSet\Services\LDAP&amp;quot;&lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp; &amp;nbsp; &lt;/span&gt;&lt;span class=&quot;c12 c13&quot;&gt;using&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp;(&lt;/span&gt;&lt;span class=&quot;c12 c13&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp;key = Registry.CurrentUser.CreateSubKey(dummy, &lt;/span&gt;&lt;span class=&quot;c12 c13&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;))&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c6&quot;&gt;&amp;nbsp; &amp;nbsp; {&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &lt;/span&gt;&lt;span class=&quot;c12 c13&quot;&gt;using&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp;(&lt;/span&gt;&lt;span class=&quot;c12 c13&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp;okey = key.CreateSubKey(target, &lt;/span&gt;&lt;span class=&quot;c12 c13&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;))&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c6&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; {&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; okey.SetValue(&lt;/span&gt;&lt;span class=&quot;c12 c27&quot;&gt;&amp;quot;LdapClientIntegrity&amp;quot;&lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;, 0, &lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c6&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; RegistryValueKind.DWord);&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c6&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; OverrideLocalMachine(key);&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1 c19&quot;&gt;&lt;span class=&quot;c6&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &lt;/span&gt;&lt;span class=&quot;c12 c17 c13&quot;&gt;try&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c6&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; {&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; IntPtr lib = LoadLibrary(&lt;/span&gt;&lt;span class=&quot;c12 c27&quot;&gt;&amp;quot;wldap32.dll&amp;quot;&lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;);&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &lt;/span&gt;&lt;span class=&quot;c12 c13&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;&amp;nbsp;(lib == IntPtr.Zero)&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &lt;/span&gt;&lt;span class=&quot;c12 c13&quot;&gt;throw&lt;/span&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c12 c13&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;&amp;nbsp;Win32Exception();&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c6&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &lt;/span&gt;&lt;span class=&quot;c12 c17 c13&quot;&gt;finally&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c6&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; {&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; OverrideLocalMachine(&lt;/span&gt;&lt;span class=&quot;c12 c13&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;c6&quot;&gt;);&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c6&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Registry.CurrentUser.DeleteSubKeyTree(dummy);&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c6&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c6&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c6&quot;&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c12&quot;&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span&gt;This code redirects the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;HKEY_LOCAL_MACHINE&lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;&amp;nbsp;key and then loads the LDAP library. Once it&amp;#39;s loaded we can then revert the override so that everything else works as expected. We can now repurpose the built-in LDAP library to relay Kerberos authentication to the domain controller. For the final step, we need a privileged COM service to unmarshal the OBJREF to start the process.&lt;/span&gt;&lt;/p&gt;&lt;h2 class=&quot;c23&quot; id=&quot;h.dwt9lb67za71&quot;&gt;&lt;span class=&quot;c25 c17&quot;&gt;Choosing a COM Unmarshaller &lt;/span&gt;&lt;/h2&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span&gt;The &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;RemotePotato &lt;/span&gt;&lt;span&gt;attack assumes that a more privileged user is authenticated on the same machine. However I wanted to see what I could do &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;without&lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;&amp;nbsp;that requirement. Realistically the only thing that can be done is to relay the computer&amp;#39;s domain account to the LDAP server. &lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span&gt;To get access to authentication for the computer account, we need to unmarshal the OBJREF inside a process running as either &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;SYSTEM&lt;/span&gt;&lt;span&gt;&amp;nbsp;or &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;NETWORK SERVICE&lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;. These local accounts are mapped to the computer account when authenticating to another machine on the network. &lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span&gt;We do have one big limitation on the selection of a suitable COM server: it must make the RPC connection using the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;RPC_C_AUTHN_LEVEL_PKT_CONNECT&lt;/span&gt;&lt;span&gt;&amp;nbsp;authentication level. Anything above that will enable Integrity on the authentication which will prevent us relaying to LDAP. Fortunately &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;RPC_C_AUTHN_LEVEL_PKT_CONNECT&lt;/span&gt;&lt;span&gt;&amp;nbsp;is the default setting for DCOM, but unfortunately all services which use the &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;svchost &lt;/span&gt;&lt;span&gt;process change that default to &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;RPC_C_AUTHN_LEVEL_PKT&lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;&amp;nbsp;which enables Integrity.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span&gt;After a bit of hunting around with &lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&lt;a class=&quot;c211&quot; href=&quot;http://oleview.net&quot;&gt;OleViewDotNet&lt;/a&gt;&lt;/span&gt;&lt;span&gt;, I found a good candidate class, &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;CRemoteAppLifetimeManager&lt;/span&gt;&lt;span&gt;&amp;nbsp;(CLSID: 0bae55fc-479f-45c2-972e-e951be72c0c1) which is hosted in its own executable, runs as &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;NETWORK SERVICE&lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;, and doesn&amp;#39;t change any default settings as shown below.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;/p&gt;
  
 &lt;p class=&quot;c5&quot;&gt;&lt;span class=&quot;c4&quot;&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjY0GTONUmsfjcV_gBc77i0Cvy_4WgZ_89837ArCqW3GfvyXBsIinDGdcZxxo5Sj6WWjTd0DsNFt7O95UMjb_-QiwHrzdvJo3y9HWH6oxQVnBeKjwLUqnVGmwh9kqOsvM9YfZsIiSgCdX3io1tg31NwkHUMfS3KTEGoJxbRrtC15Z5n72WuCSS92zOb/s945/image3%20%283%29.png&quot; style=&quot;display: block; padding: 1em 0;text-align: center;&quot;&gt;&lt;img src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjY0GTONUmsfjcV_gBc77i0Cvy_4WgZ_89837ArCqW3GfvyXBsIinDGdcZxxo5Sj6WWjTd0DsNFt7O95UMjb_-QiwHrzdvJo3y9HWH6oxQVnBeKjwLUqnVGmwh9kqOsvM9YfZsIiSgCdX3io1tg31NwkHUMfS3KTEGoJxbRrtC15Z5n72WuCSS92zOb/s945/image3%20%283%29.png&quot; border=&quot;0&quot; alt=&quot;Screenshot of the OleViewDotNet showing the security flags of the CRemoteAppLifetimeManager COM server&quot; style=&quot;max-height: 750px; max-width: 600px;&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span&gt;The server doesn&amp;#39;t change the default impersonation level from &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;RPC_C_IMP_LEVEL_IDENTIFY&lt;/span&gt;&lt;span&gt;, which means the negotiated token will only be at &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;SecurityIdentification&lt;/span&gt;&lt;span&gt;&amp;nbsp;level. For LDAP, this doesn&amp;#39;t matter as it only uses the token for access checking, not to open resources. However, this would prevent using the same authentication to access something like the SMB server. I&amp;#39;m confident that given enough effort, a COM server with both &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;RPC_C_AUTHN_LEVEL_PKT_CONNECT&lt;/span&gt;&lt;span&gt;&amp;nbsp;and &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;RPC_C_IMP_LEVEL_IMPERSONATE&lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;&amp;nbsp;could be found, but it wasn&amp;#39;t necessary for my exploit.&lt;/span&gt;&lt;/p&gt;&lt;h2 class=&quot;c23&quot; id=&quot;h.38szqoyv0vag&quot;&gt;&lt;span class=&quot;c25 c17&quot;&gt;Wrapping Up&lt;/span&gt;&lt;/h2&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span&gt;That&amp;#39;s a somewhat complex exploit. However, it does allow for authentication relay, with arbitrary Kerberos tokens from a local user to LDAP on a default Windows 10 system. Hopefully it might provide some ideas of how to implement something similar without always needing to write your protocol servers and clients and just use what&amp;#39;s already available.&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span&gt;This exploit is very similar to the existing RemotePotato exploit that Microsoft have already stated will not be fixed. This is because Microsoft considers authentication relay attacks to be an issue with the configuration of the Windows network, such as not enforcing signing on LDAP, rather than the particular technique used to generate the authentication relay. As I mentioned in the &lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&lt;a class=&quot;c211&quot; href=&quot;https://googleprojectzero.blogspot.com/2021/10/using-kerberos-for-authentication-relay.html&quot;&gt;previous blog post&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;, at most this would be assessed as a Moderate severity issue which does not reach the bar for fixing as part of regular updates (or potentially, not being fixed at all).&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c9&quot;&gt;&lt;/span&gt;&lt;/p&gt;
 &lt;p class=&quot;c5&quot;&gt;&lt;span&gt;As for mitigating this issue without it being fixed by Microsoft, a system administrator should follow Microsoft&amp;#39;s recommendations to enable signing and/or encryption on any sensitive service in the domain, especially LDAP. They can also enable Extended Protection for Authentication where the service is protected by TLS. They can also configure the &lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&lt;a class=&quot;c211&quot; href=&quot;https://docs.microsoft.com/en-us/windows/win32/com/setting-machine-wide-security-using-dcomcnfg#setting-system-wide-default-authentication-level&quot;&gt;default DCOM authentication level&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;to be &lt;/span&gt;&lt;span class=&quot;c4&quot;&gt;RPC_C_AUTHN_LEVEL_PKT_INTEGRITY&lt;/span&gt;&lt;span class=&quot;c9&quot;&gt;&amp;nbsp;or above. These changes would make the relay of Kerberos, or NTLM significantly less useful.&lt;/span&gt;&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='https://googleprojectzero.blogspot.com/feeds/5634534606665421566/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='https://googleprojectzero.blogspot.com/2021/10/windows-exploitation-tricks-relaying.html#comment-form' title='0 Comments'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/4838136820032157985/posts/default/5634534606665421566'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/4838136820032157985/posts/default/5634534606665421566'/><link rel='alternate' type='text/html' href='https://googleprojectzero.blogspot.com/2021/10/windows-exploitation-tricks-relaying.html' title='Windows Exploitation Tricks: Relaying DCOM Authentication'/><author><name>Anonymous</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/blank.gif'/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEidf0_fh87eJd499r4V31gq2EoxkP1fptUl5KU9lwkDp87pFnA3qdmY3eGRB2HqY878TZp7JhPF7F_LpNcl0ax6g6bsSWgv9sSBUx-SFUXZGssDtAFvL_P_ROZPAZW9tdiUz_06DNaFgIUsqBit5HpztFCv67tZF8EILTkQmONHwZ9U7H5G0D5Dg079/s72-c/image2%20%285%29.png" height="72" width="72"/><thr:total>0</thr:total></entry>