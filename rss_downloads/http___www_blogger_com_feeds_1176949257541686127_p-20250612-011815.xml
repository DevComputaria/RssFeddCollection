<?xml version='1.0' encoding='UTF-8'?><?xml-stylesheet href="http://www.blogger.com/styles/atom.css" type="text/css"?><entry xmlns='http://www.w3.org/2005/Atom' xmlns:blogger='http://schemas.google.com/blogger/2008' xmlns:georss='http://www.georss.org/georss' xmlns:gd='http://schemas.google.com/g/2005' xmlns:thr='http://purl.org/syndication/thread/1.0'><id>tag:blogger.com,1999:blog-1176949257541686127.post-4848280266237406480</id><published>2022-02-23T12:00:00.013-05:00</published><updated>2022-11-17T17:10:01.795-05:00</updated><title type='text'>Mitigating kernel risks on 32-bit ARM</title><content type='html'>&lt;span class=&quot;byline-author&quot;&gt;Posted by Ard Biesheuvel, Google Open Source Security Team&amp;nbsp;&lt;br /&gt;&lt;/span&gt;&lt;br /&gt;Linux kernel support for the 32-bit ARM architecture was contributed in the late 90s, when there was little corporate involvement in Linux development, and most contributors were students or hobbyists, tinkering with development boards, often without much in the way of documentation.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiRnJFm2Rdr__we5pJygL04gU7hvqbYirI_D67TDuAdVmJ3HJudN4HWEivB7cWjI_ULCBczSI2Ay4LFNZh11Oof-O9fsapy1BZN6Iy9Yq3yKbPaUyR5Hlz8EcKqF1CcYRhq3kkPh1YVC8UzxoTyU0Z87l_cppMSGgqZgVcYUWcvsCvYAWzTdJNbQsnu/s600/mkr-top.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;371&quot; data-original-width=&quot;600&quot; height=&quot;396&quot; src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiRnJFm2Rdr__we5pJygL04gU7hvqbYirI_D67TDuAdVmJ3HJudN4HWEivB7cWjI_ULCBczSI2Ay4LFNZh11Oof-O9fsapy1BZN6Iy9Yq3yKbPaUyR5Hlz8EcKqF1CcYRhq3kkPh1YVC8UzxoTyU0Z87l_cppMSGgqZgVcYUWcvsCvYAWzTdJNbQsnu/w640-h396/mkr-top.png&quot; width=&quot;640&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;br /&gt;Now 20+ years later, 32-bit ARM&#39;s maintainer has downgraded its support level to &lt;a href=&quot;https://git.kernel.org/linus/18bd49043caa8b272649d4868c29133eb0a3d143&quot;&gt;&#39;odd fixes&lt;/a&gt;,&#39; while remaining active as a kernel contributor. This is a common pattern for aging and obsolete architectures: corporate funding for Linux kernel development has tremendously increased the pace of development, but only for architectures with a high return on investment. As a result, the 32-bit ARM port of Linux is essentially in maintenance-only mode, and lacks core Linux advancements such as THREAD_INFO_IN_TASK or VMAP_STACK, which protect against stack overflow attacks.&lt;br /&gt;&lt;br /&gt;The lack of developer attention does not imply that the 32-bit ARM port has ceased to make economic sense, though. Instead, it has evolved from being one of the spearheads of Linux innovation to a stable and mature platform, and while funding its upstream development may not make sense in the long term, deploying 32-bit ARM into the field today most certainly still makes economic sense when margins are razor thin and &lt;a href=&quot;https://en.wikipedia.org/wiki/Bill_of_materials&quot;&gt;BOM&lt;/a&gt; costs need to be kept to an absolute minimum. This is why 32-bit ARM is still widely used in embedded systems like set-top boxes and wireless routers.&lt;br /&gt;&lt;br /&gt;&lt;div&gt;&lt;b&gt;Running 32-bit Linux on 64-bit ARM systems&lt;/b&gt;&lt;br /&gt;&lt;br /&gt;Ironically, at these low price points, the DRAM is actually the dominant component in terms of BOM cost, and many of these 32-bit ARM systems incorporate a cheap ARMv8 &lt;a href=&quot;https://en.wikipedia.org/wiki/System_on_a_chip&quot;&gt;SoC&lt;/a&gt; that happens to be capable of running in 64-bit mode as well. The reason for running 32-bit applications nonetheless is that these generally use less of the expensive DRAM, and can be deployed directly without the need to recompile the binaries. As 32-bit applications don&#39;t need a 64-bit kernel (which itself uses more memory due to its internal use of 64-bit pointers), the product ships with a 32-bit kernel instead.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;If you&#39;re choosing to use a 32-bit kernel for its smaller memory footprint, it&#39;s not without risks. You&#39;ll likely experience performance issues, unpatched vulnerabilities, and unexpected misbehaviors such as:&lt;br /&gt;&lt;br /&gt;&lt;ul style=&quot;text-align: left;&quot;&gt;&lt;li&gt;32-bit kernels generally cannot manage more than 1 GiB of physical memory without resorting to HIGHMEM bouncing, and cannot provide a full virtual address space of 4 GiB to user space, as 64-bit kernels can.&lt;/li&gt;&lt;li&gt;Side channels or other flaws caused by silicon errata may exist that haven&#39;t been mitigated in 32-bit kernels. For example, the hardening against Spectre and Meltdown vulnerabilities were only done for ARMv7 32-bit only CPUs, and many ARMv8 cores running in 32-bit mode may still be vulnerable (only Cortex-A73 and A75 are handled specifically). And in general, silicon flaws in 64-bit parts that affect the 32-bit kernel are less likely to be found or documented, simply because the silicon validation teams donâ€™t prioritize them.&lt;/li&gt;&lt;li&gt;The 32-bit ARM kernel does not implement the elaborate &lt;a href=&quot;https://youtu.be/CUAXCeRjw3c?t=2687&quot;&gt;alternatives patching framework&lt;/a&gt; that is used by other architectures to implement handling of silicon errata, which are particular to certain revisions of certain CPUs. Instead, on 32-bit multiplatform kernels, we simply enable all errata workarounds that may be needed by any of the cores that may ever run the image in question, potentially affecting performance unnecessarily on cores that have no need for them.&lt;/li&gt;&lt;li&gt;Silicon vendors are phasing out 32-bit support in the longer term. Given an ecosystem containing a handful of operating systems and thousands of applications, support for 32-bit operating systems (which is more complex technically) is highly likely to be dropped first. For products with longer life cycles, long-term procurement contracts for components available today are usually much more costly than adjusting the BOM over time and using newer, cheaper parts.&lt;/li&gt;&lt;li&gt;The 32-bit kernel does not implement &lt;a href=&quot;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=f80fb3a3d50843a401dac4b566b3b131da8077a2&quot;&gt;kernel address space randomization&lt;/a&gt;, and even if it did, its comparatively tiny address space simply leaves very little space for randomization. Other hardening features, such as &lt;a href=&quot;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=c55191e96caa9&quot;&gt;rodata=full&lt;/a&gt; or &lt;a href=&quot;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=87143f404f338&quot;&gt;hierarchical eXecute Never attributes&lt;/a&gt;, are missing as well on 32-bit, and are not likely to be implemented, either due to lack of support in the architecture, or because of the complexity of the 32-bit memory management code, which still supports all of the different architecture revisions dating back to the initial Linux port running on the &lt;a href=&quot;https://en.wikipedia.org/wiki/Risc_PC&quot;&gt;Risc PC&lt;/a&gt;.&lt;/li&gt;&lt;/ul&gt;&lt;b&gt;Keeping the 32-bit ARM kernel secure&lt;/b&gt;&lt;br /&gt;&lt;br /&gt;There are cases, though, where using the 32-bit kernel is the only option, e.g., if the CPUs are in fact 32-bit only (which is the case even for some ARMv8 cores such as Cortex-A32), or when relying on an existing 32-bit only codebase running in the kernel (drivers for legacy peripherals). Note that in such cases, it still makes sense to use the most recent kernel version compatible with the hardware, since we are in fact making an effort to enable some of the existing hardening features on 32-bit ARM as well.&lt;br /&gt;&lt;br /&gt;&lt;ul style=&quot;text-align: left;&quot;&gt;&lt;li&gt;&lt;b&gt;THREAD_INFO_IN_TASK for v7 SMP cores&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote style=&quot;border: none; margin: 0px 0px 0px 40px; padding: 0px; text-align: left;&quot;&gt;The v5.16 release of the Linux kernel &lt;a href=&quot;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=18ed1c01a7dd3d7c780b06a49124da237a4c1790&quot;&gt;implements&lt;/a&gt; support for THREAD_INFO_IN_TASK when running on ARMv7 SMP systems. This protects the kernel&#39;s per-task bookkeeping (called thread_info), which lives on the far (and normally unused) end of the stack, against stack overflows which may occur in rare -yet sometimes exploitable- cases where the control flow of the program simply ends up accumulating more state than the stack can hold. (Note that a stack overflow is not the same as a stack buffer overflow, where the overflow happens in the opposite direction.)&lt;/blockquote&gt;&lt;br /&gt;&lt;blockquote style=&quot;border: none; margin: 0px 0px 0px 40px; padding: 0px; text-align: left;&quot;&gt;By moving thread_info off the stack and into the kernel heap, and by using a special SMP CPU register to keep track of its location, we can mitigate the risk of stack overflows resulting in thread_info corruption. However, it does not prevent stack overflows themselves: these may still occur, and result in corruption of other data structures that happen to be adjacent to the task stack in memory.&lt;/blockquote&gt;&lt;ul style=&quot;text-align: left;&quot;&gt;&lt;li&gt;&lt;b&gt;THREAD_INFO_IN_TASK for other cores&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote style=&quot;border: none; margin: 0px 0px 0px 40px; padding: 0px; text-align: left;&quot;&gt;For CPUs that lack this special SMP CPU register, we also proposed an implementation of THREAD_INFO_IN_TASK that is expected to land in v5.18. Instead of a special register, it uses a global variable to keep track of the location of thread_info.&lt;/blockquote&gt;&lt;br /&gt;&lt;br /&gt;&lt;ul style=&quot;text-align: left;&quot;&gt;&lt;li&gt;&lt;b&gt;VMAP_STACK support&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote style=&quot;border: none; margin: 0px 0px 0px 40px; padding: 0px; text-align: left;&quot;&gt;Preventing stack overflows from corrupting unrelated memory contents is the goal of VMAP_STACK, which we are &lt;a href=&quot;https://lore.kernel.org/linux-arm-kernel/20211122092816.2865873-1-ardb@kernel.org/&quot;&gt;enabling for 32-bit ARM&lt;/a&gt; as well. When VMAP_STACK is enabled, kernel mode stacks are allocated from the kernel heap as before, but mapped into a different part of the kernel&#39;s address space, and surrounded by guard regions, which are guaranteed to be kept unpopulated. Given that accesses to such unpopulated regions will trigger an exception, the kernel&#39;s memory management layer can step in and terminate the program as soon as a stack overflow occurs, and prevent it from causing memory corruption.&lt;/blockquote&gt;&lt;br /&gt;&lt;br /&gt;&lt;b&gt;Support for IRQ stacks&lt;/b&gt;&lt;br /&gt;&lt;br /&gt;Coming up with a bounded worst case on which to base the size of the kernel stack is rather hard, especially given the fact that it is shared between the program itself and any exception handling routines that may be called on its behalf, including interrupt handlers. To mitigate the risk of a pathological worst case occurring, where an interrupt fires that needs a lot of stack space right at a time when most of the stack is already being used by the program, we are also &lt;a href=&quot;https://lore.kernel.org/linux-arm-kernel/20211115084732.3704393-1-ardb@kernel.org/&quot;&gt;enabling IRQ_STACKS for 32-bit ARM&lt;/a&gt;, which will run handlers of both hard and soft interrupts from a dedicated stack, one for each CPU. By decoupling the task and interrupt contexts like this, the likelihood that a well-behaved program needs to be terminated due to stack overflow should be all but eliminated.&lt;br /&gt;&lt;b&gt;&lt;br /&gt;&lt;/b&gt;&lt;div&gt;&lt;b&gt;Conclusion&lt;/b&gt;&lt;br /&gt;&lt;br /&gt;With &lt;a href=&quot;https://lore.kernel.org/linux-arm-kernel/20211208092611.1012773-1-ardb@kernel.org/&quot;&gt;these changes&lt;/a&gt; in place, kernel stack overflow protection will be available for all ARM systems supported by Linux, including ancient ones like the Risc PC or &lt;a href=&quot;https://lore.kernel.org/linux-arm-kernel/874k7pn923.wl-maz@kernel.org/&quot;&gt;Netwinder&lt;/a&gt;, provided that it runs a Linux distribution that is &lt;a href=&quot;https://security.googleblog.com/2021/08/linux-kernel-security-done-right.html&quot;&gt;keeping up with the times.&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgLhPK54-AOa_xVMODcHvgFDrZ9pv-EAx3MCIe6mXWp6-Dj0Sv8KEmGVjrFO3bmMxg2tRg1Nd9F511sng0p77SDXzBbpaKyyIvxqw2c7LTAeuO2PmEnWUIlhqTcTqdYVrtCyp7cafMBmJMfe40UM0-Nj-dnRa6OtC3MpINADZiShssmt0vEQL4Nj5ug/s1600/mkr-bottom.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;1600&quot; data-original-width=&quot;1200&quot; height=&quot;400&quot; src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgLhPK54-AOa_xVMODcHvgFDrZ9pv-EAx3MCIe6mXWp6-Dj0Sv8KEmGVjrFO3bmMxg2tRg1Nd9F511sng0p77SDXzBbpaKyyIvxqw2c7LTAeuO2PmEnWUIlhqTcTqdYVrtCyp7cafMBmJMfe40UM0-Nj-dnRa6OtC3MpINADZiShssmt0vEQL4Nj5ug/w300-h400/mkr-bottom.png&quot; width=&quot;300&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;br /&gt;However, relying on legacy hardware and software comes with a risk, and even though we try to help keep users of the 32-bit kernel as safe as we reasonably can, it is not the right choice for new designs that incorporate 64-bit capable hardware.&lt;/div&gt;&lt;/div&gt;</content><link rel='replies' type='application/atom+xml' href='http://security.googleblog.com/feeds/4848280266237406480/comments/default' title='Post Comments'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment/fullpage/post/1176949257541686127/4848280266237406480?isPopup=true' title='0 Comments'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/1176949257541686127/posts/default/4848280266237406480'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/1176949257541686127/posts/default/4848280266237406480'/><link rel='alternate' type='text/html' href='http://security.googleblog.com/2022/02/mitigating-kernel-risks-on-32-bit-arm.html' title='Mitigating kernel risks on 32-bit ARM'/><author><name>Anonymous</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='https://img1.blogblog.com/img/blank.gif'/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiRnJFm2Rdr__we5pJygL04gU7hvqbYirI_D67TDuAdVmJ3HJudN4HWEivB7cWjI_ULCBczSI2Ay4LFNZh11Oof-O9fsapy1BZN6Iy9Yq3yKbPaUyR5Hlz8EcKqF1CcYRhq3kkPh1YVC8UzxoTyU0Z87l_cppMSGgqZgVcYUWcvsCvYAWzTdJNbQsnu/s72-w640-h396-c/mkr-top.png" height="72" width="72"/><thr:total>0</thr:total></entry>