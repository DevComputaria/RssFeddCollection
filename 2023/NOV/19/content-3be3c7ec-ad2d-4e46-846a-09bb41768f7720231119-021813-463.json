{
    "?xml": {
        "@version": "1.0",
        "@encoding": "UTF-8"
    },
    "rss": {
        "@xmlns:dc": "http://purl.org/dc/elements/1.1/",
        "@xmlns:content": "http://purl.org/rss/1.0/modules/content/",
        "@xmlns:atom": "http://www.w3.org/2005/Atom",
        "@version": "2.0",
        "@xmlns:cc": "http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html",
        "channel": {
            "title": {
                "#cdata-section": "Stories by AlanB on Medium"
            },
            "description": {
                "#cdata-section": "Stories by AlanB on Medium"
            },
            "link": "https://medium.com/@alanbavosa?source=rss-b5c3cfc04db6------2",
            "image": {
                "url": "https://cdn-images-1.medium.com/fit/c/150/150/1*P1yy3DvUUjhgi3QvkHq_Mg.jpeg",
                "title": "Stories by AlanB on Medium",
                "link": "https://medium.com/@alanbavosa?source=rss-b5c3cfc04db6------2"
            },
            "generator": "Medium",
            "lastBuildDate": "Sun, 19 Nov 2023 05:18:13 GMT",
            "atom:link": [
                {
                    "@href": "https://medium.com/@alanbavosa/feed",
                    "@rel": "self",
                    "@type": "application/rss+xml"
                },
                {
                    "@href": "http://medium.superfeedr.com",
                    "@rel": "hub"
                }
            ],
            "webMaster": {
                "#cdata-section": "yourfriends@medium.com"
            },
            "item": [
                {
                    "title": {
                        "#cdata-section": "Preventing Living Off the Land Attacks on iOS and Android Apps"
                    },
                    "link": "https://alanbavosa.medium.com/preventing-living-off-the-land-attacks-on-ios-and-android-apps-e58741e78d8?source=rss-b5c3cfc04db6------2",
                    "guid": {
                        "@isPermaLink": "false",
                        "#text": "https://medium.com/p/e58741e78d8"
                    },
                    "category": [
                        {
                            "#cdata-section": "mobile-app-security"
                        },
                        {
                            "#cdata-section": "mobile-app-development"
                        },
                        {
                            "#cdata-section": "hacking"
                        },
                        {
                            "#cdata-section": "mobile-app-developers"
                        },
                        {
                            "#cdata-section": "mobile-apps"
                        }
                    ],
                    "dc:creator": {
                        "#cdata-section": "AlanB"
                    },
                    "pubDate": "Wed, 31 May 2023 23:13:50 GMT",
                    "atom:updated": "2023-05-31T23:13:50.838Z",
                    "content:encoded": {
                        "#cdata-section": "<figure><img alt=\"Preventing Living Off The Land Attacks on Android &amp; iOS Apps\" src=\"https://cdn-images-1.medium.com/max/256/1*ClV1CMf-YuIj4PgSH80AmQ.png\" /><figcaption><strong>Preventing Living Off The Land Attacks on Android &amp; iOS Apps</strong></figcaption></figure><p>For brands that rely on Android and iOS apps as a key part of their business (which is most brands today), protecting the information stored in or used by mobile apps is critical to protecting your intellectual property and ensuring a secure mobile experience for your users. For many organizations, mobile apps these days are the lifeblood of the business. Mobile apps contain a wide variety of valuable information that can be harvested or stolen, ranging from the user’s personally identifiable information (PII), financial info such as credit card numbers, payments and transaction data, network or identity information that can be manipulated to impersonate trusted entities, users and more. Mobile apps can also be reverse-engineered easily to learn exactly how to create perfectly crafted and highly credible attacks that can trick even the most vigilant and sophisticated users or cyber teams. And the scary thing is that hackers can conduct these nefarious activities simply by leveraging what is already in the app today. In fact, this is what’s known as a “Living off the Land attack”.</p><h4><strong>What Are Living Off the Land Attacks?</strong></h4><p>Living Off the Land (LotL) attacks on mobile apps refer to a type of attack that involves exploiting existing software components, features, or tools already present in the target environment to carry out malicious activities. In the context of mobile apps, LotL attacks typically involve abusing built-in features of the app or mobile operating system (such as mobile permissions, intents, accessibility services, developer options, etc) as well as free open-source toolsets (such as Frida, Magisk, ADB, decompilers, and many more) to carry out malicious actions. LotL attacks are often classified as “fileless” because they do not leave any artifacts behind, which also makes them very difficult to detect and prevent using traditional mobile app security approaches. The fact that attackers use existing app components to conduct their attacks does not mean that the damage stops there. LotL attacks can be used to enable new attack vectors or to create malicious artifacts like malware, trojans, and fakes/clones using methods like code injection, swizzling, hooking, dynamic binary instrumentation, and more. Attackers often use LotL attacks as launchpads that allow them to acquire even more powerful attack capabilities or open doors to more harmful attack methods. This is why it’s so important to understand LotL attacks and prevent them from happening in the first place. So keep reading to learn how to do just that. But first, let’s start by exploring a few examples of LotL attacks and understanding their approaches and methods.</p><h4><strong>Reverse Engineering</strong></h4><p>One of the first things most hackers will do before starting an attack campaign is research how the app works, by reverse engineering it using <a href=\"https://www.appdome.com/dev-sec-blog/reversing-mobile-apps-via-static-code-analysis/\">Static Analysis</a> and <a href=\"https://www.appdome.com/how-to/mobile-app-security/mobile-rasp-security/oneshield-no-code-mobile-rasp-explained/\">Dynamic Analysis</a>. With static analysis, attackers analyze the app’s source code and control flows (app logic) to understand what the code does and how the app works, without running the app. Dynamic analysis involves executing the app and interacting with the app using tools such as debuggers, emulators, and virtualized environments to observe, analyze or tamper with the app or its workflows using many different techniques.</p><h4><strong>Hard-Coded Data</strong></h4><p>Many mobile apps come with default credentials, such as usernames and passwords, that are easy to guess or known to attackers. Other times, developers may hard code sensitive information into the app’s code or store such information as text-based information known as ‘strings’. Attackers can easily find such information using standard pen testing or static analysis tools such as decompilers or disassemblers, especially if the application code and strings are not obfuscated or encrypted.</p><h4><strong>Man-in-the-Middle (MitM) Attacks</strong></h4><figure><img alt=\"MitM attacks against mobile applications\" src=\"https://cdn-images-1.medium.com/max/256/1*86HIsrNbo2RK544yPxpdzA.png\" /></figure><p>Mobile MitM attacks target the connection between a mobile app and the server it connects to. Hackers use many methods to achieve MitM attacks, including attaching proxies to insecure network or WiFi connections, exploiting stale session IDs, using fake or forged SSL certificates, and more. Using these kinds of attacks, forged can intercept data transmitted between an attacks app and its server, allowing them to access and manipulate the data. They also can use MitM attacks to impersonate or masquerade as a ‘trusted’ party on either or both ends of the connection.</p><h4><strong>Jailbreaking &amp; Rooting</strong></h4><p>Jailbreaking and rooting are methods in which the attacker escalates privileges to access the underlying OS and file system. Jailbreak and rooting make it easier for the attacker to compromise any app or to disable/bypass existing security measures.</p><figure><img alt=\"Jailbreaking and rooting ios and android\" src=\"https://cdn-images-1.medium.com/max/256/1*0jhhhAAb9ERGbPg7fQOvRw.png\" /></figure><h4><strong>Mobile App Permission Abuse</strong></h4><p>Mobile apps require users to grant specific permissions to access features or data on the device. Attackers use malware to exploit permissions by tricking users into allowing permissions to OS features or resources like the camera, microphone, contacts, location, and much more, which the malware can then use for its own malicious purposes or to gain access to privileged resources.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/518/1*_AQ-4ZP1iZIwLnkiYr6Cjg.png\" /><figcaption>Excessive Mobile App Permissions</figcaption></figure><h4><strong>Abusing Accessibility Services</strong></h4><p>A growing attack trend used against banking trojans and other malware has been their abuse of existing OS features like Android <a href=\"https://developer.android.com/reference/android/accessibilityservice/AccessibilityService\">AccessibilityService</a> to improve the effectiveness of the attacks. For example, the <a href=\"https://thehackernews.com/2022/12/beware-cybercriminals-launch-new.html\">BrasDex</a> malware variant which targets mobile banks in Brazil is capable of carrying out devastating attacks, including the ability to enter data on users’ behalf without any user involvement. Among other capabilities, the malware uses Android AccessibilityService to make unauthorized transactions by moving through mobile app screens and entering the recipients’ data automatically. The transactions don’t raise suspicion as they are performed using a legitimate service straight from a user’s account.</p><blockquote>The <a href=\"https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7491630/\">National Institute of Health conducted one of the most extensive studies</a> of the ways Accessibility services are abused and in particular how such attacks use LotL techniques to evade detection and cover their tracks.</blockquote><h3><strong>How to Prevent LotL Attacks</strong></h3><p>Mobile app security, as well as protection against mobile malware, and mobile fraud, are fundamental requirements that every mobile app dev and cyber team should implement to protect mobile users, mobile data and the application itself from being compromised or attacked. But Living off-the-land attacks on mobile apps can be challenging to detect and prevent because they often use legitimate components and features of the app or the device, and they are also extremely dynamic and highly customized to the target environment that they seek to attack. On top of that, hackers capitalize on the explosion of innovation in the way apps are developed, often using the same tools and automation techniques that developers use to build, deliver and test apps.</p><p>Modern Dev and Cyber teams realize that the only effective way to stay ahead of Living Off the Land attacks is by automating mobile app security. Here at Appdome, we call what we do <strong><em>Cyber Defense Automation,</em></strong> and it all starts with a single platform to automate the process of implementing mobile app security features directly into mobile applications without any coding or dev work. Another important consideration is the need for a “system of record” to track, audit, and version control the security model all within existing toolchains and workflows developers use to build, test, and deliver mobile apps inside the CI/CD development pipeline.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=e58741e78d8\" width=\"1\" height=\"1\" alt=\"\">"
                    }
                },
                {
                    "title": {
                        "#cdata-section": "How to Prevent Malicious Use of Parallel Space and Virtual Space apps?"
                    },
                    "link": "https://alanbavosa.medium.com/how-to-prevent-malicious-use-of-parallel-space-and-virtual-space-apps-fad2e0f57c1a?source=rss-b5c3cfc04db6------2",
                    "guid": {
                        "@isPermaLink": "false",
                        "#text": "https://medium.com/p/fad2e0f57c1a"
                    },
                    "category": [
                        {
                            "#cdata-section": "malware"
                        },
                        {
                            "#cdata-section": "mobile-app-security"
                        },
                        {
                            "#cdata-section": "mobile-hacking"
                        },
                        {
                            "#cdata-section": "hacking-tools"
                        },
                        {
                            "#cdata-section": "parallel-space"
                        }
                    ],
                    "dc:creator": {
                        "#cdata-section": "AlanB"
                    },
                    "pubDate": "Sat, 22 Oct 2022 13:31:40 GMT",
                    "atom:updated": "2022-10-25T21:17:13.750Z",
                    "content:encoded": {
                        "#cdata-section": "<figure><img alt=\"how to block parallel space and other virtual space apps from cheating in mobile games and creating multiple accounts\" src=\"https://cdn-images-1.medium.com/max/1024/1*ixEwV6D4YCtwYy-suTBBRA.png\" /></figure><p>Parallel Space is a popular virtualization app that allows mobile users to make clones of Android apps and create multiple accounts for the same app that can run on the same physical “device”. It works by creating a separate container (an isolated environment where you can run other apps inside the container on the same virtualized environment). I use quotes around the word device because Parallel Space (and any of the apps like it) can run on many different platforms, not just Android. It runs on Android, Mac, Windows as well as emulators like BlueStacks and Nox, which makes it a very flexible tool for modding, cloning apps and using multiple accounts for the same mobile applications. For example, I just made a clone of a hugely popular social media app which I’m running on my personal Android phone and another clone of the same app that I’m running on the BlueStacks emulator. I’m using my ‘real’ ID on one account, and a fabricated ID that I just made up 10 minutes ago on the clones.</p><p>Now some of you might ask ‘so what’s wrong with that’?</p><p>Now, I’m an ethical hacker doing this with good intentions with the permission of the app maker. But most of the folks that use apps like Parallel Space (game cheaters, black hat hackers, cybercriminals, etc) do not ask for permission (they don’t need to), and are usually not acting in the interest of the app maker. And that’s the exact reason why the developers of apps for which Parallel Space targets might want to prevent users from using it (or at least control the manner in which it’s used).</p><p>Let me explain.</p><p>Mobile game developers and app publishers typically design their games with a specific set of design paradigms and usage scenarios. Two very important and very deliberate design assumptions of most mobile games are that they are intended for a single user (ie: a single account) and run on a mobile device (like an Android phone). One of the most important reasons for these design constraints is that it allows developers to ensure a high-quality, consistent, and supportable user experience for their games on which they can build a reliable product and monetization strategy. Apps like Parallel Space violate both of these design constraints and allow mobile users to run apps in virtualized environments and use multiple accounts on the same instance.</p><p>So let’s examine some of the reasons WHY people use ‘second space’ apps like Parallel Space for their own selfish benefit (and to the detriment of the app maker and mobile community at large).</p><h3><strong>Game Cheating</strong></h3><p>One of the most popular uses of apps like Parallel Space is cheating in mobile games to gain an unfair advantage. Parallel Space and virtualization frameworks like it allow game cheaters and hackers to run the target game in a virtualized environment, which benefits them in multiple ways. For one, running in a virtual space gives the cheater flexibility and scale. They can rapidly spin up instances and accounts at-will without needing to run the app on a physical device. Running virtual also allows them to cheat in games without rooting their own Android device, and manipulate RAM, networking elements, and other game properties in order to gain advantages.</p><blockquote>One of the most popular uses of virtual space apps like Parallel Space is mobile game cheating.</blockquote><figure><img alt=\"Parallel space and other virtualization apps help people hide sinister activity in mobile apps.\" src=\"https://cdn-images-1.medium.com/max/508/1*53EnT2uaJdjI67Lm_LLIeQ.png\" /><figcaption>parallel space-cheating apps</figcaption></figure><h3><strong>Cloning, Modding &amp; Multiple Account Creation</strong></h3><p>Another important benefit for cheaters, and perhaps the ‘killer feature’ that drives 90 million downloads of Parallel Space is the ability to create clones and mods of mobile apps/games and use those cloned apps across multiple accounts — all on the same device. Similar “Second Space” apps like <em>Dual Space </em>and <em>2Accounts</em> allow users to create clones of almost any app or game on the Google Play Store. Running apps in multiple accounts is a must-have feature for game cheaters because it gives them a way to keep playing (and cheating) the game even if their account gets banned. Running multiple accounts is also useful in gaining unfair advantages in multiplayer games for many reasons, as it can enhance the cheater’s odds of winning by allowing more control over the game experience.</p><h3><strong>Hiding/cloaking (ie: Invisible Mode)</strong></h3><p>Second Space Apps often allow mobile users to hide the apps that they have cloned, which is a very useful feature for cyber-criminals or game cheaters, who almost always want to conceal their activities. After all, the best cybercrimes are often the ones that go undetected. And while apps like Parallel Space are used heavily for cheating in mobile games, the cloning and cloaking features extend the popularity and usefulness of second space apps to many other types of mobile applications. For example, the ability to create an unlimited number of random accounts and conceal activities enables all kinds of shady and malicious activities like money laundering, surveillance, cyber-bullying in social media apps, or synthetic fraud, credential stuffing, and identity theft in cash apps, loyalty apps, mobile banking apps, and much more.</p><h3><strong>Mobile Permission Harvesting &amp; Abuse</strong></h3><p>Apps like Parallel Space often market themselves as ‘protecting user privacy’, claiming that they keep the user’s private data in a separate container. But the minute you install one Parallel Space, you get barraged with permission requests for every app that you want to use Parallel Space for, and it simply won’t work unless you grant the permissions. Each of those permissions, once granted, can be used in abusive, malicious, and unintended ways that are not always clear to the end-user. If you want to learn more about the hidden dangers of mobile app permissions, check out this <a href=\"https://www.appdome.com/dev-sec-blog/evergreen-malware-evolving-malware-to-scale-fraud-operations/\">blog on mobile malware</a></p><h3><strong>The Mobile Developer Dilemma</strong></h3><p>So what can you do as a mobile developer? On the one hand, it’s obvious to everyone that rampant cheating in mobile games (or in any other app type) is not good for anyone (except for the cheater of course). However, there are several fundamental and difficult problems that mobile game developers must grapple with in order to effectively prevent cheating. For one, there are many many ways to cheat in mobile games — using virtual space apps is just one method. There’s memory editing, hex editing, code injection, binary patching, auto-clickers, hacking in-app purchase logic, and fully automated cheating apps like Lucky Patcher, and many many more. I’ve covered many of these <a href=\"https://www.appdome.com/dev-sec-blog/top-game-modding-techniques-and-how-to-prevent-them/\">popular mobile game cheating methods</a> in another blog.</p><p>Developers may not even know if a specific cheating method is being used to cheat in their game. They may suspect it, but they don’t really know. And even if they were fairly certain, preventing these cheating methods would require developers to build specific defenses into the application’s source code, one defense at a time. That’s an enormous amount of work, especially when using traditional mobile security solutions like open-source libraries or 3rd party SDKs. And finally, there’s the ever-important user experience. Mobile game developers are absolutely paranoid about implementing protections that might negatively impact the user experience.</p><p>Luckily, there‘s a different way. Mobile Developers need a solution that allows them to learn the specific cheating methods that are being used against their apps in the wild, and they also need a build system that allows them to build the specific protection into their game in a fully automated way, right from within their existing development processes.</p><p>Developers use <a href=\"http://www.appdome.com\">Appdome’s</a> No Code DevSecOps Build System to protect apps and games against malicious use of Parallel Space and other Second Space Apps. As a mobile developer, you can protect your Android app or mobile game so that malicious users can’t use apps like Parallel Space, virtualization frameworks, emulators, simulators, app players to create clones, mods or multiple accounts of your app, as well as other types of mobile fraud and/or cheating.</p><p>If you would like to talk more about this topic feel free to drop me an email at abavosa1@gmail.com. And if you’re a mobile developer who’s looking for a way to protect their game or app against virtualization tools, fraud, or malware, go ahead and reach out and I’d be happy to show you how you can build any of these protections into any iOS or Android app in just a few minutes — no coding required.</p><p>Cheers!</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=fad2e0f57c1a\" width=\"1\" height=\"1\" alt=\"\">"
                    }
                },
                {
                    "title": {
                        "#cdata-section": "What “Shift Left” security really means for SDK Vendors"
                    },
                    "link": "https://alanbavosa.medium.com/what-shift-left-security-really-means-for-sdk-vendors-783887638c1a?source=rss-b5c3cfc04db6------2",
                    "guid": {
                        "@isPermaLink": "false",
                        "#text": "https://medium.com/p/783887638c1a"
                    },
                    "dc:creator": {
                        "#cdata-section": "AlanB"
                    },
                    "pubDate": "Fri, 08 Apr 2022 09:00:39 GMT",
                    "atom:updated": "2022-04-08T09:00:39.316Z",
                    "content:encoded": {
                        "#cdata-section": "<p>What “Shift Left” security really means for SDK Vendors</p><p>Shift left your application security. Just press the pause button on your continuous delivery pipeline and ask your developers to download our poorly documented SDK…err…actually email our devrel team for the sdk cuz we don’t publish our sdk to the public. It’s kinda top secret. (Plus bill hasn’t finished writing the sdk yet..he’s almost done with the swift version …the objective C version comes out next quarter. We have android fully covered tho if your app is written 100% in Java and you don’t need all the features on day 1. We don’t have a plug-in for c++ yet, but you don’t really need to secure native libraries anyway)….react native you say? Well hmmmm I think you can download a JavaScript obfuscator from GitHub. Just make sure you ask the developer if they fixed all the CVEs…they probly did. Oh flutter? Nah we don’t think flutter is gonna resonate with the dev community so you might wanna avoid that framework.</p><p>Anyways we’ll get back to you on Monday once we clear your developers to download our SDK. It’s just 1 line of code, conveniently described in 74 pages of jibberish. There’s even some sample code that gives you a rough approximation of how you might be able to just “drop in” the SDK right quick…it’s just a simple hello world app, but ya know most apps are pretty much the same inside these days, so it should “just work”. Once you get done reading the SDK, give us a ring if you have any issues. We’re standing right by to help!!! SHIFT LEFT!!!!</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=783887638c1a\" width=\"1\" height=\"1\" alt=\"\">"
                    }
                },
                {
                    "title": {
                        "#cdata-section": "How to Secure Crypto Wallets and other eWallet Apps"
                    },
                    "link": "https://alanbavosa.medium.com/how-to-secure-crypto-wallets-and-other-ewallet-apps-64fadbe88fcc?source=rss-b5c3cfc04db6------2",
                    "guid": {
                        "@isPermaLink": "false",
                        "#text": "https://medium.com/p/64fadbe88fcc"
                    },
                    "category": [
                        {
                            "#cdata-section": "mobile-app-development"
                        },
                        {
                            "#cdata-section": "mobile-app-security"
                        },
                        {
                            "#cdata-section": "bitcoin"
                        },
                        {
                            "#cdata-section": "cryptocurrency"
                        },
                        {
                            "#cdata-section": "crypto-wallet"
                        }
                    ],
                    "dc:creator": {
                        "#cdata-section": "AlanB"
                    },
                    "pubDate": "Thu, 20 Jan 2022 05:15:32 GMT",
                    "atom:updated": "2022-01-20T05:18:00.328Z",
                    "content:encoded": {
                        "#cdata-section": "<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*omRhtFA7AQKXtfeXFM8GqA.png\" /></figure><p>In this blog post, I’ll discuss the security implications of crypto wallets and offer some tips to mobile developers on how to secure crypto wallets and protect their users’ crypto.</p><p>There’s no denying that the crypto market is on fire. Whether you consider it to be ‘all-hype’ or ‘the future of money’, one thing is clear — lots of people are using crypto wallets and other forms of e-wallets to store, trade, and transact with digital currencies. This trend is clearly shown in the chart below which shows the explosive growth of crypto wallet users worldwide.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*p-NBX7MxeWJVMyvcOkyYsw.png\" /><figcaption>Number of Crypto Wallet Users Worldwide (Source: Statistica)</figcaption></figure><p>No matter how you slice it, where there’s money (be it virtual, real, or ‘doge’), there will also be crime, fraud, theft, trickery and deceit. I know, it’s a cold world..Keep reading to understand the potential security risks involved in using crypto wallets and also how to keep your crypto wallets, eWallets and cryptocurrency safe and secure.</p><h3>What are e-Wallets and Crypto Wallets?</h3><p>An <a href=\"https://en.wikipedia.org/wiki/Digital_wallet\">e-Wallet</a> is a digital financial instrument that allows a customer to use a mobile app and/or device to make payments for goods and services using some form of stored digital currency. Digital currency can be things like frequent flier miles, loyalty points, a linked credit card or even cash. Apple Pay, Google Pay, and Samsung Pay are all examples of e-Wallets.</p><p>A crypto wallet is a specific type of e-wallet that is used to store, trade or transact using a cryptocurrency (like bitcoin or Ethereum). There are many different types of crypto wallets. Examples of some of the most popular crypto wallets are <a href=\"https://www.coinbase.com/\">Coinbase</a>, <a href=\"https://robinhood.com/us/en/\">Robinhood</a>, <a href=\"https://zengo.com/\">ZenGo</a>, and <a href=\"https://crypto.com/exchange/\">Crypto.com</a>. There are 2 main types of electronic crypto wallets — hosted wallets or non-custodial wallets. With a hosted wallet, a third party keeps your crypto for you, similar to how a bank keeps your money in a checking or savings account. With a non-custodial crypto wallet, the customer takes on more control over the account via the possession of a private key that provides full access and control over the account and funds at any time. With Non-custodial accounts, the private key (including where and how it is stored) is the sole responsibility of the customer (these are the types of wallets where you hear horror stories in the news of people who have forgotten or lost their private key and as a result lost millions of dollars of cryptocurrency).</p><p>From a security perspective, both hosted and non-custodial crypto wallets can be hacked if an attacker gains control over the account either by stealing or learning the private key (in the case of non-custodial accounts) or by tricking the hosting provider that they are the legitimate account holder (via phishing, masquerading or good old fashion account takeovers).</p><p>Consider the security breach at <a href=\"https://cryptocurrency.org/news/article/the-biggest-exchange-hacks-in-cryptocurrency-history---part1-mt-gox\">Mt. Gox</a>, a leading Bitcoin exchange that filed for bankruptcy in after $450 million worth of Bitcoins were stolen directly from Mt. Gox cryptocurrency wallets.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*GcZ8qhKbTB1-jKVvHH2PmA.png\" /></figure><p>While there are many methods and techniques hackers use to steal cryptocurrency, mobile applications are one of the weakest links in the attack chain. Even when social engineering and phishing are used as a primary attack technique used to trick or lure the unsuspecting user to reveal sensitive information, mobile applications are often exploited in a blended attack scenario. For example, an attacker may use a phishing technique or classical social engineering to lure a user to download a fake app that masquerades as a crypto wallet but actually contains malicious code inside. Once the unsuspecting user runs the app, the malware inside the app becomes active and monitors the user’s activity, records their keystrokes via keylogger, or phones home for additional exploit code.</p><p>In the case of non-custodial accounts, where the private key is heavily sought after, hackers have been known to target the mobile clipboard using specially crafted malware that abuses legitimate Android methods for reading information that has been copied to the clipboard. In this case, they are betting that the mobile user will eventually use the “copy/paste” feature to copy their private key from wherever they have it stored so that they can access their non-custodial account to get access to cryptocurrency. It’s probably a pretty safe bet that many users are going to copy the private key somewhere, due to the difficulty of memorizing a private key string that looks like this:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*M3amnP4xBLaoRvTjA2TyIQ.png\" /></figure><p>Another popular attack method for stealing crypto keys is through the use of hacking 2FA codes, which are often required as an additional security measure to access hosted crypto wallets. I’ve <a href=\"https://www.appdome.com/mobile-security-threats-malware/how-to-prevent-mfa-bypass-in-mobile-apps/\">written about this topic in past blogs</a> where I discussed how malware is often programmed to steal MFA and 2FA codes — same concept here. The malware can masquerade as a legitimate Android app like Microsoft Word or Adobe Flash, which it uses to trick users into granting permissions that the malware then abuses in a number of ways. Once installed, it quietly records keystrokes and notifications while scanning for bank account apps to monitor.</p><p>And let’s not forget <a href=\"https://www.appdome.com/blog/how-fraudsters-use-screen-overlay-attacks-to-commit-mobile-fraud/\">overlay attacks</a>, which have become a standard method used to attack mobile banking apps around the world. Crypto hackers are learning the use of overlay attacks in tricking users to transmit sensitive information (such as crypto keys or passwords), or to enable permissions or intents that are harmful to the user (such as allowing the crypto hacker to elevate privileges, log keystrokes, or plant backdoors).</p><h3>Best Practices to Secure Crypto Wallets</h3><p>Below is a set of recommended security best practices that I have provided to Appdome customers as a baseline for securing crypto wallets. Not every feature will be required for every app or use case. Instead, mobile developers can use this set of features as ‘mobile app security building blocks’ that they can combine in order to implement a robust security model in their crypto wallet apps:</p><ul><li><a href=\"https://www.appdome.com/how-to/mobile-app-security/no-code-app-shielding/no-code-mobile-app-shielding-resources/\">App Shielding </a>— anti-debugging, anti-tampering and anti-reversing, checksum validation, and prevents binary patching, app re-signing, and other forms of tampering. This is one of the building blocks required to prevent the distribution of fake apps or clones.</li><li><a href=\"https://www.appdome.com/how-to/mobile-app-security/no-code-code-obfuscation/obfuscate-mobile-apps-prevent-reverse-engineering/\">Code Obfuscation</a> — Prevents malicious reverse engineering of the app’s source code and logical structure.</li><li><a href=\"https://www.appdome.com/how-to/mobile-app-security/no-code-data-encryption/prevent-mobile-data-exploits-data-at-rest-encryption/\">Mobile Data Encryption</a> — uses AES-256 to dynamically encrypt all the data stored in the application sandbox and throughout the code in preferences, strings, resources, strings.xml values and java class dex files.</li><li><a href=\"https://www.appdome.com/how-to/mobile-app-security/no-code-jailbreak-root-prevention/protect-ios-apps-against-jailbreaking-using-jailbreak-prevention/\">Jailbreak</a> and <a href=\"https://www.appdome.com/how-to/mobile-app-security/no-code-jailbreak-root-prevention/protect-android-apps-against-rooting/\">Root Prevention</a> — this prevents an iOS app from running on a jailbroken device and an Android app on a rooted device.</li><li><a href=\"https://www.appdome.com/how-to/mobile-app-security/no-code-man-in-the-middle-prevention/use-secure-certificate-pinning-prevent-mitm-attacks/\">Secure Communications</a> — including Man-in-the-middle attack prevention, certificate pinning, certificate validation, and malicious proxy prevention. These features prevent the crypto wallet app from connecting to untrusted servers and protect the app against Man-in-the-Middle attacks, such as when an attacker redirects traffic to their own malicious proxy by swapping out the digital certificate stored inside the app’s trust store.</li><li><a href=\"https://www.appdome.com/how-to/mobile-fraud-prevention/prevent-android-ios-fraud/prevent-keyloggers-android-ios-apps/\">Keylogger Prevention</a> — Auto-detect approved keyboards and stop the use of custom keyboards that may include keylogger software used to exfiltrate keystroke information.</li><li><a href=\"https://www.appdome.com/how-to/mobile-fraud-prevention/prevent-android-ios-fraud/detect-accessibility-service/\">Detect Accessibility Abuse</a> — Detects any application installed on the device that has too many accessibility services permissions. This privilege escalation is common with all Trojans and RATs, which are often used to assist in the stealing of crypto keys.</li><li><a href=\"https://www.appdome.com/how-to/mobile-fraud-prevention/prevent-android-ios-fraud/block-adb/\">Block Android Debug Bridge</a> — Automatically detects Android Debug Bridge (ADB) and prevents the use of ADB for malicious reverse-engineering, debugging, remote shell, etc.</li><li><a href=\"https://www.appdome.com/how-to/mobile-fraud-prevention/prevent-android-ios-fraud/block-screen-overlay-attacks/\">Block Overlay Attacks</a> — Detect and prevent malicious screen overlays, where a fake screen is placed over the real screen and the user is tricked into performing a harmful action (eg: revealing crypto keys, passwords, secrets) or inadvertently granting permissions to malware.</li><li><a href=\"https://www.appdome.com/how-to/mobile-fraud-prevention/prevent-android-ios-malware/block-magisk-manager/\">Block Magisk Manager</a> — Identifies and blocks the use of Magisk Manager, an advanced root bypass, root hiding framework.</li><li><a href=\"https://www.appdome.com/how-to/mobile-fraud-prevention/prevent-android-ios-malware/block-frida-toolkits/\">Block Frida Toolkits</a> — Automatically detect and block dynamic binary instrumentation, method hooking, and malicious code or memory injection that attackers carry out using Frida or Frida-based toolkits.</li></ul><p>Drop me a line and I’d be happy to explain (or demonstrate) how to implement any of the above features in any iOS or Android app.</p><p>Cheers!</p><p>Alan</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=64fadbe88fcc\" width=\"1\" height=\"1\" alt=\"\">"
                    }
                },
                {
                    "title": {
                        "#cdata-section": "What is a Mobile SDK Anyway?"
                    },
                    "link": "https://alanbavosa.medium.com/what-is-a-mobile-sdk-anyway-52c58b0cffc1?source=rss-b5c3cfc04db6------2",
                    "guid": {
                        "@isPermaLink": "false",
                        "#text": "https://medium.com/p/52c58b0cffc1"
                    },
                    "category": [
                        {
                            "#cdata-section": "mobile-sdks"
                        },
                        {
                            "#cdata-section": "sdk"
                        },
                        {
                            "#cdata-section": "mobile-app-development"
                        },
                        {
                            "#cdata-section": "mobile-app-developers"
                        }
                    ],
                    "dc:creator": {
                        "#cdata-section": "AlanB"
                    },
                    "pubDate": "Sat, 14 Aug 2021 00:24:50 GMT",
                    "atom:updated": "2021-08-14T00:40:01.068Z",
                    "content:encoded": {
                        "#cdata-section": "<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*ZrqB4vkL_YhTwGhi60dqoQ.png\" /></figure><p>This is a multi-part blog series on mobile SDKs. I’ll describe mobile SDKs from a comprehensive standpoint and answer all the burning questions you might have about mobile SDKs, including:</p><ul><li>What are mobile SDKs, how are they used, why do people create them, and why are they important to the mobile economy?</li><li>Common use cases for SDKs in mobile apps</li><li>How are SDKs implemented in mobile apps?</li><li>Platform and Framework limitations and other challenges developers face when implementing mobile SDKs</li><li>Hidden costs of manually implementing and updating mobile SDKs in apps.</li><li>What are the security considerations of implementing SDKs</li><li>New and Automated ways to accelerate implementations via automation that accelerate their usage and eliminate unnecessary work</li></ul><h3>What is a Mobile SDK?</h3><p>A mobile software development kit (SDK) is a set of software development tools developers use and implement to deliver new 3rd party capabilities in a mobile application using the service provider’s published APIs. The traditional method for implementing a mobile SDK requires mobile developers to modify the app’s source code according to the instructions provided by a third-party service provider (aka the “SDK provider”). I will refer to this process as ‘manual’ SDK implementation — because in order to successfully deliver the new service in the app, one or more mobile developers needs to modify the app’s source code line by line or ‘by hand’.</p><p>SDKs are created and published by companies of all sizes, from Silicon Valley start-ups to major companies like Facebook, Amazon, Google, Microsoft and Alibaba — for services covering backend infrastructure, mobile advertising, mobile payments, mobile app security, and everything in between.</p><p>For the sake of simplicity, we’ll refer to them all as “SDK providers”. These organizations create SDKs and target them at mobile developers and app publishers, who integrate the SDK into the source code of an existing mobile app during the app development process.</p><p>There are thousands of mobile SDKs (16,842 according to <a href=\"https://www.programmableweb.com/category/all/sdk\">Programmable Web</a>).</p><figure><img alt=\"SDK Growth since 20015. Source: Programmable Web\" src=\"https://cdn-images-1.medium.com/max/1024/0*6ZC8wBkDQ8scN6Dq.jpg\" /><figcaption>Source: Programmable Web</figcaption></figure><p>Every app on the planet contains SDKs, and they play a critical role in how apps function. The SDK analytics firm SafeDK publishes a semi-annual report on SDKs, and for the past several years, the average number of SDKs for B2C apps (i.e.: “Consumer apps”) has hovered right around <a href=\"http://blog.safedk.com/sdk-economy/report-highlights-from-our-2018-yearly-mobile-sdks-trends-report/\">18.2 SDKs per app</a>. For B2E apps (i.e.: ‘Enterprise’ apps), it’s around 12 SDKs per app. For those of you wondering why consumer apps have more SDKs than enterprise apps, just follow the money. The consumer apps are typically free to download and monetize through ads and in-app payments. Both of those require — you guessed it! — SDKs.</p><h3>SDKs Are Everywhere</h3><p>Stating that a ‘mobile app’ is a collection of third-party SDKs and APIs packaged together with the app’s business logic is no exaggeration. Just about every task you’ve ever completed in a mobile app was enabled by an SDK, either directly or indirectly. There are limitless <a href=\"https://mightysignal.com/sdk-category-directory\">SDK categories</a>, including SDKs for authentication, single sign-on (SSO), MFA, app management and distribution, app performance, analytics, messaging, conversational chatbots, data encryption, marketing automation, engagement, surveys, mobile ads, payments, and much more.</p><p>You interact with SDKs every day, whether you know it or not. SDKs are behind the scenes when you order a latte from Starbucks, deposit a check using your bank’s mobile app, pay a buddy using Venmo, search for a restaurant on Yelp, create a dogface emoji on Snapchat, or overpay for a pair of red Prada sneakers on Ebay, and get a strangely similar sneaker ad from Balenciaga the next day.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/382/0*GcCStHM9pqQIwidE\" /></figure><p>In every single case (and millions more), mobile SDKs made the transaction, experience, or interaction possible.</p><h3>Why Are Mobile SDKs Created &amp; How Are They Used?</h3><p>Mobile SDKs are necessary because mobile app developers can’t build every service that the app or its customers require out of the box. There is no predefined standard or middleware layer in the mobile development tool stack that enables an app to discover, connect to and consume new services or APIs on its own. If a developer did not explicitly build the capability to interact with a 3rd-party service into the app’s source code, then that service simply does not exist (as far as the app is concerned).</p><p>Imagine if you were the developer for a ride-sharing app. When you first sat down to build the app, you might sketch out the major components:</p><ul><li>A way to log in through social media accounts;</li><li>A way to pay for the ride;</li><li>A mapping system to show nearby cars;</li><li>A bug tracker to get alerts if the app crashes.</li></ul><p>And that’s just the start of the list. We would not have Uber and Lyft today if the development teams had to write their own authentication, payments, and location software. Fortunately, other companies (we call them “SDK providers,” remember?) do that for them!</p><p>So, going back to our little brainstorm, you might do some research and discover that:</p><ul><li>Facebook provides a great authentication SDK;</li><li>Stripe has an amazing payments SDK;</li><li>Google has a nice mapping SDK, and</li><li>Bugsnag has a great crash reporting SDK.</li></ul><p>SDKs are specific to each platform or OS, and there are variants of the SDK for every OS and/or framework the service intends to reach. The contents of the SDK package can vary, based on factors like: the type of service, the native OS capabilities, the framework used to develop the app, as well as the SDK maturity level.</p><p>Generally speaking, SDKs usually include some combination of the following items (not all SDKs include every element below):</p><ul><li>The SDK provider’s APIs.</li><li>API Reference Guide — a document or website containing the information required to work with the SDK providers API, such as the functions, methods, classes, return types, syntax, naming conventions, arguments, ordering requirements — sometimes including hypothetical examples.</li><li>Authentication requirements — including API keys and authentication tokens or cookies as well as the authentication sequence, validation, redirect URLs, authorization requirements, error codes, security requirements (e.g. MFA, encryption, secrets).<br>This part is absolutely crucial to any SDK implementation because a trust relationship must be established between the mobile app and the service (to ensure that the machines or individuals making the connection requests are legitimate, non-malicious and that the access levels, controls and privileges are established)</li><li>Native and/or non-native libraries</li><li>“Plugins” to reach non-native frameworks or non-native libraries (sometimes)</li><li>Sample code (sometimes)</li><li>Debugging information (sometimes)</li><li>UI elements or additional business logic (sometimes)</li></ul><h3>The Anatomy of a Mobile SDK</h3><p>There are two sides to every SDK implementation: the <strong>mobile application</strong> and the <strong>service</strong> that the mobile application wishes to connect to or consume. But no matter which side you sit on, an SDK is a means to an end.</p><p>The SDK provider views the SDK as a relatively low-cost distribution mechanism to get their service embedded inside apps that they don’t own (but that their target customers use). It’s an easy way to reach a large number of subscribers with a relatively low amount of effort. Much of the work is borne by mobile app developers who implement the SDK.</p><p>On the flip side of the coin, mobile app developers view SDKs as ways to deliver new capabilities or features in their mobile app without building the functionality from scratch. Again, why build your own proprietary mapping algorithms when you can implement Google’s mapping SDKs to use theirs?</p><p>SDKs are a key way that mobile developers build new capabilities into their apps, and before Appdome came along, the ONLY way to implement a mobile SDK was to modify the app’s source code, line by line. It’s a laborious and time-consuming process that involves many repetitive tasks and trial-and-error development. And this process must be repeated throughout the app’s lifecycles for <em>every</em> SDK inside the app.</p><p>To implement any new service in an app, mobile developers must formulate their own mental model on how to modify the app’s source code to consume the new service through its APIs. To do this, they must understand every component of the mobile app (the app’s logic, structure, functions, and the complex relationships between all the above). And they must also understand how the SDK provider’s service works. This process entails quite a bit of subjectivity and interpretation. Also keep in mind that many apps are built by teams of developers, who each write a portion of the code, meaning not every developer knows every part of the app inside and out.</p><p>Stay tuned for the next installment of this blog series where I will break down the nitty-gritty of what an SDK really is, and outline the steps required to implement an SDK into a mobile application. I’ll also discuss the main challenges and pitfalls (things the SDK provider will likely not tell you), and how you can work around them or avoid them altogether. Or at a minimum, you’ll be more informed about what you’re getting into when you undertake a new SDK project.</p><p>Peace!</p><p>Alan</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=52c58b0cffc1\" width=\"1\" height=\"1\" alt=\"\">"
                    }
                },
                {
                    "title": {
                        "#cdata-section": "Reversing Mobile Apps: The Silent Threat of Static Analysis Blog"
                    },
                    "link": "https://alanbavosa.medium.com/reversing-mobile-apps-the-silent-threat-of-static-analysis-blog-1a9e46a653af?source=rss-b5c3cfc04db6------2",
                    "guid": {
                        "@isPermaLink": "false",
                        "#text": "https://medium.com/p/1a9e46a653af"
                    },
                    "category": [
                        {
                            "#cdata-section": "mobile-app-development"
                        },
                        {
                            "#cdata-section": "code-obfuscation"
                        },
                        {
                            "#cdata-section": "mobile-app-security"
                        },
                        {
                            "#cdata-section": "static-code-analysis"
                        },
                        {
                            "#cdata-section": "no-code"
                        }
                    ],
                    "dc:creator": {
                        "#cdata-section": "AlanB"
                    },
                    "pubDate": "Tue, 27 Jul 2021 02:26:01 GMT",
                    "atom:updated": "2021-08-07T04:45:14.552Z",
                    "content:encoded": {
                        "#cdata-section": "<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*WinmzNKUwdXt0r_vQP27tg.png\" /></figure><p>This is a multi-part blog series about Reverse Engineering, a fundamental building block in every hacker’s tool-chain for compromising mobile applications. Throughout different blogs in this series, I’ll explain the major types of reverse engineering (including static analysis and dynamic analysis), including why hackers do it, what information they learn from it, and how they use that information to attack your app, your users, and your business. I’ll also explain how attackers combine reversing methods to break a mobile app’s defenses and understand how your code and application work. I’ll cover some of the most widely used tools and methods hackers use for reversing apps and provide examples of real attack scenarios using different methods. I’ll also cover some of the different options and choices developers have to protect against reversing and explain the pros and cons of each.</p><p>And finally, I’ll explain how you can use automation to deliver more comprehensive protection against reverse engineering than you do today, but with a lot less work.</p><p>First, let’s get a few definitions straight:</p><h3>What is Reverse Engineering?</h3><p><a href=\"https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05c-Reverse-Engineering-and-Tampering.md\">Reverse engineering</a> is the process of breaking something down to understand how it works. In the context of mobile apps, reverse engineering (also known as reversing) involves deconstructing, analyzing, and observing compiled apps to understand the app’s code, logic, and underlying function. The 2 main types of reverse engineering are <strong>Static Analysis</strong> and <strong>Dynamic Analysis</strong>. With static analysis, attackers analyze the app’s source code and control flows (app logic) to understand what the code does and how the app works, without actually running the app.</p><p>Dynamic analysis is the evaluation of a mobile application while it runs, which involves executing and interacting with the app to understand or change its behavior.</p><p>In this first post of the series, I will focus on <strong>Static Analysis</strong>. I’ll cover dynamic analysis in an upcoming blog in this series. You can skip to our resources on <a href=\"https://www.appdome.com/blog/prevent-app-modifications-anti-tampering/\">Dynamic Analysis if you want to start there.</a></p><h3>Who Performs Static Analysis on Mobile Apps and Why?</h3><p>You can learn a lot about an application just by analyzing the source code and this can be done with both good and bad intentions. For example, penetration testers use static analysis to test the app’s security model, uncover weaknesses in the app’s defenses, and even disable security protections (such as anti-tampering or jailbreak/root detection). And black-hat hackers use similar methods to understand the source code, except their intentions are always malicious. Their goal is to use reverse engineering to understand what, where, and how to attack your app. In some cases, they may be after sensitive data about the app or users, which developers often store in the app’s code (inside strings, preference files, resource folders, etc in clear text). They also use reversing to reveal the application’s logic, find critical files/data, analyze and change workflows, or find and exploit vulnerable code or 3rd libraries used in the application, among other things.</p><p>Reversing also helps hackers increase the scope or impact of their attacks and increase their likelihood of success. Hackers often accumulate a large amount of detailed information about the app and its users, which they use later in downstream attacks or to create specially crafted malware. Generally speaking, the more an attacker knows about your app, the more effective their attacks will be.</p><blockquote>Hackers combine reversing methods to break a mobile app’s defenses and understand how your code and application work.</blockquote><h3>How Static Analysis Can Be Used Maliciously</h3><p>Below are some of the ways cybercriminals use the information that they learn from static analysis. There are far more aspects of reverse engineering than can be covered here, so this is not intended to be an exhaustive list.</p><ul><li>To learn information about how the app connects to its backend, which can be used to perform attacks against the app’s servers (eg: credential stuffing, botnet attacks, account takeovers, DoS attacks, etc)</li><li>To find weaknesses in the app’s encryption model, such as weak ciphers, encryption keys stored in the app insecurely. This can be used to crack the app’s encryption or to find valuable data stored inside the app insecurely.</li><li>To harvest or steal data about users by searching for hard-coded information in the app, or data about users that are stored in plain-text in strings, within app preferences, user defaults, or other resource or assets folders that the app needs in order to run.</li><li>To understand the app’s permissions and intents and other components which govern how the app shares data with other apps and interacts with the operating system or other components. These allow external applications to access data in your app, which can potentially leak user data to other applications. This can be abused to craft specific attacks that abuse legitimate functionality or to create malware that masquerades as a legitimate app and tricks users into granting excessive permissions, revealing sensitive information (eg: <a href=\"https://www.appdome.com/blog/how-fraudsters-use-screen-overlay-attacks-to-commit-mobile-fraud/\">screen overlay attacks</a>, <a href=\"https://www.appdome.com/mobile-security-threats-malware/how-to-block-strandhogg-malware/\">StrandHogg</a>)</li><li>To gain intelligence, perform subsequent code modification (such as bypassing or disabling security controls or modifying business logic or workflows).</li><li>To steal intellectual property or create fake versions, clones, or mods of apps</li></ul><h3>How Attackers Conduct Static Analysis</h3><p>So now that we know some of the things that can be accomplished via static analysis, let’s explore how hackers go about doing it. I’ll cover some of the basics of static analysis using examples (In this first post, I’ll focus on Android apps in the examples. I’ll cover iOS in a separate post in this series). To begin static analysis an attacker usually starts by downloading Android and iOS apps from various app stores, where the apps are packaged in binary format (.APKs and .IPAs). An APK or IPA is really just a form of a compressed ZIP file that contains the app, its code, and all the resources the app needs to run. To view the contents of an app binary, all you have to do is extract (unzip) the file. For Android apps, you can simply rename the file extension to .zip, open the folder, and view the contents. If the app is only superficially obfuscated or doesn’t make wide use of encryption, then the hacker’s job is going to be quite easy because they’ll be able to simply read the code, or use a disassembler or decompiler to access and analyze source code.</p><p>Because binary code is not understandable by humans, hackers will usually disassemble or decompile the mobile app to recreate and analyze the source code in the original format that the developer wrote it.</p><p>Popular tools used for such purposes are baskmali, APKTool, JD-GUI, jadx, IDA-Pro, Hopper and a plethora of others.</p><p>Neither exactness nor completeness is required for an attacker to reach their goal of understanding the source code. Depending on the hacker’s goal, they can do plenty of damage just by understanding specific blocks of code.</p><p>So how does a hacker find the source code in the app? There are many ways to do it, and none of them are very difficult to do. Why? Well, all mobile applications are built and packaged according to a defined and well-understood structure.</p><h3>Where is Source Code Located in iOS and Android apps?</h3><p>In native iOS apps, the code is part of the application executable (C/C++/Objective-C/Swift). In native Android apps, code can be found in DEX files (Java/Kotlin) and/or in native libraries (C or C++). With native iOS and Android apps, source code is converted into binary format when the app is compiled.</p><p>In Xamarin apps, which are written in C#, (“C Sharp”) source code is located in DLL files (dynamic link libraries). In non-native apps (hybrid apps) such as Cordova and React Native apps, source code comes in the form of JavaScript, CSS, or HTML files, and is not compiled into binary format the same way as with native apps. Instead, source code for non-native apps is usually <strong>stored inside the app </strong>in a folder when the app is compiled. So to read the source code for non-native apps, decompiling the app is not always necessary if the app is not obfuscated. One only needs to extract the contents (ie: rename the folder and open it and you can see the source code).</p><h3>Main Areas Hackers Target For Static Code Analysis In Android Apps</h3><p>Below are some of the main areas that hackers focus on when performing static analysis of Android apps.</p><ul><li><strong>Android Manifest:</strong> (eg AndroidManifest.xml) contains the app’s metadata, configuration and components. When reversing an .apk the manifest is a good starting point for the hacker to determine the best ‘entry point’ (ie: which classes are most attractive targets to analyze first. You can also learn about the app’s activities, running services, permissions, intents, broadcast receivers and more).</li><li><strong>Classes</strong>: The classes folder (eg: classes.dex) contains the source code (executable Java classes, otherwise known as DEX files) which is ultimately executed by the Android Runtime. Every APK has a single classes.dex file, which references any classes or methods used within an app.</li><li><strong>Strings</strong>: (eg: Java strings, or strings.xml) contains string resources of the Android application, which are often used to store and share text-based information such as usernames/passwords, authentication info, API keys, and more. In many apps, this information is stored in plain-text, and is a favorite target of hackers of all types due to the wealth of valuable information that can be found here.</li><li><strong>Preferences: </strong>(eg: SharedPreferences) — contains persistent information about the user and app, likes, and preferences. For example, some apps may store credit card numbers, personally identifiable information (PII), local currency, location information, etc. in preferences.</li><li><strong>Assets</strong>: contains Images, videos, and other interactive content. With non-native apps and frameworks, the assets folder can include source code files and other data. For example, Cordova or React Native applications will store JavaScript code in the assets folder. Xamarin applications may store DLL files in the “assemblies” folder (which serves a similar purpose as the manifest).</li><li><strong>Resources: </strong>contains resources, images, layout, directories for launcher icons, and may contain string resource or pre-compiled code or resources (strings, colors, styles, etc.)</li><li><strong>lib/:</strong> native libraries (C or C++) used in the application.</li><li><strong>META-INF: </strong>APK metadata, signature information which can be used to re-sign, repackage and redistribute clones or pirated apps</li></ul><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/650/0*TitACzd_5ykS1QtT.png\" /></figure><h3>How To Protect Against Static Code Analysis</h3><p>Code obfuscation is one of the primary methods of preventing static code analysis. Obfuscation is the practice of obscuring source code and application logic to prevent attackers from understanding the meaning, intent or function of your source code, including how it executes instructions or logic — all without changing the underlying function or behavior of the app. Obfuscation is one of the most important ‘first lines of defense’ against malicious reversing.</p><p>There are multiple techniques to obfuscate code, and a comprehensive solution requires implementing several techniques that complement and reinforce each other. The reason you should layer in multiple techniques is to prevent attackers from being able to circumvent any single protection easily by working their way around the obfuscation.</p><p>A robust obfuscation solution will make it easy to implement name obfuscation (renaming methods, objects, variables, classes, libraries), string and resource encryption, encryption of <a href=\"https://www.appdome.com/how-to/mobile-app-security/no-code-data-encryption/encrypt-shared-preferences-android-apps/\">app preferences</a> and <a href=\"https://www.appdome.com/how-to/mobile-app-security/no-code-data-encryption/encrypt-app-preferences-nsuserdefaults-ios-apps/\">user defaults</a>. Additionally, an important protection for Android apps is code packing (obfuscating and/or <a href=\"https://www.appdome.com/how-to/mobile-app-security/no-code-data-encryption/encrypt-java-class-dex-android-apps-protect-data/\">encrypting DEX files aka. Java Classes</a>). In addition, not only is it important to obfuscate the code and libraries, but also the application’s control flows (app logic), including such diverse techniques as <a href=\"https://www.appdome.com/how-to/mobile-app-security/no-code-code-obfuscation/obfuscate-mobile-apps-prevent-reverse-engineering/\">dummy code insertion</a>, replacing function call targets, inserting arbitrary paths into the flow, or making the function tree appear broken to attackers by hiding the original code path or targets in an encrypted location. And finally, it’s always recommended to strip debug information, so that hackers can’t sift through stack traces and easily understand the application’s behavior.</p><p>With Appdome you can implement one or multiple of these the above techniques together in order to reinforce and strengthen the overall defense through a multi-layered approach. For example, many of our customers combine <a href=\"https://www.appdome.com/how-to/mobile-app-security/no-code-code-obfuscation/native-code-obfuscation/\">native code obfuscation</a> with <a href=\"https://www.appdome.com/how-to/mobile-app-security/no-code-code-obfuscation/obfuscate-android-ios-control-flows-methods/\">control flow relocation</a> to protect the code, libraries as well as the application’s logical flows. If your app has non-native code or libraries, you can add <a href=\"https://www.appdome.com/how-to/mobile-app-security/no-code-code-obfuscation/obfuscate-non-native-android-ios-code-frameworks\">Non-native code obfuscation</a>. And it’s always recommended to <a href=\"https://www.appdome.com/how-to/mobile-app-security/no-code-code-obfuscation/remove-debug-information-prevent-reverse-engineering\">Strip Debug Info</a> to remove symbols, and all descriptive information from the application’s binaries, such as identifiers (variable and function names) and source code names/line numbers.</p><p>And with Appdome, you can implement a comprehensive defense in minutes to prevent against both static and <a href=\"https://www.appdome.com/how-to/mobile-app-security/no-code-app-shielding/no-code-mobile-app-shielding-resources/\">dynamic analysis</a>, all without any manual coding, without symbolicating your code, without using a specialized compiler, and without an SDK. This is how Appdome customers are able to obfuscate and protect a large majority of their code instantly, without any of the complexity, inflexibility or arduous line-by-line coding of traditional obfuscation solutions which are bound to a specific coding language.</p><p>Further, Appdome covers all frameworks, all programming languages (Java, Kotlin, Swift, C++, Objective C) all OS platforms, and all non-native or hybrid frameworks (such as React Native, Cordova, Flutter, Xamarin, Ionic, or any of the low-code development frameworks in the market today) all with a single solution.</p><p>The complexity of traditional obfuscation solutions is explained in this <a href=\"https://arxiv.org/pdf/1801.02742.pdf\">leading research paper, which studied millions of Android apps to understand why such a large majority of apps either contained no obfuscation or superficial obfuscation</a> (class name obfuscation only). The simple reason: complexity.</p><p>Bottom line is that in order to make significant progress in improving mobile obfuscation outcomes requires simple automated solutions that developers can implement without slowing down releases or breaking their code.</p><p><em>Originally published at </em><a href=\"https://www.appdome.com/blog/reversing-mobile-apps-via-static-code-analysis/\"><em>https://www.appdome.com</em></a><em> on July 27, 2021.</em></p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=1a9e46a653af\" width=\"1\" height=\"1\" alt=\"\">"
                    }
                },
                {
                    "title": {
                        "#cdata-section": "This blog post is a continuation of my previous blog on how malware adapts itself and evolves based…"
                    },
                    "link": "https://alanbavosa.medium.com/this-blog-post-is-a-continuation-of-my-previous-blog-on-how-malware-adapts-itself-and-evolves-based-d8461d270a8f?source=rss-b5c3cfc04db6------2",
                    "guid": {
                        "@isPermaLink": "false",
                        "#text": "https://medium.com/p/d8461d270a8f"
                    },
                    "dc:creator": {
                        "#cdata-section": "AlanB"
                    },
                    "pubDate": "Wed, 23 Jun 2021 17:09:36 GMT",
                    "atom:updated": "2021-07-08T00:01:20.975Z",
                    "content:encoded": {
                        "#cdata-section": "<blockquote>DevSec Blog | How to Block StrandHogg Malware on Android Apps</blockquote><figure><img alt=\"How mobile malware adapts and changes based on the environment and how that enances its ability to prey on ususpecting users.\" src=\"https://cdn-images-1.medium.com/max/400/0*Nqxfpgo5lHs0C_jA.jpg\" /></figure><blockquote>Overlay Attacks — a New Spin on an Old Trick —How StrandHogg innovates To Stay Relevent</blockquote><p>This blog post is a continuation of my <a href=\"https://www.appdome.com/mobile-security-threats-malware/evergreen-malware-evolving-malware-to-scale-fraud-operations/\">previous blog on how malware adapts itself and evolves</a> based on conditions it encounters in its environment. StrandHogg and StrandHogg 2.0 overlay malware variants are perfect examples of this. I’ll examine how later StrandHogg variants have become more powerful over time, and how all variants abuse normal Android functions to specifically target apps that use those functions. I’ll also show how StrandHogg uses a combination of trickery, privilege escalation, and abuse of Android platform functions to evade detection, expand its attack surface, and multiply the ways it can be used in mobile fraud.</p><h3>What is StrandHogg?</h3><p><a href=\"https://www.helpnetsecurity.com/2020/05/28/cve-2020-0096/\">StrandHogg </a>is an Android vulnerability found in multiple Android versions in which mobile malware imitates legitimate Android apps and then uses Android functionality in an abusive manner, allowing a malicious app to hijack a legitimate app running on the same device — potentially exposing private SMS messages and photos, login credentials, GPS movements, phone conversations and more.</p><p>StrandHogg uses multiple methods to abuse standard Android functions and exploit software vulnerabilities as part of an overlay attack. In an overlay attack, specially crafted malware is used to trick mobile users to interact with malicious content that is hidden from their view, concealed, covered by another button or window, or disguised in some other way. The malware is usually designed to contextually match up with the app’s logic and interaction patterns in order to deceive the mobile user that the requested action is desirable or beneficial to them. But in reality, the opposite is true (ie: the action that the user performs benefits the attacker, usually in the form of privilege escalations, that could allow them to take control over the environments, assume the user’s identity, or hijack/harvest their data and more).</p><p>In order for an overlay attack to be successful, the malicious content must be non-obvious to users and undetectable by malware detection software, and the methods that StrandHogg uses to abuse Android functions do exactly that. You can <a href=\"https://www.appdome.com/blog/how-fraudsters-use-screen-overlay-attacks-to-commit-mobile-fraud/\">read more about overlay attacks in this blog</a>. I’ll now explain how StrandHogg does all of these nasty things, how it can exploit both host apps and target apps, and how it abuses normal Android functionality, a classic example of <a href=\"https://owasp.org/www-project-mobile-top-10/2016-risks/m1-improper-platform-usage\">OWASP “Improper Platform Usage</a>”. But don’t worry, with Appdome you can block StrandHogg malware from attacking your Android apps. Keep reading to learn how.</p><h3>How Does StrandHogg work?</h3><p>In all variants of StrandHogg, a malicious app installed on an Android device runs in the background, and then uses ‘task hijacking’ to impersonate legitimate apps on the same device. This is normally carried out via an overlay attack. When a normal app icon or button is clicked, a malicious ‘overlay’ is executed instead of what the user thinks they clicked on. Once executed the malicious app tricks victims to grant app-permissions to the malicious app or to send sensitive information to an attacker. This allows attackers to do things like steal pin codes, bypass multi-factor authentication, intercept or read SMS messages, or initiate a click-bot that launches a barrage of automated ad ‘clicks’ in a mobile game or shopping app to generate fraudulent ad revenue).</p><p>Here’s a diagram showing how StrandHogg works in 2 common scenarios, The first scenario shows an overlay attack where StrandHogg overlays a fake login screen to steal banking credentials.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/650/0*w0X4Pr73ekkytCuz.jpeg\" /></figure><p>Scenario 1: StrandHogg Fake app screen overlay to steal credentials</p><p>The second scenario shows how StrandHogg can be used to impersonate a legitimate app to trick users into granting permissions to the malicious app (while the user thinks they are granting permissions to the legitimate app). If successful, such an attack could allow an attacker to take control over an app/environment/account, intercept text messages, record conversations, conduct ransomware attacks and more.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/650/0*maJ5r1kgK199Z_F0.jpeg\" /></figure><p>Scenario 2: StrandHogg screen overlay for privilege escalation via permission harvesting</p><h3>How is StrandHogg 2.0 Different Than Earlier Variants</h3><p>StrandHogg 2.0 is an updated version of the overlay malware that uses different exploit methods which allow for greater scale and make it harder to detect. Specifically, StrandHogg 2.0 carries out exploits using “<a href=\"https://owasp.org/www-community/vulnerabilities/Unsafe_use_of_Reflection\">reflection</a>“, which allows the malware to assume the identity of legitimate apps dynamically during runtime at the click of a single button, and also in a way that is specifically tailored to the resources/assets of the target apps that StrandHogg encounters. In earlier variants of StrandHogg, all of the required app permissions had to be declared in the Android manifest upfront.</p><p>As a result, earlier StrandHogg variants could only be carried out on apps one at a time. StrandHogg 2.0 can be exploited against many apps simultaneously at scale.</p><h3>How to Block StrandHogg Malware using Appdome</h3><p>Appdome’s <a href=\"https://www.appdome.com/how-to/mobile-fraud-prevention/prevent-android-ios-fraud/block-screen-overlay-attacks/\">Block App Overlay Attacks feature</a> can be used to protect Android apps against overlay attacks, including StrandHogg and StrandHogg 2. Using Appdome’s no-code mobile app security and fraud prevention platform, developers can build overlay attack protection into any Android app in minutes without coding, and without an SDK, gateway, or separate app running on the device. This equips the Android app with all the capabilities it needs to defend itself against overlay attacks and other forms of mobile fraud.</p><p>If you want to learn more about any of these features or see them in action, feel free to <a href=\"https://www.appdome.com/request-a-demo/request-a-demo-mobile-malware-prevention/\">request a demo</a> to see how Appdome helps mobile developers automate mobile app security and prevent mobile fraud fast — for any app frameworks, and without changing developer workflows.</p><p><em>Originally published at </em><a href=\"https://www.appdome.com/blog/how-to-block-strandhogg-malware/\"><em>https://www.appdome.com</em></a><em> on June 23, 2021.</em></p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=d8461d270a8f\" width=\"1\" height=\"1\" alt=\"\">"
                    }
                },
                {
                    "title": {
                        "#cdata-section": "Most Mobile Apps Can Be Hacked In 15 Minutes or Less"
                    },
                    "link": "https://alanbavosa.medium.com/most-mobile-apps-can-be-hacked-in-15-minutes-or-less-8cc2b8542b4f?source=rss-b5c3cfc04db6------2",
                    "guid": {
                        "@isPermaLink": "false",
                        "#text": "https://medium.com/p/8cc2b8542b4f"
                    },
                    "dc:creator": {
                        "#cdata-section": "AlanB"
                    },
                    "pubDate": "Fri, 28 May 2021 00:00:00 GMT",
                    "atom:updated": "2021-06-23T19:03:37.597Z",
                    "content:encoded": {
                        "#cdata-section": "<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*4cwKA1-8h8Mp2GIrkvtKyA.png\" /><figcaption>Most Mobile Apps Can Be Hacked In 15 Minutes</figcaption></figure><p>The state of mobile app security is weak AF; a large majority of Android and iOS apps lack even the most basic security protections and can be compromised with very little time and effort. At my company, our white-hat security team routinely tests a wide variety of Android and iOS apps across all industries and segments. A vast majority of them can be cracked in 15 minutes or less using free tools and ‘white-box’ pen-testing methods. In general, here’s what we find for most mobile apps:</p><p><strong>1.Lack of App Shielding Tamper Protection <br></strong> The very first layer of defense in any mobile app security strategy should consist of hardening or “shielding” the app by implementing basic runtime application self-protection (RASP) measures like anti-tampering, anti-debugging, anti-reversing, and jailbreak/rooting prevention. For example, many apps we come across either don’t implement tamper prevention or use a 3rd party open source library implemented in largely un-obfuscated code. That kind of solution is easily bypassed.</p><p><strong>2. Lack of Obfuscation<br></strong> Code obfuscation makes it difficult for attackers to understand an app’s source code and control flows. Without obfuscation, mobile app binaries (.apks and .ipas) be disassembled and/or decompiled very easily using a wide variety of free tools. And using dynamic instrumentation tools like Frida, attackers can hook into applications and inject code dynamically.</p><p><strong>3. Weak or Insufficient Encryption<br></strong> Most apps don’t encrypt data stored in the app, in strings, preferences or resource folders, which leaves sensitive mobile user data in the clear.</p><p><strong>There’s a Better Way to Secure Mobile Apps <br></strong> Closing such large security gaps requires a multilayered app defense made up of complementary and self-reinforcing features that protect apps against tampering, reversing, rooting/jailbreaking, mobile fraud, and also that encrypt all sensitive data in all states (at rest, in transit, and in use).</p><p>Bottom line, the only way to do that is to <strong>automate mobile app security</strong>. And only then can you <em>REALLY</em> make security an integral part of the app lifecycle. That’s what true DevSecOps is. And until you do that, the “Sec” in DevSecOps is just a pipedream on a marketing slide. That’s right, I said it.</p><p>You can <a href=\"https://beta.darkreading.com/application-security/most-mobile-apps-can-be-compromised-in-15-minutes-or-less\">read the full article on Dark Reading</a>.</p><p>If you want to SEE how to secure any iOS or Android app in a few minutes, with no-code or coding, drop me a line at alan@appdome.com and I’ll show you personally.</p><p><em>Originally published at </em><a href=\"https://www.darkreading.com/application-security/most-mobile-apps-can-be-compromised-in-15-minutes-or-less-/a/d-id/1341087\"><em>https://beta.darkreading.com</em></a><em> on May 28, 2021.</em></p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=8cc2b8542b4f\" width=\"1\" height=\"1\" alt=\"\">"
                    }
                },
                {
                    "title": {
                        "#cdata-section": "Why Hackers (and Pen Testers) Jailbreak iOS"
                    },
                    "link": "https://alanbavosa.medium.com/why-hackers-and-pen-testers-jailbreak-ios-d27d147b626f?source=rss-b5c3cfc04db6------2",
                    "guid": {
                        "@isPermaLink": "false",
                        "#text": "https://medium.com/p/d27d147b626f"
                    },
                    "category": [
                        {
                            "#cdata-section": "ios"
                        },
                        {
                            "#cdata-section": "jailbreaking"
                        },
                        {
                            "#cdata-section": "mobile-app-security"
                        },
                        {
                            "#cdata-section": "jailbreak-ios-11"
                        },
                        {
                            "#cdata-section": "mobile-app-development"
                        }
                    ],
                    "dc:creator": {
                        "#cdata-section": "AlanB"
                    },
                    "pubDate": "Sun, 07 Mar 2021 00:03:37 GMT",
                    "atom:updated": "2021-03-07T00:03:37.203Z",
                    "content:encoded": {
                        "#cdata-section": "<figure><img alt=\"Hackers Jailbreak iPhones to compromise iOS and gain full administrative control over the enviorment\" src=\"https://cdn-images-1.medium.com/max/738/1*6DFoLbbaSxlFYdEdqwCdgQ.png\" /></figure><h4>And why no mobile app is safe on a Jailbroken iPhone</h4><h3>What is Jailbreaking iOS — ie: What does it mean to Jailbreak an iPhone?</h3><p>Jailbreaking is the process of unlocking the iOS operating system on an Apple mobile device. Jailbreaking is a form of administrative privilege escalation, which bypasses Apple’s restrictions, resulting in full administrative control over the OS (the highest level of administrative privilege possible). Jailbreaking is often accomplished by exploiting bugs in Apple’s software/firmware or modifying system kernels to allow read and write access to the file system. Jailbreaking is one of the primary methods/tools for <strong>every hacker</strong> — both black hat hackers and white hat hackers (eg: penetration testers or security researchers). They all use Jailbreaking in similar ways (to compromise the security model of mobile devices, the operating system, and any app running on the device). The main difference is that black hat hackers have malicious intent, while white-hat hackers generally have non-malicious intent.</p><h3>Below are the Top reasons people Jailbreak iOS:</h3><ol><li>To bypass Apple’s restrictions around installing software or connecting to alternative app store (repos) like Cydia.</li><li>To customize the OS, to change the behavior of their phone/operating system in ways that Apple does not support</li><li>Developers Jailbreak iOS to access and modify the file system, test new app builds with a wider selection of tools, to test the security model of their app</li><li>Gamers or hackers Jailbreak iOS to install game mods, tweaks, cheat tools, and more advanced hacking tools.</li><li>Pen testers and Hackers Jailbreak iOS to gain an advantage in compromising the security model, to expose weaknesses in mobile app protections, to disable anti-tampering or other security protections, to turn off security SDKs that have been hard-coded to the app.</li></ol><p>Whatever the intent, Jailbreaking makes every hacker’s job much easier because it gives them a significant advantage in compromising the security model, due to the elevated level of privilege and full administrative control that Jailbreaking enables. You can think of Jailbreaking as a ‘gateway’ hacking tool: In other words, Jailbreaking is a fundamental hacking tool that gives hackers one or more of the following advantages:</p><ul><li>Jailbreaking makes it possible to obtain or use more advanced hacking tools (unfettered access to alternative repositories like Cydia, where hackers can obtain tweaks, mods, fake apps, clones, or get access to more powerful hacking or cheating tools).</li><li>Using Jailbreaking, hackers can achieve more powerful outcomes with just about any tool (e.g.: use FRIDA to perform dynamic code injection, function hooking, method swizzling. These are all methods by which hackers alter the logical control flows of a mobile app to replace intended app behaviors with their own malicious behaviors.</li><li>Jailbreaking enables hackers to use a much more extensive variety of hacking methods (e.g.:use emulators to alter memory and bypass in-app purchases in mobile games, to disable mobile advertising SDKs, to set-up a malware beacon inside the app)</li><li>Jailbreaking makes it easier to bypass security controls or protections (e.g.: disable anti-tampering protections, turn off digital rights management checks, disable mobile threat detection (MTD) SDKs in the source code.</li></ul><p>Jailbreaking results in a compromised security model, where you cannot trust any signals coming from the device (because on a Jailbroken device, the hacker is in control and change modify the signals to achieve their desired outcome). And while many of the above methods are still possible without Jailbreaking, there’s no question that Jailbreaking makes them better, easier, more powerful, etc. Any iOS app that runs on a Jailbroken device is in a vulnerable state, where hackers can amplify and increase the magnitude of their attacks — all with less effort.</p><blockquote>Bottom line: Jailbreaking results in a compromised security model, where you cannot trust any signals coming from the device (because on a Jailbroken device, the hacker is in control and modify the signals to say or report whatever outcome they want — which is never good for your app.</blockquote><h3>What is Jailbreak Bypass (aka Jailbreak Hiding)?</h3><p>Hackers use Jailbreak Bypass and Jailbreak Hiding tools to evade Jailbreak detection/protections. As mentioned above, Jailbreaking makes it easier to hack iOS apps and to compromise the mobile security model. So if a mobile app is protected with Jailbreak detection or Jailbreak protection, hackers will try to either bypass the protection or hide the fact that the device is Jailbroken. If they can evade detection, then they can operate in a Jailbreak state longer (doing whatever activity they used Jailbreak to achieve in the first place): such as play the game for free longer, or use more advanced or automated tools like emulators to modify in-app purchases, use FRIDA to inject malicious code, to use IDA-Pro to create a call graph to trace the app’s source code, to modify app workflows, or send fake signals to unsuspecting users to make their attacks seem more legitimate/credible.</p><p>Hackers combine Jailbreak tools with Jailbreak bypass tools to kill two birds with one stone. For example, hackers combine the use of Jailbreak tools like <strong>CheckRa1n,</strong> <strong>Unc0ver, Zylon, PlankFilza, Chimera </strong>etc, (which they use to Jailbreak iOS), alongside special-purpose Jailbreak Bypass or Jailbreak hiding tools like <strong>FlyJB</strong>, <strong>JailProtect</strong>, <strong>Liberty Lite</strong>, <strong>TweakRestrictor</strong>, <strong>KernBypass</strong>. The first set of tools is used to achieve Jailbreak status, while the second set of tools is used to conceal the fact that the device is Jailbroken or to bypass Jailbreak protection/detection mechanisms in the app.</p><h3>How to Protect iOS Apps against Jailbreak and Jailbreaking Hiding Tools</h3><p>As a mobile app developer, you have several options when it comes to building <strong>Jailbreak Prevention</strong> into your app. The purpose of jailbreak prevention is to build runtime protections into your app that allow it to defend itself if it’s running on a device that has been jailbroken. You have DIY options (such as implementing 3rd party libraries or 3rd party commercial SDKs). These both require mobile developers to code the solution themselves by modifying the source code of the mobile app according to the rough guidelines of the 3rd party libraries and/or SDK. Alternatively, you can use a no-code mobile development and security platform like Appdome to build <a href=\"https://www.appdome.com/no-code-mobile-integration-knowledge-base/appdome-enhanced-jailbreak-and-root-detection/\">Jailbreak Prevention</a> into any iOS app for you — without coding. Whatever way you go, be sure to pick a solution that can do the following:</p><ul><li>Perform continuous Jailbreak checks — not just upon app initialization</li><li>Detect at multiple code and API layers — eg: Native code and non-native code and APIs. This is especially important if your app is built in a cross-platform or <a href=\"https://medium.com/swlh/native-vs-non-native-mobile-apps-whats-the-difference-b3a641e06f52#:~:text=Native%20apps%20are%20compiled%20to,compiled%20directly%20into%20binary%20code.\">non-native framework like React Native, Cordova, Xamarin</a>, etc, or if the app is built with multiple programming languages (Swift + Objective C). Building protections into your app that have dependencies on the specific coding language may mean that you need to implement multiple solutions in order to ensure broad protection</li><li>Detect Jailbreak via multiple detection mechanisms: inspect for changes made in superuser status, detect irregular file system modifications, detect attempts to circumvent Apple’s app-signing procedures.</li><li>Detect Jailbreak hiding and Jailbreak bypass tools like FlyJB or Liberty Lite. This is especially important because as I said before, Jailbreaking is one of the top ‘go-to’ tools of every hacker, and they will go through extreme measures in order to continue using Jailbreak reliably.</li><li>Jailbreak prevention should be a part of a cohesive, layered security defense, where it <strong>complements </strong>other security protections like app shielding, anti-tampering, anti-debugging, RASP, encryption, and obfuscation. This is especially important because hackers have many tools, methods, and techniques at their disposal when it comes to hacking mobile apps. It’s important to understand that mobile apps sit in public app stores where anybody can download the app and reverse engineer it, either by extracting the binary or run it thru a disassembler/decompiler to access the source code in minutes. If that’s not enough, chances are, the code is largely unobfuscated and the data largely unencrypted. And at best, maybe there’s a lightweight anti-tampering library in the app (which a moderately experienced developer/hacker can diable in about 5 minutes). On a Jailbroken device, an app that is so lightly protected doesn’t stand a chance. And if you do implement Jailbreak prevention via DIY methods, it’s important that the Jailbreak protection isn’t the ONLY protection in the app. Because if the hacker can’t jailbreak the phone, they can still decompile, debug, and reverse engineer their way to obtain what they are looking for — usually that’s your customer’s data.</li></ul><p>The best Jailbreak defense is one that self-detects, operates at multple layers, and reinfornces other protections in the app. There’s no silver bullet in mobile app security. As always, keep safe and keep your mobile apps and users safe too.</p><p>PS: At Appdome we’re at work on a new no-code mobile app security offering which is specifically designed to protect iOS and Android apps that are under constant bombardment by experienced, motivated hackers using specialized tools. Key industry segments are mobile games, retail and fintech. If you have such an app, I’d love to hear your use case. We might have space for you in our private Beta program (which I happen to run). As thanks for participating in the Beta, our white hat ‘red team’ will perform a <strong>free penetration test</strong> on your app. And if you secure your app on Appdome (which takes less than 5 minutes), we’ll guarantee that your app will pass a future penetration test.</p><p>Drop me a line at alan@appdome.com</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=d27d147b626f\" width=\"1\" height=\"1\" alt=\"\">"
                    }
                },
                {
                    "title": {
                        "#cdata-section": "Prevent Mobile Phishing Without Coding"
                    },
                    "link": "https://medium.com/swlh/prevent-mobile-phishing-without-coding-a1c04187217e?source=rss-b5c3cfc04db6------2",
                    "guid": {
                        "@isPermaLink": "false",
                        "#text": "https://medium.com/p/a1c04187217e"
                    },
                    "category": [
                        {
                            "#cdata-section": "cybersecurity"
                        },
                        {
                            "#cdata-section": "mobile-security"
                        },
                        {
                            "#cdata-section": "mobile-app-development"
                        },
                        {
                            "#cdata-section": "phishing-attacks"
                        },
                        {
                            "#cdata-section": "mobile-app-security"
                        }
                    ],
                    "dc:creator": {
                        "#cdata-section": "AlanB"
                    },
                    "pubDate": "Mon, 11 Jan 2021 04:04:55 GMT",
                    "atom:updated": "2022-05-12T17:38:07.506Z",
                    "content:encoded": {
                        "#cdata-section": "<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*_10n08YzVLWwGDB11Ng0Og.png\" /></figure><h3>How to use SSL Certificate Validation &amp; Certificate Pinning to Prevent Phishing</h3><h3>What is Mobile Phishing?</h3><p>Mobile <a href=\"https://en.wikipedia.org/wiki/Phishing\">Phishing</a> is a cybercrime in which an attacker impersonates a legitimate/trusted institution and uses social engineering techniques to trick mobile users into doing what the hacker wants. The goal of phishing is usually either to trick mobile users into providing sensitive information (e.g. PII, username/password, SS #, banking details, credit card info, etc) or to download/install malware (for example using a fake app, or clone, or malware embedded inside a legitimate app). There are many <a href=\"https://www.phishing.org/phishing-techniques\">many different forms and variants of phishing</a>, such as spearphishing (high-value targets, usually execs), vishing (voicemail based), smishing (SMS based), and much more. Phishing is one of the most versatile and reliable attack methods of all time, and it’s often used as a raw material in blended attacks (such as MitM attacks, ransomware, malware/trojan propagation, session hijacking, etc). You can think of phishing as a ‘swiss-army-knife’ of cybercrime, except that phishing actually works! CSO Online published a nice article on the <a href=\"https://www.csoonline.com/article/3235520/15-real-world-phishing-examples-and-how-to-recognize-them.html\">Top 14 Real-World Phishing Attacks</a>, so you can get a feel for just how practical, versatile, reliable, and lucrative Phishing can be to a hacker.</p><p>Pharming is a variant of phishing in which the mobile user’s session is redirected to a fake, malicious website. For example, instead of my bank resolving to x.x.x.1, my bank now resolves to x.x.x.2 which is really the attacker’s fake bank site made up to look like my bank’s site.<br> There are some pretty creative ways for pharming &amp; phishing to work such as <a href=\"https://en.wikipedia.org/wiki/DNS_spoofing\">DNS Spoofing</a> also called Cache Poisoning. Regardless of the method, once the user connects to the malicious site, the attacker attempts to harvest sensitive information.</p><h3><strong>What is Certificate pinning?</strong></h3><p><a href=\"https://owasp.org/www-community/controls/Certificate_and_Public_Key_Pinning\">Certificate Pinning</a> is the process of embedding a mobile app with valid SSL certificate for known trusted servers. An application which pins a certificate or public key no longer depends on external elements — (such as DNS or intermediate/public certificate authorities) — when making security decisions relating to a peer server’s identity. In mobile, the most common form of certificate pinning is embedding the server certificates inside the mobile app to ensure that the server certificate is always trusted. This will prevent hackers from presenting modified fraudulent certificates to the mobile app in an attempt to redirect the mobile user to a malicious site.SSL certificate validation helps to ensure that the SSL certificate files that link details about an organization with a cryptographic key are valid. SSL certificate validation helps ensure your app is using an authentic certificate. It can further go on to pin or link a host to a certificate on your app so that a mismatch, such as in the case of a pharming attack, will generate an alert or trigger another action based on how you implement the feature on Appdome.</p><p>SSL Certificate validation and pinning can be used together to combat mobile pharming by determining “yes” the certificate is authentic and “yes” the expected host is the host that the app is connected to. If it doesn’t match, the app should alert the user. For a deeper dive on certificates and certificate pinning, <a href=\"https://youtu.be/JqC8g6IuP9k\">check out this video on MitM attacks</a>.</p><h3><strong>How to Add Certificate Validation and Certificate Pinning in Any Mobile App without Coding</strong></h3><p>Appdome’s no-code security build system enables developers and security folks to implement their choice of <a href=\"https://www.appdome.com/no-code-mobile-integration-knowledge-base/appdome-\">Mobile App Security</a> features (including <a href=\"https://www.sciencedirect.com/topics/computer-science/certificate-validation\">SSL Cetificate Validation</a> <a href=\"https://www.appdome.com/no-code-mobile-integration-knowledge-base/configuring-smart-certificate-pinning/\">Certificate Pinning</a> and many other features) in any iOS or Android app in minutes, without coding. This prevents mobile Phishing and Pharming by always ensuring that the SSL/TLS certificate of the server is valid and has not been tampered with by attackers.</p><p>When you build a mobile app with SSL certificate validation, the app’s SSL certificates are validated to ensure they are authentic every time a connection attempt occurs. If the certificate validation fails, e.g. because of a fraudulent certificate, the session will be blocked or dropped, and a notification will be displayed to the mobile app user.</p><p>In addition, you can also add certificate pinning to any app for additional protection. This is the process of linking a host to a specific certificate or a CA (Certificate Authority). Pinning helps to ensure that that destination matches the originally pinned certificate your app expects and that the certificate has not been forged. This is also useful for attacks where sessions terminate on a malicious proxy as part of a Mobile MitM attack (aka: Man-in-the-Middle attack).</p><p>Mobile developers can implement certificate pinning by itself or in combination with other security features, such as anti-tampering, data-at-rest encryption, or code obfuscation — all without any coding or development effort. This enables developers to increase the security of their apps and build a layered defense in minutes, all within thier existing app lifecycle and dev workflows.</p><p>Thanks for reading! To learn more about how to add security protections to mobile apps without coding, visit our <a href=\"https://www.appdome.com/appdome-blog/\">Dev+Sec blog</a>.</p><p>Drop me a line with any comments!</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=a1c04187217e\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/swlh/prevent-mobile-phishing-without-coding-a1c04187217e\">Prevent Mobile Phishing Without Coding</a> was originally published in <a href=\"https://medium.com/swlh\">The Startup</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"
                    }
                }
            ]
        }
    }
}